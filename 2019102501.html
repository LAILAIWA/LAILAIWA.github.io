<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的算法相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——算法">
<meta property="og:url" content="http://linyishui.top/2019102501.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的算法相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-10-25T08:23:37.000Z">
<meta property="article:modified_time" content="2025-02-24T15:52:34.292Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://linyishui.top/2019102501.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019102501.html","path":"2019102501.html","title":"面试整理——算法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——算法 | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E7%BB%BC%E5%90%88"><span class="nav-text">一.综合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95"><span class="nav-text">Leetcode解题方法记录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">数组&#x2F;字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-text">链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">一维动态规划</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BF%AB%E6%8E%92%EF%BC%9F"><span class="nav-text">问：讲下常见的排序算法及其复杂度？怎么实现一个快排？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9F"><span class="nav-text">问：二分查找？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">二.数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%A0%91%E4%B8%80%E8%88%AC%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%8C%E9%93%BE%E8%A1%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">问：树一般怎么实现，链表怎么实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A0%86%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E4%B8%8B%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">问：堆是怎么实现？小根堆如何插入数据，讲一下过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%EF%BC%9F"><span class="nav-text">问：判断链表是否有环？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="nav-text">问：树的前序、中序、后序遍历？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%9D%9E%E9%80%92%E5%BD%92%E4%B8%94%E4%B8%8D%E7%94%A8%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%EF%BC%88%E4%B8%8D%E7%94%A8%E6%A0%88%EF%BC%89%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F"><span class="nav-text">问：非递归且不用额外空间（不用栈），如何遍历二叉树？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A0%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A0%EF%BC%9F"><span class="nav-text">问：二叉树的深度优先搜素和广度优先搜素？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F"><span class="nav-text">问：讲讲红黑树？如何计算红黑树的时间复杂度？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8CAVL%E6%A0%91%EF%BC%9F"><span class="nav-text">问：红黑树和AVL树？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E5%95%A5redis-zset%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8%E8%80%8C%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">问：为啥redis zset使用跳跃链表而不用红黑树实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B7%B3%E8%A1%A8%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：跳表和二叉树的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%8B%E8%B7%B3%E8%A1%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F"><span class="nav-text">问：讲下跳表怎么实现的?哈夫曼编码是怎么回事？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFB%E6%A0%91%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFB-%E6%A0%91%EF%BC%9F%E4%BA%8C%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：什么是B树？什么是B+树？二者的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%89%E7%94%A8%E8%B7%B3%E8%A1%A8%EF%BC%8C%E8%80%8C%E6%98%AFB-%E6%A0%91"><span class="nav-text">问：数据库索引为什么不选用跳表，而是B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：图的数据结构？遍历方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9F"><span class="nav-text">问：动态规划？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%EF%BC%9F"><span class="nav-text">问：哈夫曼编码？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-text">问：贪心算法？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98"><span class="nav-text">三. 基础算法题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">1. 数组和字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Two-Sum-%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%EF%BC%8C%E6%89%BE%E5%87%BA%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0"><span class="nav-text">Two Sum 问题：给定一个整数数组，找出和为目标值的两个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">回文：判断一个字符串是否是回文字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%8F%8D%E8%BD%AC%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%8D%E8%BD%AC%EF%BC%88%E4%B8%8D%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-text">字符反转：实现字符串的反转（不用内置函数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%EF%BC%88Kadane%E2%80%99s-Algorithm%EF%BC%89"><span class="nav-text">动态规划：找到一个数组中连续子数组的最大和（Kadane’s Algorithm）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%88Anagram%EF%BC%89"><span class="nav-text">给定两个字符串，判断是否是字母异位词（Anagram）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%90%9C%E7%B4%A2"><span class="nav-text">2. 排序与搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">实现快速排序和归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC%EF%BC%88%E5%A6%82-4-5-6-7-0-1-2-%EF%BC%89"><span class="nav-text">在一个旋转排序数组中查找目标值（如 [4, 5, 6, 7, 0, 1, 2]）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">找出第 K 个最大的元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98"><span class="nav-text">中级算法题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%93%BE%E8%A1%A8"><span class="nav-text">1. 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-text">反转一个单向链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%EF%BC%8C%E5%B9%B6%E6%89%BE%E5%88%B0%E7%8E%AF%E7%9A%84%E8%B5%B7%E5%A7%8B%E7%82%B9"><span class="nav-text">判断一个链表是否有环，并找到环的起始点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-text">合并两个排序的链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BA%A4%E7%82%B9"><span class="nav-text">给定两个链表，找到它们的交点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%91%E4%B8%8E%E5%9B%BE"><span class="nav-text">2. 树与图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-text">实现二叉树的前序、中序、后序遍历（递归与非递归）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-text">求二叉树的最大深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="nav-text">验证一个二叉树是否是二叉搜索树（BST）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88LCA%EF%BC%89"><span class="nav-text">找到二叉树中两个节点的最近公共祖先（LCA）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89"><span class="nav-text">实现图的深度优先搜索（DFS）和广度优先搜索（BFS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%9B%BE%E6%98%AF%E5%90%A6%E6%98%AF%E8%BF%9E%E9%80%9A%E5%9B%BE"><span class="nav-text">判断一个图是否是连通图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">3. 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%EF%BC%88Fibonacci-%E6%95%B0%E5%88%97%E5%8F%98%E7%A7%8D%EF%BC%89"><span class="nav-text">爬楼梯问题（Fibonacci 数列变种）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89"><span class="nav-text">找到最长上升子序列（LIS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%BE%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BB%99%E5%AE%9A%E7%A1%AC%E5%B8%81%E9%9D%A2%E5%80%BC%E6%95%B0%E7%BB%84%EF%BC%8C%E6%B1%82%E6%9C%80%E5%B0%91%E7%A1%AC%E5%B8%81%E6%95%B0%E4%BD%BF%E5%BE%97%E6%80%BB%E9%87%91%E9%A2%9D%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC"><span class="nav-text">找零钱问题：给定硬币面值数组，求最少硬币数使得总金额为目标值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-text">编辑距离问题：计算两个字符串的最小编辑距离</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-text">4. 贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98"><span class="nav-text">分发糖果问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="nav-text">合并区间问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E5%8F%AF%E4%BB%A5%E8%A3%85%E5%85%A5%E8%83%8C%E5%8C%85%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%EF%BC%880-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-text">找出可以装入背包的最大价值（0&#x2F;1 背包问题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98"><span class="nav-text">活动选择问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98"><span class="nav-text">高级算法题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-text">1. 位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%EF%BC%89"><span class="nav-text">找到数组中只出现一次的数字（其他数字出现两次）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B8%AA%E6%95%B0"><span class="nav-text">找出两个整数的二进制位的不同个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95"><span class="nav-text">不使用加减乘除实现加法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%86%E6%B2%BB%E6%B3%95"><span class="nav-text">2. 分治法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B9%98%E6%B3%95%EF%BC%88Karatsuba-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-text">实现大整数的快速乘法（Karatsuba 算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E4%B8%AA%E6%95%B0"><span class="nav-text">求数组中的逆序对个数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">3. 高级数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-LRU-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-text">实现 LRU 缓存机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-text">用栈实现队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">设计一个支持常数时间插入、删除和随机访问的数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9B%BE%E8%AE%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="nav-text">4. 图论与网络流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%EF%BC%88Dijkstra-%E7%AE%97%E6%B3%95%EF%BC%8CFloyd-Warshall-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-text">最短路径问题（Dijkstra 算法，Floyd-Warshall 算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Kruskal-%E6%88%96-Prim-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-text">最小生成树（Kruskal 或 Prim 算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98%EF%BC%88Edmonds-Karp-%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-text">最大流问题（Edmonds-Karp 算法）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D"><span class="nav-text">5. 字符串匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-KMP-%E7%AE%97%E6%B3%95"><span class="nav-text">实现 KMP 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">查找字符串中最长的回文子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Trie-%E6%A0%91"><span class="nav-text">实现Trie 树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">实现一个固定大小的滑动窗口最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">模拟生产者消费者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">设计一个电梯调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E7%BB%84%E4%BC%9A%E8%AE%AE%E6%97%B6%E9%97%B4%E6%AE%B5%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%89%E6%8E%92%E6%89%80%E6%9C%89%E4%BC%9A%E8%AE%AE"><span class="nav-text">给定一组会议时间段，判断是否可以安排所有会议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%E7%BB%99%E5%91%98%E5%B7%A5%EF%BC%8C%E4%BD%BF%E5%BE%97%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4%E6%9C%80%E7%9F%AD"><span class="nav-text">分配任务给员工，使得完成所有任务所需的时间最短</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E6%89%8B%E6%92%95"><span class="nav-text">四.手撕</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%89%BE%E5%87%BA%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E9%9A%94%E8%B7%9D%E7%A6%BB%E6%9C%80%E9%95%BF%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%EF%BC%9F"><span class="nav-text">问：找出无序数组中相隔距离最长的逆序对？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AArand5-%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%9D%87%E5%8C%80%E7%9A%84rand7-%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F"><span class="nav-text">问：给出一个rand5()，实现一个分布均匀的rand7()生成器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">问：实现堆排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BB%99%E4%BA%86%E9%95%BF%E5%BA%A6%E4%B8%BAN%E7%9A%84%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E8%A6%81%E6%B1%82%E8%BE%93%E5%87%BA%E7%AC%AC10%E5%A4%A7%E7%9A%84%E6%95%B0%E3%80%82"><span class="nav-text">问：给了长度为N的有重复元素的数组，要求输出第10大的数。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="nav-text">问：手写一个对象池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7-Hash-%E7%AE%97%E6%B3%95%EF%BC%9F%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-text">问：一致性 Hash 算法？其应用场景？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ATopK-%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：TopK 问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%95%E7%9D%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%8BLRU%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-text">问：试着实现一下LRU算法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%80%E4%B8%AA%E4%BA%BA%E4%BB%8E%E8%B5%B7%E7%82%B9%E5%87%BA%E5%8F%91%EF%BC%8C%E5%88%9D%E5%A7%8B%E7%94%9F%E5%91%BD%E5%80%BC%E4%B8%BAn%EF%BC%8C%E6%AF%8F%E6%AC%A1%E5%8F%AF%E4%BB%A5%E5%90%91%E5%89%8D%E8%B7%B3k%E6%AD%A5%E5%B9%B6%E6%B6%88%E8%80%97k%E7%82%B9%E7%94%9F%E5%91%BD%E5%80%BC%EF%BC%8C%E8%B7%AF%E4%B8%8A%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%E9%83%BD%E6%9C%89%E6%81%A2%E5%A4%8D%E7%94%9F%E5%91%BD%E5%80%BC%E7%9A%84%E5%A5%BD%E8%98%91%E8%8F%87%EF%BC%8C%E5%92%8C%E6%89%A3%E9%99%A4%E7%94%9F%E5%91%BD%E5%80%BC%E7%9A%84%E5%9D%8F%E8%98%91%E8%8F%87%EF%BC%8C%E4%BA%BA%E7%9A%84%E7%94%9F%E5%91%BD%E5%80%BC%E4%B8%8D%E8%83%BD%E4%B8%BA0%E3%80%82%E9%97%AE%E8%AF%A5%E4%BA%BA%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E6%97%B6%E7%9A%84%E6%9C%80%E5%A4%A7%E5%89%A9%E4%BD%99%E7%94%9F%E5%91%BD%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%83%BD%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%EF%BC%8C%E8%BF%94%E5%9B%9E-1%E3%80%82"><span class="nav-text">问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Aleetcode%E5%8E%9F%E9%A2%98%EF%BC%8C%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E3%80%82%E7%BB%99%E4%B8%80%E7%BB%84%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%EF%BC%8C%E5%8F%AA%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E4%BA%A4%E6%98%93%EF%BC%8C%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%AC%A1%E4%BA%A4%E6%98%93%EF%BC%8C%E5%88%A9%E6%B6%A6%E5%8F%88%E6%98%AF%E5%A4%9A%E5%B0%91%E5%91%A2%EF%BC%9F"><span class="nav-text">问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%9C%89%E5%A4%A7%E9%87%8F%E5%B7%B2%E7%9F%A5%E7%9A%84url%E7%BD%91%E5%9D%80%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84url%E7%BD%91%E5%9D%80%EF%BC%8C%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B0%E7%BD%91%E5%9D%80%E6%98%AF%E5%90%A6%E5%92%8C%E5%B7%B2%E7%9F%A5%E7%BD%91%E5%9D%80%E9%87%8D%E5%A4%8D%EF%BC%9F"><span class="nav-text">问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Aurl%E5%BE%88%E9%95%BF%EF%BC%8C%E5%AD%97%E5%85%B8%E6%A0%91%E5%BE%88%E5%8D%A0%E7%A9%BA%E9%97%B4%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">问：url很长，字典树很占空间怎么办？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BD%A0%E5%88%9A%E6%89%8D%E6%8F%90%E5%88%B0%E4%BA%86%E5%93%88%E5%B8%8C%EF%BC%8C%E9%82%A3%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%93%88%E5%B8%8C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">问：你刚才提到了哈希，那说一下哈希的实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%93%88%E5%B8%8C%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%EF%BC%9F%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="nav-text">问：哈希在什么情况下需要扩容？怎么扩容？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A9%E5%AE%B9%E6%97%B6%E6%98%AF%E7%BF%BB%E4%B8%80%E5%80%8D%E5%91%A2%EF%BC%9F%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E5%80%8D%EF%BC%8C%E4%B8%89%E5%80%8D%EF%BC%9F"><span class="nav-text">问：为什么扩容时是翻一倍呢？而不是两倍，三倍？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%9C%89%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%9C%80%E8%A6%81%E8%BF%81%E7%A7%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E5%81%9C%E6%AD%A2%E5%AF%B9%E5%A4%96%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-text">问：服务器中有大量数据需要迁移，如何在不停止对外服务的情况下安全的迁移数据？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%84%B6%E5%90%8E%E9%9D%A2%E8%AF%95%E5%AE%98%E6%8F%90%E9%86%92%E8%A6%81%E6%98%AF%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%95%B0%E6%8D%AE%E8%A2%AB%E6%94%B9%E5%8A%A8%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">问：然后面试官提醒要是数据迁移的过程中数据被改动了怎么办？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8A%A0%E9%94%81%E4%BA%86%E4%B8%8D%E5%B0%B1%E6%B2%A1%E6%B3%95%E5%AF%B9%E5%A4%96%E6%9C%8D%E5%8A%A1%E4%BA%86%E5%90%97%EF%BC%9F"><span class="nav-text">问：加锁了不就没法对外服务了吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E9%82%A3%E4%B8%AA%E6%95%B0%EF%BC%8C%E5%85%B6%E4%BB%96%E9%83%BD%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%EF%BC%9B-%E5%BC%82%E6%88%96-%E6%8E%A5%E4%B8%8A%E9%9D%A2%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E5%91%A2%EF%BC%9F"><span class="nav-text">问：找出数组中只出现一次的那个数，其他都出现两次；(异或) 接上面，如果数组中有两个数只出现一次呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ABST%E4%B8%AD%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E5%B7%AE%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">问：BST中任意两个节点差的最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%AD%E5%BF%83%E5%AF%B9%E7%A7%B0"><span class="nav-text">问：判断二叉树是否中心对称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98"><span class="nav-text">问：大数相乘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BB%99%E6%88%91%E4%B8%80%E5%BC%A0%E7%BA%B8%EF%BC%8C%E7%94%BB%E4%BA%86%E4%B8%80%E4%B8%AA%E4%B9%9D%E6%96%B9%E6%A0%BC%EF%BC%8C%E9%83%BD%E5%A1%AB%E4%BA%86%E6%95%B0%E5%AD%97%EF%BC%8C%E7%BB%99%E4%B8%80%E4%B8%AAMN%E7%9F%A9%E9%98%B5%EF%BC%8C%E4%BB%8E1%E5%BC%80%E5%A7%8B%E9%80%86%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E8%BF%99MN%E4%B8%AA%E6%95%B0%EF%BC%8C%E8%A6%81%E6%B1%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%8E%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%85%88%E8%AF%B4%E4%B8%8B%E6%80%9D%E8%B7%AF"><span class="nav-text">问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%95%B0%E7%BB%84A%EF%BC%8C2-n%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8Cn%E4%B8%AA%E5%A5%87%E6%95%B0%E3%80%81n%E4%B8%AA%E5%81%B6%E6%95%B0%EF%BC%8C%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%EF%BC%8C%E4%BD%BF%E5%BE%97%E6%95%B0%E7%BB%84%E5%A5%87%E6%95%B0%E4%B8%8B%E6%A0%87%E4%BD%8D%E7%BD%AE%E6%94%BE%E7%BD%AE%E7%9A%84%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%EF%BC%8C%E5%81%B6%E6%95%B0%E4%B8%8B%E6%A0%87%E4%BD%8D%E7%BD%AE%E6%94%BE%E7%BD%AE%E7%9A%84%E9%83%BD%E6%98%AF%E5%81%B6%E6%95%B0%E3%80%82%E5%85%88%E8%AF%B4%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-text">问：数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E5%AD%97%E6%95%B0%E5%B9%B6%E6%89%93%E5%8D%B0-%E9%99%A4%E4%BA%86%E8%BF%99%E4%B8%AA%E8%BF%98%E6%9C%89%E5%88%AB%E7%9A%84%E5%8A%9E%E6%B3%95%E5%90%97%EF%BC%9F"><span class="nav-text">问：统计一个字符串的字符出现字数并打印?除了这个还有别的办法吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%9F"><span class="nav-text">问：全排列？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%81%87%E5%A6%82%E4%BD%A0%E6%AD%A3%E5%9C%A8%E5%81%9A%E6%B7%98%E5%AE%9D%E7%9A%84%E5%90%8E%E5%8F%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E5%87%BA1000-2000%E4%BB%B7%E6%A0%BC%E7%9A%84%E5%95%86%E5%93%81%EF%BC%9F"><span class="nav-text">问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%9C%89%E4%B8%80%E4%B8%AA%E5%9C%BA%E6%99%AF%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%83%8C%E5%8C%85%E9%87%8C%EF%BC%8C%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%BE%80%E9%87%8C%E9%9D%A2%E7%A7%BB%E8%B5%B0%E4%B8%9C%E8%A5%BF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%E5%8A%A0%E9%94%81%E5%8A%A0%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%EF%BC%8C%E8%AE%A9%E4%BD%A0%E6%9D%A5%E5%86%99%E4%BB%A3%E7%A0%81%E4%BD%A0%E6%80%8E%E4%B9%88%E5%86%99%EF%BC%9F"><span class="nav-text">问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E9%87%8C%E6%98%AF%E5%90%A6%E6%9C%89%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%9F"><span class="nav-text">问：判断数组里是否有和为指定值的两个数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AF%B9%E7%AC%94%E8%AF%95%E9%A2%98%E8%BF%9B%E8%A1%8C%E6%8F%90%E9%97%AE%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%89%BE%E5%88%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%A7%A3%E6%B3%95%E5%90%97%EF%BC%9F"><span class="nav-text">问：对笔试题进行提问？有没找到更好的解法吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E7%AE%97%E6%B3%95%E9%A2%98"><span class="nav-text">三.算法题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2-Arrays-Strings"><span class="nav-text">3.1 数组&#x2F;字符串 Arrays&#x2F;Strings</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-lt-easy-gt-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">88.合并两个有序数组 &lt;easy&gt; 双指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-lt-easy-gt-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">27. 移除元素 &lt;easy&gt; 双指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-lt-easy-gt-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">26. 删除有序数组中的重复项 &lt;easy&gt; 双指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II-lt-medium-gt-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">80. 删除有序数组中的重复项 II &lt;medium&gt; 双指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0-lt-easy-gt"><span class="nav-text">169. 多数元素 &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84-lt-medium-gt-%E6%95%B0%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="nav-text">189. 轮转数组 &lt;medium&gt; 数组翻转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-lt-easy-gt"><span class="nav-text">121. 买卖股票的最佳时机 &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II-lt-medium-gt"><span class="nav-text">122. 买卖股票的最佳时机 II &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-lt-medium-gt-%E8%B4%AA%E5%BF%83"><span class="nav-text">55. 跳跃游戏 &lt;medium&gt; 贪心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II-lt-medium-gt-%E8%B4%AA%E5%BF%83"><span class="nav-text">45. 跳跃游戏 II &lt;medium&gt; 贪心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#274-H-%E6%8C%87%E6%95%B0-lt-medium-gt"><span class="nav-text">274. H 指数 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#380-O-1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0-lt-medium-gt"><span class="nav-text">380. O(1) 时间插入、删除和获取随机元素 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF-lt-medium-gt-%E9%A2%9D%E5%A4%96%E6%95%B0%E7%BB%84"><span class="nav-text">238. 除自身以外数组的乘积  &lt;medium&gt; 额外数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99-lt-medium-gt"><span class="nav-text">134. 加油站  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C-lt-hard-gt"><span class="nav-text">135. 分发糖果  &lt;hard&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-lt-hard-gt-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">42. 接雨水  &lt;hard&gt; 双指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0-lt-easy-gt"><span class="nav-text">13. 罗马数字转整数 &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97-lt-medium-gt-%E8%B4%AA%E5%BF%83"><span class="nav-text">12. 整数转罗马数字  &lt;medium&gt; 贪心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6-lt-easy-gt"><span class="nav-text">58. 最后一个单词的长度 &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-lt-easy-gt"><span class="nav-text">14. 最长公共前缀 &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-lt-medium-gt"><span class="nav-text">151. 反转字符串中的单词  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-N-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2-lt-medium-gt"><span class="nav-text">6. N 字形变换  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87-lt-easy-gt"><span class="nav-text">28. 找出字符串中第一个匹配项的下标 &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#68-%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90-lt-hard-gt-%E8%B4%AA%E5%BF%83"><span class="nav-text">68. 文本左右对齐  &lt;hard&gt; 贪心</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%8F%8C%E6%8C%87%E9%92%88-Two-Pointers"><span class="nav-text">3.2 双指针 Two Pointers</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2-lt-easy-gt"><span class="nav-text">125. 验证回文串  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-lt-easy-gt"><span class="nav-text">392. 判断子序列  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-lt-medium-gt"><span class="nav-text">167. 两数之和 II - 输入有序数组  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-lt-medium-gt"><span class="nav-text">11. 盛最多水的容器  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-lt-medium-gt"><span class="nav-text">15. 三数之和  &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-Sliding-Window"><span class="nav-text">3.3 滑动窗口 Sliding Window</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-lt-medium-gt"><span class="nav-text">209. 长度最小的子数组  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-lt-medium-gt"><span class="nav-text">3. 无重复字符的最长子串  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2-lt-hard-gt"><span class="nav-text">30. 串联所有单词的子串  &lt;hard&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-lt-hard-gt"><span class="nav-text">76. 最小覆盖子串  &lt;hard&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E7%9F%A9%E9%98%B5-Matrix"><span class="nav-text">3.4 矩阵 Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-lt-medium-gt"><span class="nav-text">36. 有效的数独  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-lt-medium-gt"><span class="nav-text">54. 螺旋矩阵  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-lt-medium-gt"><span class="nav-text">48. 旋转图像  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6-lt-medium-gt"><span class="nav-text">73. 矩阵置零  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F-lt-medium-gt"><span class="nav-text">289. 生命游戏  &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%93%88%E5%B8%8C%E8%A1%A8-Hash-Table"><span class="nav-text">3.5 哈希表 Hash Table</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1-lt-easy-gt"><span class="nav-text">383. 赎金信  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2-lt-easy-gt"><span class="nav-text">205. 同构字符串  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B-lt-easy-gt"><span class="nav-text">290. 单词规律  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-lt-medium-gt"><span class="nav-text">49. 字母异位词分组  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-lt-medium-gt-1"><span class="nav-text">49. 字母异位词分组  &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-lt-easy-gt"><span class="nav-text">1. 两数之和  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0-lt-easy-gt"><span class="nav-text">202. 快乐数  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II-lt-easy-gt"><span class="nav-text">219. 存在重复元素 II  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-lt-medium-gt"><span class="nav-text">128. 最长连续序列 &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%8C%BA%E9%97%B4-Interval"><span class="nav-text">3.6 区间 Interval</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4-lt-easy-gt"><span class="nav-text">228. 汇总区间  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-lt-medium-gt"><span class="nav-text">56. 合并区间 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4-lt-medium-gt"><span class="nav-text">57. 插入区间 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83-lt-medium-gt"><span class="nav-text">452. 用最少数量的箭引爆气球 &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E6%A0%88-Stack"><span class="nav-text">3.7 栈 Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-lt-easy-gt"><span class="nav-text">20. 有效的括号  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84-lt-medium-gt"><span class="nav-text">71. 简化路径 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88-lt-medium-gt"><span class="nav-text">155. 最小栈 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-lt-medium-gt"><span class="nav-text">150. 逆波兰表达式求值 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-lt-hard-gt"><span class="nav-text">224. 基本计算器  &lt;hard&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-%E9%93%BE%E8%A1%A8-Linked-List"><span class="nav-text">3.8 链表 Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-lt-easy-gt-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-text">141. 环形链表  &lt;easy&gt; 快慢指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-lt-medium-gt-%E9%81%8D%E5%8E%86%E5%90%8C%E6%97%B6%E9%80%90%E4%BD%8D%E7%9B%B8%E5%8A%A0"><span class="nav-text">2. 两数相加 &lt;medium&gt; 遍历同时逐位相加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-lt-easy-gt"><span class="nav-text">21. 合并两个有序链表  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6-lt-medium-gt-Map%E6%8F%90%E5%89%8D%E7%94%9F%E6%88%90%E5%A4%8D%E5%88%B6%E8%8A%82%E7%82%B9"><span class="nav-text">138. 随机链表的复制 &lt;medium&gt; Map提前生成复制节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II-lt-medium-gt"><span class="nav-text">92. 反转链表 II &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-text">143. 重排链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-lt-hard-gt"><span class="nav-text">25. K 个一组翻转链表  &lt;hard&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9-lt-medium-gt"><span class="nav-text">19. 删除链表的倒数第 N 个结点 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II-lt-medium-gt"><span class="nav-text">82. 删除排序链表中的重复元素 II &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8-lt-medium-gt"><span class="nav-text">61. 旋转链表 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8-lt-medium-gt"><span class="nav-text">86. 分隔链表 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#146-LRU-%E7%BC%93%E5%AD%98-lt-medium-gt"><span class="nav-text">146. LRU 缓存 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#460-LFU%E7%BC%93%E5%AD%98-lt-hard-gt"><span class="nav-text">460. LFU缓存 &lt;hard&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-%E4%BA%8C%E5%8F%89%E6%A0%91-Binary-Tree"><span class="nav-text">3.9 二叉树 Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-lt-easy-gt"><span class="nav-text">104. 二叉树的最大深度  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91-lt-easy-gt"><span class="nav-text">100. 相同的树  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-lt-easy-gt"><span class="nav-text">226. 翻转二叉树  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-lt-easy-gt"><span class="nav-text">101. 对称二叉树  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-lt-medium-gt"><span class="nav-text">105. 从前序与中序遍历序列构造二叉树 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-lt-medium-gt"><span class="nav-text">106. 从中序与后序遍历序列构造二叉树 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II-lt-medium-gt"><span class="nav-text">117. 填充每个节点的下一个右侧节点指针 II &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-lt-medium-gt"><span class="nav-text">114. 二叉树展开为链表 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-lt-easy-gt"><span class="nav-text">112. 路径总和  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#129-%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C-lt-medium-gt"><span class="nav-text">129. 求根节点到叶节点数字之和 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-lt-hard-gt"><span class="nav-text">124. 二叉树中的最大路径和  &lt;hard&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8-lt-medium-gt"><span class="nav-text">173. 二叉搜索树迭代器 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-lt-easy-gt"><span class="nav-text">222. 完全二叉树的节点个数  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-lt-medium-gt"><span class="nav-text">236. 二叉树的最近公共祖先 &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-Binary-Tree-Level-Order-Traversal"><span class="nav-text">3.10 二叉树层次遍历 Binary Tree Level Order Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-lt-medium-gt"><span class="nav-text">199. 二叉树的右视图 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC-lt-easy-gt"><span class="nav-text">637. 二叉树的层平均值  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-lt-medium-gt"><span class="nav-text">102. 二叉树的层序遍历 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-lt-medium-gt"><span class="nav-text">103. 二叉树的锯齿形层序遍历 &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-Binary-Search-Tree"><span class="nav-text">3.11 二叉搜索树 Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE-lt-easy-gt"><span class="nav-text">530. 二叉搜索树的最小绝对差  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0-lt-medium-gt"><span class="nav-text">230. 二叉搜索树中第K小的元素 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-lt-medium-gt"><span class="nav-text">98. 验证二叉搜索树 &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-12-%E5%9B%BE-Graph"><span class="nav-text">3.12 图 Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-lt-medium-gt"><span class="nav-text">200. 岛屿数量 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F-lt-medium-gt"><span class="nav-text">130. 被围绕的区域 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#133-%E5%85%8B%E9%9A%86%E5%9B%BE-lt-medium-gt"><span class="nav-text">133. 克隆图 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC-lt-medium-gt-lt-hard-gt"><span class="nav-text">399. 除法求值 &lt;medium&gt; ~  &lt;hard&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8-lt-medium-gt"><span class="nav-text">207. 课程表 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#210-%E8%AF%BE%E7%A8%8B%E8%A1%A8-II-lt-medium-gt"><span class="nav-text">210. 课程表 II &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-13-%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-Breadth-First-Search-BFS-in-Graphs"><span class="nav-text">3.13 图的广度优先搜索 Breadth-First Search (BFS) in Graphs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#909-%E8%9B%87%E6%A2%AF%E6%A3%8B-lt-medium-gt"><span class="nav-text">909. 蛇梯棋 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#433-%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96-lt-medium-gt"><span class="nav-text">433. 最小基因变化 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-lt-hard-gt"><span class="nav-text">127. 单词接龙 &lt;hard&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-14-%E5%AD%97%E5%85%B8%E6%A0%91-Trie-Prefix-Tree"><span class="nav-text">3.14 字典树 Trie (Prefix Tree)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91-lt-medium-gt"><span class="nav-text">208. 实现 Trie (前缀树) &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-lt-medium-gt"><span class="nav-text">211. 添加与搜索单词 - 数据结构设计 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#212-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-II-lt-hard-gt"><span class="nav-text">212. 单词搜索 II &lt;hard&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-15-%E5%9B%9E%E6%BA%AF-Backtracking"><span class="nav-text">3.15 回溯 Backtracking</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-lt-medium-gt"><span class="nav-text">17. 电话号码的字母组合 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#77-%E7%BB%84%E5%90%88-lt-medium-gt"><span class="nav-text">77. 组合 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97-lt-medium-gt"><span class="nav-text">46. 全排列 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-lt-medium-gt"><span class="nav-text">39. 组合总和 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52-N-%E7%9A%87%E5%90%8E-II-lt-hard-gt"><span class="nav-text">52. N 皇后 II &lt;hard&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-lt-medium-gt"><span class="nav-text">22. 括号生成 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-lt-medium-gt"><span class="nav-text">79. 单词搜索 &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-16-%E5%88%86%E6%B2%BB-Divide-and-Conquer"><span class="nav-text">3.16 分治 Divide and Conquer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-lt-easy-gt"><span class="nav-text">108. 将有序数组转换为二叉搜索树  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8-lt-medium-gt"><span class="nav-text">148. 排序链表 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#427-%E5%BB%BA%E7%AB%8B%E5%9B%9B%E5%8F%89%E6%A0%91-lt-medium-gt"><span class="nav-text">427. 建立四叉树 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-lt-hard-gt"><span class="nav-text">23. 合并 K 个升序链表 &lt;hard&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-17-Kadane%E7%AE%97%E6%B3%95-Kadane%E2%80%99s-Algorithm"><span class="nav-text">3.17 Kadane算法 Kadane’s Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-lt-medium-gt"><span class="nav-text">53. 最大子数组和 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#918-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-lt-medium-gt"><span class="nav-text">918. 环形子数组的最大和 &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-18-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-Binary-Search"><span class="nav-text">3.18 二分查找 Binary Search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-lt-easy-gt"><span class="nav-text">35. 搜索插入位置  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-lt-medium-gt"><span class="nav-text">74. 搜索二维矩阵 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC-lt-medium-gt"><span class="nav-text">162. 寻找峰值 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-lt-medium-gt"><span class="nav-text">33. 搜索旋转排序数组 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-lt-medium-gt"><span class="nav-text">34. 在排序数组中查找元素的第一个和最后一个位置 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-lt-medium-gt"><span class="nav-text">153. 寻找旋转排序数组中的最小值 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-lt-hard-gt"><span class="nav-text">4. 寻找两个正序数组的中位数 &lt;hard&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-19-%E5%A0%86-Heap"><span class="nav-text">3.19 堆 Heap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-lt-medium-gt"><span class="nav-text">215. 数组中的第K个最大元素 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#502-IPO-lt-hard-gt"><span class="nav-text">502. IPO &lt;hard&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#373-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84-K-%E5%AF%B9%E6%95%B0%E5%AD%97-lt-medium-gt"><span class="nav-text">373. 查找和最小的 K 对数字 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-lt-hard-gt"><span class="nav-text">295. 数据流的中位数 &lt;hard&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-20-%E4%BD%8D%E8%BF%90%E7%AE%97-Bit-Manipulation"><span class="nav-text">3.20 位运算 Bit Manipulation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C-lt-easy-gt"><span class="nav-text">67. 二进制求和  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D-lt-easy-gt"><span class="nav-text">190. 颠倒二进制位  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0-lt-easy-gt"><span class="nav-text">191. 位1的个数  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-lt-easy-gt"><span class="nav-text">136. 只出现一次的数字  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II-lt-medium-gt"><span class="nav-text">137. 只出现一次的数字 II &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E-lt-medium-gt"><span class="nav-text">201. 数字范围按位与 &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-21-%E6%95%B0%E5%AD%A6-Mathematics"><span class="nav-text">3.21 数学 Mathematics</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E5%9B%9E%E6%96%87%E6%95%B0-lt-easy-gt"><span class="nav-text">9. 回文数  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#66-%E5%8A%A0%E4%B8%80-lt-easy-gt"><span class="nav-text">66. 加一  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6-lt-medium-gt"><span class="nav-text">172. 阶乘后的零 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-lt-easy-gt"><span class="nav-text">69. x 的平方根  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50-Pow-x-n-lt-medium-gt"><span class="nav-text">50. Pow(x, n) &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0-lt-hard-gt"><span class="nav-text">149. 直线上最多的点数 &lt;hard&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-22-%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-One-dimensional-Dynamic-Programming"><span class="nav-text">3.22 一维动态规划 One-dimensional Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-lt-easy-gt"><span class="nav-text">70. 爬楼梯  &lt;easy&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-lt-medium-gt"><span class="nav-text">198. 打家劫舍 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-lt-medium-gt"><span class="nav-text">139. 单词拆分 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-lt-medium-gt"><span class="nav-text">322. 零钱兑换 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-lt-medium-gt"><span class="nav-text">300. 最长递增子序列 &lt;medium&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-23-%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Multi-dimensional-Dynamic-Programming"><span class="nav-text">3.23 多维动态规划 Multi-dimensional Dynamic Programming</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-lt-medium-gt"><span class="nav-text">120. 三角形最小路径和 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-lt-medium-gt"><span class="nav-text">64. 最小路径和 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II-lt-medium-gt"><span class="nav-text">63. 不同路径 II &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-lt-medium-gt"><span class="nav-text">5. 最长回文子串 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2-lt-medium-gt"><span class="nav-text">97. 交错字符串 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-lt-medium-gt"><span class="nav-text">72. 编辑距离 &lt;medium&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III-lt-hard-gt"><span class="nav-text">123. 买卖股票的最佳时机 III &lt;hard&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV-lt-hard-gt"><span class="nav-text">188. 买卖股票的最佳时机 IV &lt;hard&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2-lt-medium-gt"><span class="nav-text">221. 最大正方形 &lt;medium&gt;</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019102501.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-25 16:23:37" itemprop="dateCreated datePublished" datetime="2019-10-25T16:23:37+08:00">2019-10-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-02-24 23:52:34" itemprop="dateModified" datetime="2025-02-24T23:52:34+08:00">2025-02-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>484k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7:20</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的算法相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="一-综合"><a href="#一-综合" class="headerlink" title="一.综合"></a>一.综合</h2><h4 id="Leetcode解题方法记录"><a href="#Leetcode解题方法记录" class="headerlink" title="Leetcode解题方法记录"></a>Leetcode解题方法记录</h4><h5 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组/字符串"></a>数组/字符串</h5><table>
<thead>
<tr>
<th>难度</th>
<th>题目</th>
<th>解题方法</th>
</tr>
</thead>
<tbody><tr>
<td>easy</td>
<td>88.合并两个有序数组</td>
<td>逆向双指针倒序循环将元素合并入nums1，循环后收尾nums2剩余</td>
</tr>
<tr>
<td>easy</td>
<td>27. 移除元素</td>
<td>双指针，循环指针遍历数组，另一个指针只在元素不同时交换元素，该指针就是最终结果</td>
</tr>
<tr>
<td>easy</td>
<td>26. 删除有序数组中的重复项</td>
<td>双指针，元素相等时j不动，不等时将i与j+1交换，从而留下一个j</td>
</tr>
<tr>
<td>medium</td>
<td>80. 删除有序数组中的重复项 II</td>
<td>双指针，因为保留2个重复元素，所以从2开始，每次判断i和j-2是否相等，若不等表示i元素要保留，和j交换，并j++更新j。j代表着留下的元素。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><table>
<thead>
<tr>
<th>难度</th>
<th>题目</th>
<th>解题方法</th>
</tr>
</thead>
<tbody><tr>
<td>easy</td>
<td>141. 环形链表</td>
<td>快慢指针</td>
</tr>
<tr>
<td>medium</td>
<td>2.两数相加</td>
<td>同时遍历两个链表，逐位相加</td>
</tr>
<tr>
<td>easy</td>
<td>21. 合并两个有序链表</td>
<td>同时遍历两个链表，分别判断节点各种情况</td>
</tr>
<tr>
<td>medium</td>
<td>138. 随机链表的复制</td>
<td>用Map提前生成复制节点，二次遍历copy连接</td>
</tr>
<tr>
<td>medium</td>
<td>92. 反转链表 II</td>
<td>指定区间反转，压栈；或者使用reverse直接反转链表</td>
</tr>
<tr>
<td>medium</td>
<td>143. 重排链表</td>
<td>快慢指针定位中部，再reverse反转</td>
</tr>
<tr>
<td>hard</td>
<td>25. K 个一组翻转链表</td>
<td>每k个一组反转，每轮反转要记住反转的头尾，再reverse反转</td>
</tr>
<tr>
<td>medium</td>
<td>19. 删除链表的倒数第 N 个结点</td>
<td>快慢指针，快指针先移动n个节点，然后快慢指针一起移动，快指针到达尾部时，慢指针到达要删除的节点</td>
</tr>
<tr>
<td>medium</td>
<td>82. 删除排序链表中的重复元素 II</td>
<td>双层循环，记录prev、curr、next，直到找到所有重复元素</td>
</tr>
<tr>
<td>medium</td>
<td>61. 旋转链表</td>
<td>先遍历长度再对k求余可以避免重复循环</td>
</tr>
<tr>
<td>medium</td>
<td>86. 分隔链表</td>
<td>用两个指针分别代表小于和大于等于x的链表，循环后注意连接两个链表，并且断开新的large链表尾部的next连接</td>
</tr>
<tr>
<td>medium</td>
<td>146. LRU 缓存</td>
<td>通过双向链表来存放使用记录，Map&lt;key, Node&gt;来记录键值对，每次使用时先removeNode，再addToFront，新增时若超容量则删除tail前一个节点即最久为使用</td>
</tr>
<tr>
<td>hard</td>
<td>460. LFU缓存</td>
<td>双向链表+HashMap来实现。记录minFreq，通过一个Map来存放键值对用于快速访问，然后另一个Map&lt;Int Freq, DoubleLinkedList&gt; 记录每个频率的节点，双向链表表示LRU，用于淘汰相同频率节点。</td>
</tr>
</tbody></table>
<h5 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h5><table>
<thead>
<tr>
<th>难度</th>
<th>题目</th>
<th>解题方法</th>
</tr>
</thead>
<tbody><tr>
<td>easy</td>
<td>70. 爬楼梯</td>
<td>d[i] = d[i-1] + d[i-2]</td>
</tr>
<tr>
<td>medium</td>
<td>198. 打家劫舍</td>
<td>dp[i] = Max(dp[i-1], dp[i-2] + nums[i-1])</td>
</tr>
<tr>
<td>medium</td>
<td>139. 单词拆分</td>
<td>dp[i] = dp[i-len] &amp; s.substring(i - len, i).equals(word)</td>
</tr>
<tr>
<td>medium</td>
<td>322. 零钱兑换</td>
<td>dp[i] = Math.min(dp[i-coin] + 1, dp[i])</td>
</tr>
<tr>
<td>medium</td>
<td>300. 最长递增子序列</td>
<td>dp[i] = Math.max(dp[i], dp[j] + 1)</td>
</tr>
</tbody></table>
<h4 id="问：讲下常见的排序算法及其复杂度？怎么实现一个快排？"><a href="#问：讲下常见的排序算法及其复杂度？怎么实现一个快排？" class="headerlink" title="问：讲下常见的排序算法及其复杂度？怎么实现一个快排？"></a>问：讲下常见的排序算法及其复杂度？怎么实现一个快排？</h4><p><strong>1. 常见排序算法及其复杂度</strong></p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏）</th>
<th>时间复杂度（最好）</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td><strong>冒泡排序</strong></td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td><strong>选择排序</strong></td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><strong>插入排序</strong></td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td><strong>归并排序</strong></td>
<td>O(nlog⁡n)</td>
<td>O(nlog⁡n)</td>
<td>O(nlog⁡n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td><strong>快速排序</strong></td>
<td>O(nlog⁡n)</td>
<td>O(n^2)</td>
<td>O(nlog⁡n)</td>
<td>O(log⁡n)</td>
<td>不稳定</td>
</tr>
<tr>
<td><strong>堆排序</strong></td>
<td>O(nlog⁡n)</td>
<td>O(nlog⁡n)</td>
<td>O(nlog⁡n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><strong>计数排序</strong></td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)O(n+k)</td>
<td>O(k)</td>
<td>稳定</td>
</tr>
<tr>
<td><strong>桶排序</strong></td>
<td>O(n+k)</td>
<td>O(n^2)</td>
<td>O(n+k)O(n+k)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
<tr>
<td><strong>基数排序</strong></td>
<td>O(d⋅(n+k))</td>
<td>O(d⋅(n+k))</td>
<td>O(d⋅(n+k))</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
</tbody></table>
<p><strong>2. 快速排序（Quick Sort）实现</strong></p>
<p>快速排序是基于分治思想的排序算法。它选择一个”基准”元素，将数组分为两部分：一部分比基准小，一部分比基准大，然后递归地对两部分进行排序。</p>
<ol>
<li>选择一个基准（pivot）。</li>
<li>将数组分成两部分：小于基准和大于基准。</li>
<li>递归地对两部分排序。</li>
</ol>
<p><strong>代码实现（Java）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivotIndex = partition(arr, left, right);</span><br><span class="line">            quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[right]; <span class="comment">// 选择最后一个元素作为基准</span></span><br><span class="line">        <span class="keyword">int</span> i = left - <span class="number">1</span>;       <span class="comment">// i 指向小于 pivot 的最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i + <span class="number">1</span>, right); <span class="comment">// 把 pivot 放到正确的位置</span></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;            <span class="comment">// 返回基准元素的索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>最坏情况</strong>：O(n^2)（当数组是有序的，基准总是最小/最大值）</li>
<li><strong>平均情况</strong>：O(nlog⁡n)</li>
<li><strong>最好情况</strong>：O(nlog⁡n)</li>
</ul>
<p><strong>空间复杂度</strong>：</p>
<ul>
<li>O(log⁡n)（递归栈空间）</li>
</ul>
<p><strong>冒泡排序（Bubble Sort）</strong></p>
<ol>
<li>比较相邻的元素，如果顺序错误就交换它们。</li>
<li>每一轮将最大的元素“冒泡”到末尾。</li>
<li>重复 n−1 轮，直到整个数组有序。</li>
</ol>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> swapped = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123; <span class="comment">// 交换相邻元素</span></span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    swapped = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>; <span class="comment">// 若无交换，提前结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>选择排序（Selection Sort）</strong></p>
<ol>
<li>每轮从未排序部分选择最小的元素，放到已排序部分的末尾。</li>
<li>重复 n−1 轮，最终数组有序。</li>
</ol>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换最小值到当前位置</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[minIndex];</span><br><span class="line">            arr[minIndex] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入排序（Insertion Sort）</strong></p>
<ol>
<li>将数组分为已排序和未排序部分。</li>
<li>从未排序部分选取元素，插入到已排序部分的正确位置。</li>
<li>重复直到整个数组有序。</li>
</ol>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(n^2)（最好：O(n)，当数组接近有序）</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 将比 key 大的元素右移</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = key; <span class="comment">// 插入元素到正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>归并排序（Merge Sort）</strong></p>
<ol>
<li>将数组分成两部分，递归地对两部分排序。</li>
<li>合并两个已排序数组。</li>
</ol>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(nlog⁡n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 递归排序左边</span></span><br><span class="line">            mergeSort(arr, left, mid);</span><br><span class="line">            <span class="comment">// 递归排序右边</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="comment">// 合并两边</span></span><br><span class="line">            merge(arr, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = right - mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] leftArr = <span class="keyword">new</span> <span class="keyword">int</span>[n1];</span><br><span class="line">        <span class="keyword">int</span>[] rightArr = <span class="keyword">new</span> <span class="keyword">int</span>[n2];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制两边数组</span></span><br><span class="line">        System.arraycopy(arr, left, leftArr, <span class="number">0</span>, n1);</span><br><span class="line">        System.arraycopy(arr, mid + <span class="number">1</span>, rightArr, <span class="number">0</span>, n2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">        <span class="comment">// 双指针分别遍历两个集合，按顺序放回原集合</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;</span><br><span class="line">                arr[k++] = leftArr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k++] = rightArr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1) arr[k++] = leftArr[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n2) arr[k++] = rightArr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆排序（Heap Sort）</strong></p>
<ol>
<li>构建一个大根堆。</li>
<li>每次取堆顶元素（最大值），放到数组末尾。</li>
<li>调整堆，重复直到数组有序。</li>
</ol>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(nlog⁡n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步：构造大根堆（Heapify过程）</span></span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始，向上调整堆</span></span><br><span class="line">        <span class="comment">// 非叶子节点的索引是 n/2 - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二步：交换堆顶和数组末尾元素，并重新调整堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调整剩余部分为新的大根堆</span></span><br><span class="line">            <span class="comment">// 注意此时堆的大小减少了1，范围是 [0, i-1]</span></span><br><span class="line">            heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数：调整堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = i; <span class="comment">// 假设当前节点 i 是最大值</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左子节点是否存在且是否大于当前最大值</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;</span><br><span class="line">        <span class="comment">// 检查右子节点是否存在且是否大于当前最大值</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最大值不是当前节点 i，则需要交换并递归调整</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            <span class="comment">// 交换当前节点和最大值节点</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[largest];</span><br><span class="line">            arr[largest] = temp;</span><br><span class="line">            <span class="comment">// 递归调整受影响的子树</span></span><br><span class="line">            heapify(arr, n, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="问：二分查找？"><a href="#问：二分查找？" class="headerlink" title="问：二分查找？"></a>问：二分查找？</h4><p>二分查找是一种 <strong>高效的查找算法</strong>，用于 <strong>有序数组</strong> 或 <strong>单调性问题</strong>，时间复杂度为 **O(log n)**。</p>
<ul>
<li>在有序数组中，选择中间元素mid作为比较基准：<ul>
<li>如果 <code>target == arr[mid]</code>，返回 <code>mid</code>（找到目标值）。</li>
<li>如果 <code>target &lt; arr[mid]</code>，说明 <code>target</code> 可能在 <strong>左半部分</strong>，递归或迭代缩小搜索范围 <code>right = mid - 1</code>。</li>
<li>如果 <code>target &gt; arr[mid]</code>，说明 <code>target</code> 可能在 <strong>右半部分</strong>，缩小搜索范围 <code>left = mid + 1</code>。</li>
</ul>
</li>
<li>重复该过程，直到找到目标值或 <strong>搜索区间为空（left &gt; right）</strong>。</li>
</ul>
<p><strong>代码实现</strong></p>
<p><strong>（1）标准二分查找</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; </span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 找到目标值，返回索引</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 目标值在右侧</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 目标值在左侧</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearch bs = <span class="keyword">new</span> BinarySearch();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(bs.binarySearch(arr, <span class="number">7</span>)); <span class="comment">// 输出 3（索引位置）</span></span><br><span class="line">        System.out.println(bs.binarySearch(arr, <span class="number">6</span>)); <span class="comment">// 输出 -1（未找到）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：<code>O(log n)</code><br><strong>空间复杂度</strong>：<code>O(1)</code>（迭代实现，不使用额外空间）</p>
<p><strong>递归版二分查找</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveBinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid; <span class="comment">// 找到目标值</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; target) <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RecursiveBinarySearch rbs = <span class="keyword">new</span> RecursiveBinarySearch();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(rbs.binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">9</span>)); <span class="comment">// 输出 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：<code>O(log n)</code><br><strong>空间复杂度</strong>：<code>O(log n)</code>（递归调用栈的开销）</p>
<p><strong>变种二分查找</strong></p>
<p><strong>（1）查找 <code>target</code> 的 “左边界”（Lower Bound）</strong></p>
<blockquote>
<p><strong>目标</strong>：找到 <code>target</code> <strong>最左侧出现的位置</strong>（如果存在），否则返回 <strong>插入位置</strong>（第一个比 <code>target</code> 大的位置）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意这里是 `&lt;` 而不是 `&lt;=`</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// `target` 可能在左侧</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// `target` 在右侧</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">System.out.println(lowerBound(arr, <span class="number">7</span>)); <span class="comment">// 输出 4</span></span><br><span class="line">System.out.println(lowerBound(arr, <span class="number">6</span>)); <span class="comment">// 输出 4（6 不存在，返回插入点）</span></span><br></pre></td></tr></table></figure>



<p><strong>（2）查找 <code>target</code> 的 “右边界”（Upper Bound）</strong></p>
<blockquote>
<p><strong>目标</strong>：找到 <code>target</code> <strong>最右侧出现的位置的右边</strong>（比 <code>target</code> 大的第一个数的索引）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">upperBound</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">System.out.println(upperBound(arr, <span class="number">7</span>)); <span class="comment">// 输出 6（索引 6 是 9）</span></span><br><span class="line">System.out.println(upperBound(arr, <span class="number">6</span>)); <span class="comment">// 输出 4（插入位置）</span></span><br></pre></td></tr></table></figure>



<p><strong>适用场景</strong></p>
<p>✅ <strong>适用于：</strong></p>
<ol>
<li><strong>有序数组</strong> 查找</li>
<li><strong>查找插入位置</strong>（lower_bound、upper_bound）</li>
<li><strong>搜索区间问题</strong>（如找出第一个/最后一个 <code>&gt;= target</code> 的位置）</li>
<li><strong>二分答案问题</strong>（如最小化最大值、最大化最小值等）</li>
</ol>
<p>❌ <strong>不适用于：</strong></p>
<ol>
<li><strong>无序数组</strong></li>
<li><strong>非单调函数</strong></li>
<li><strong>数据结构非数组</strong>（链表等无法随机访问）</li>
</ol>
<h2 id="二-数据结构"><a href="#二-数据结构" class="headerlink" title="二.数据结构"></a>二.数据结构</h2><h4 id="问：树一般怎么实现，链表怎么实现？"><a href="#问：树一般怎么实现，链表怎么实现？" class="headerlink" title="问：树一般怎么实现，链表怎么实现？"></a>问：树一般怎么实现，链表怎么实现？</h4><p><strong>树的一般实现</strong></p>
<ul>
<li><p>树可以用<strong>链式存储</strong>（指针）或<strong>数组存储</strong>实现。</p>
</li>
<li><p><strong>链式存储</strong>（常用）：</p>
<p>每个节点包含数据和指向子节点的指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>数组存储</strong>（用于完全二叉树）：</p>
<p>将节点按层次顺序存储到数组中。</p>
<ul>
<li>左子节点索引：2i + 1</li>
<li>右子节点索引：2i + 2</li>
<li>父节点索引：(i−1)/2</li>
</ul>
</li>
</ul>
<p><strong>链表的一般实现</strong></p>
<ul>
<li><p>链表是一组通过指针相互连接的节点，可分为单向链表、双向链表、循环链表等。</p>
</li>
<li><p><strong>单向链表</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>双向链表</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    DoublyListNode prev;</span><br><span class="line">    DoublyListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoublyListNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表在实现上较简单，适合需要频繁插入和删除的场景，但在随机访问上性能较差（需要 O(n) 时间）。</p>
</li>
</ul>
<h4 id="问：堆是怎么实现？小根堆如何插入数据，讲一下过程？"><a href="#问：堆是怎么实现？小根堆如何插入数据，讲一下过程？" class="headerlink" title="问：堆是怎么实现？小根堆如何插入数据，讲一下过程？"></a>问：堆是怎么实现？小根堆如何插入数据，讲一下过程？</h4><ul>
<li><p><strong>堆的实现</strong></p>
<p>堆是一种特殊的完全二叉树，满足以下两个条件：</p>
<ol>
<li><strong>结构特性</strong>：堆是完全二叉树，即除了最后一层外，其余层是满的，并且最后一层的节点靠左对齐。</li>
<li><strong>堆序特性</strong>：<ul>
<li><strong>大根堆</strong>：每个节点的值都大于或等于其子节点的值。</li>
<li><strong>小根堆</strong>：每个节点的值都小于或等于其子节点的值。</li>
</ul>
</li>
</ol>
<p>堆可以通过<strong>数组</strong>或<strong>链表</strong>实现。一般使用数组实现更常见。</p>
<ol>
<li><strong>大根堆（最大堆）</strong>：每个节点的值都大于等于其子节点的值。</li>
<li><strong>小根堆（最小堆）</strong>：每个节点的值都小于等于其子节点的值。</li>
</ol>
</li>
<li><p><strong>堆的数组实现</strong></p>
<p>对于堆中第 i 个节点：</p>
<ul>
<li><strong>父节点索引</strong>：(i - 1) / 2</li>
<li><strong>左子节点索引</strong>：2i + 1</li>
<li><strong>右子节点索引</strong>：2i + 2</li>
</ul>
<p>假设我们有一个数组：<code>[3, 5, 1, 8, 4, 7, 2]</code> 将其构造成一个大根堆。</p>
<ol>
<li><p><strong>步骤 1：从最后一个非叶子节点开始</strong></p>
<p>对于完全二叉树，非叶子节点从 ⌊n/2⌋−1 开始：</p>
<ul>
<li>数组长度 n=7，所以最后一个非叶子节点索引为 ⌊7/2⌋−1=2。</li>
</ul>
<p><strong>从索引 2 开始调整：</strong></p>
<ul>
<li>当前节点：<code>1</code>（索引 2）</li>
<li>左子节点：<code>7</code>（索引 5）</li>
<li>右子节点：<code>2</code>（索引 6）</li>
</ul>
<p>比较当前节点和子节点：</p>
<ul>
<li>最大值是左子节点 <code>7</code>，交换当前节点 <code>1</code> 和 <code>7</code>。</li>
</ul>
<p>调整后数组：<code>[3, 5, 7, 8, 4, 1, 2]</code></p>
</li>
<li><p><strong>步骤 2：继续向上调整</strong></p>
<p><strong>调整索引 1 的子树：</strong></p>
<ul>
<li>当前节点：<code>5</code>（索引 1）</li>
<li>左子节点：<code>8</code>（索引 3）</li>
<li>右子节点：<code>4</code>（索引 4）</li>
</ul>
<p>比较当前节点和子节点：</p>
<ul>
<li>最大值是左子节点 <code>8</code>，交换当前节点 <code>5</code> 和 <code>8</code>。</li>
</ul>
<p>调整后数组：<code>[3, 8, 7, 5, 4, 1, 2]</code></p>
<p><strong>调整索引 0 的子树：</strong></p>
<ul>
<li>当前节点：<code>3</code>（索引 0）</li>
<li>左子节点：<code>8</code>（索引 1）</li>
<li>右子节点：<code>7</code>（索引 2）</li>
</ul>
<p>比较当前节点和子节点：</p>
<ul>
<li>最大值是左子节点 <code>8</code>，交换当前节点 <code>3</code> 和 <code>8</code>。</li>
</ul>
<p>调整后数组：<code>[8, 3, 7, 5, 4, 1, 2]</code></p>
<p>然后递归调整改变后节点3的子树，左节点为5，右节点为4，交换3和5。</p>
</li>
<li><p><strong>最终大根堆：</strong></p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>小根堆插入数据的过程</strong></p>
<p>插入一个数据到小根堆中需要遵循以下步骤：</p>
<ol>
<li><p><strong>将新数据放入堆的末尾</strong>。</p>
</li>
<li><p>上浮调整：</p>
<ul>
<li>将新数据和其父节点进行比较。</li>
<li>如果新数据小于父节点，则交换两者的位置。</li>
<li>继续比较新数据与新的父节点，重复这一过程，直到满足小根堆的性质。</li>
</ul>
</li>
</ol>
<p><strong>插入示例</strong></p>
<p>假设小根堆为：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">2</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">5</span>     <span class="number">10</span></span><br><span class="line"> / <span class="string">\</span></span><br><span class="line"><span class="number">8</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>数组表示为：<code>[2, 5, 10, 8, 7]</code></p>
<p>插入新数据 1：</p>
<ol>
<li><p>将 1 放到堆末尾：<code>[2, 5, 10, 8, 7, 1]</code></p>
</li>
<li><p>上浮调整：</p>
<ul>
<li>1 的父节点是 10（索引 2），比较 1 和 10：1 &lt; 10，交换。</li>
<li>现在堆为：<code>[2, 5, 1, 8, 7, 10]</code></li>
<li>1 的新父节点是 2（索引 0），比较 1 和 2：1 &lt; 2，交换。</li>
<li>最终堆为：<code>[1, 5, 2, 8, 7, 10]</code></li>
</ul>
</li>
</ol>
<p>调整后的堆：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">5</span>     <span class="number">2</span></span><br><span class="line"> / <span class="string">\</span></span><br><span class="line"><span class="number">8</span>   <span class="number">7</span></span><br><span class="line">     <span class="string">\</span></span><br><span class="line">     <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>代码实现（Java）</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.heap = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        heap.add(value); <span class="comment">// 将新元素添加到末尾</span></span><br><span class="line">        <span class="keyword">int</span> currentIndex = heap.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上浮调整</span></span><br><span class="line">        <span class="keyword">while</span> (currentIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parentIndex = (currentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap.get(currentIndex) &lt; heap.get(parentIndex)) &#123;</span><br><span class="line">                swap(currentIndex, parentIndex);</span><br><span class="line">                currentIndex = parentIndex;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = heap.get(i);</span><br><span class="line">        heap.set(i, heap.get(j));</span><br><span class="line">        heap.set(j, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(heap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinHeap minHeap = <span class="keyword">new</span> MinHeap();</span><br><span class="line">        minHeap.insert(<span class="number">2</span>);</span><br><span class="line">        minHeap.insert(<span class="number">5</span>);</span><br><span class="line">        minHeap.insert(<span class="number">10</span>);</span><br><span class="line">        minHeap.insert(<span class="number">8</span>);</span><br><span class="line">        minHeap.insert(<span class="number">7</span>);</span><br><span class="line">        minHeap.insert(<span class="number">1</span>); <span class="comment">// 插入 1</span></span><br><span class="line">        minHeap.printHeap(); <span class="comment">// 输出：[1, 5, 2, 8, 7, 10]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>时间复杂度</strong></p>
<ul>
<li><strong>插入</strong>：O(log⁡n)，因为上浮操作最多需要调整堆的高度。</li>
<li><strong>空间复杂度</strong>：O(1)，使用了原地调整，不需要额外空间。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong>小根堆的插入</strong>通过末尾插入数据并上浮调整，保证堆的性质。</li>
<li>堆的实现多使用数组，便于索引计算。</li>
<li>插入操作的效率高，适用于动态调整的数据结构场景（如优先队列、最小生成树等）。</li>
</ul>
<h4 id="问：判断链表是否有环？"><a href="#问：判断链表是否有环？" class="headerlink" title="问：判断链表是否有环？"></a>问：判断链表是否有环？</h4><p>判断链表是否有环通常使用<strong>快慢指针法</strong>（Floyd 判圈算法），该方法高效且不需要额外空间。</p>
<p><strong>算法思路</strong></p>
<ol>
<li>设置两个指针：<ul>
<li><strong>慢指针（slow）</strong>：每次移动一步。</li>
<li><strong>快指针（fast）</strong>：每次移动两步。</li>
</ul>
</li>
<li>两个指针同时从链表头开始遍历：<ul>
<li>如果链表中有环，快指针最终会追上慢指针，出现相遇的情况。</li>
<li>如果链表无环，快指针会走到链表的末尾（<code>null</code>），跳出循环。</li>
</ul>
</li>
<li>如果快指针和慢指针相遇，说明链表有环。</li>
<li>如果快指针走到链表末尾，说明链表无环。</li>
</ol>
<p><strong>代码实现（Java）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断链表是否有环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 空链表或单节点链表不可能有环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;         <span class="comment">// 慢指针每次移动一步</span></span><br><span class="line">            fast = fast.next.next;   <span class="comment">// 快指针每次移动两步</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;      <span class="comment">// 快慢指针相遇，说明有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 快指针到达链表末尾，说明无环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造测试链表</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        head.next.next.next.next = head.next; <span class="comment">// 创建环</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hasCycle(head)); <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无环链表测试</span></span><br><span class="line">        ListNode head2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        System.out.println(hasCycle(head2)); <span class="comment">// 输出 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong></p>
<ul>
<li><p>时间复杂度：O(n)，其中 n是链表的节点数。</p>
<ul>
<li>每个节点最多被访问两次：一次由慢指针，另一次由快指针。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：O(1)，只使用了两个指针，不需要额外空间。</p>
</li>
</ul>
<p><strong>扩展：找到环的起始节点</strong></p>
<p>在判断链表有环的基础上，如果要找到环的起始节点，可以在相遇后：</p>
<ol>
<li>将<strong>慢指针</strong>重置为链表头。</li>
<li>两个指针以相同速度移动（每次一步）。</li>
<li>两指针相遇时，即为环的起始节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycleStart</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123; <span class="comment">// 有环</span></span><br><span class="line">            slow = head; <span class="comment">// 慢指针回到头部</span></span><br><span class="line">            <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow; <span class="comment">// 相遇点即为环的起始节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 无环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li><strong>判断有环</strong>：使用快慢指针法。</li>
<li><strong>找到环起始点</strong>：在有环的基础上，通过双指针重置和移动实现。</li>
<li><strong>时间复杂度</strong>：O(n)，<strong>空间复杂度</strong>：O(1)。</li>
</ol>
<h4 id="问：树的前序、中序、后序遍历？"><a href="#问：树的前序、中序、后序遍历？" class="headerlink" title="问：树的前序、中序、后序遍历？"></a>问：树的前序、中序、后序遍历？</h4><p>树的遍历方式分为<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>，它们的主要区别在于访问当前节点的顺序相对于其左右子节点的顺序。以二叉树为例，具体如下：</p>
<p><strong>1. 前序遍历 (Pre-order Traversal)</strong></p>
<p>访问顺序：<strong>根节点 → 左子树 → 右子树</strong></p>
<ul>
<li><strong>逻辑：</strong><ol>
<li>访问当前节点。</li>
<li>前序遍历左子树。</li>
<li>前序遍历右子树。</li>
</ol>
</li>
<li><strong>特点：</strong><ul>
<li>可以用于复制树结构。</li>
<li>根节点总是第一个被访问。</li>
</ul>
</li>
<li><strong>递归代码：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问当前节点</span></span><br><span class="line">    preOrder(root.left);             <span class="comment">// 遍历左子树</span></span><br><span class="line">    preOrder(root.right);            <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>非递归代码 (使用栈)：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderIterative</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);      <span class="comment">// 先压入右子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);       <span class="comment">// 再压入左子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 中序遍历 (In-order Traversal)</strong></p>
<p>访问顺序：<strong>左子树 → 根节点 → 右子树</strong></p>
<ul>
<li><strong>逻辑：</strong><ol>
<li>中序遍历左子树。</li>
<li>访问当前节点。</li>
<li>中序遍历右子树。</li>
</ol>
</li>
<li><strong>特点：</strong><ul>
<li>二叉搜索树的中序遍历结果是有序的。</li>
<li>常用于树的排序输出。</li>
</ul>
</li>
<li><strong>递归代码：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root.left);              <span class="comment">// 遍历左子树</span></span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问当前节点</span></span><br><span class="line">    inOrder(root.right);             <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>非递归代码 (使用栈)：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderIterative</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(current);      <span class="comment">// 压入当前节点</span></span><br><span class="line">            current = current.left;   <span class="comment">// 移动到左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = stack.pop();        <span class="comment">// 弹出栈顶节点</span></span><br><span class="line">        System.out.print(current.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问当前节点</span></span><br><span class="line">        current = current.right;      <span class="comment">// 移动到右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 后序遍历 (Post-order Traversal)</strong></p>
<p>访问顺序：<strong>左子树 → 右子树 → 根节点</strong></p>
<ul>
<li><strong>逻辑：</strong><ol>
<li>后序遍历左子树。</li>
<li>后序遍历右子树。</li>
<li>访问当前节点。</li>
</ol>
</li>
<li><strong>特点：</strong><ul>
<li>常用于删除树或释放内存，保证子节点在父节点之前被访问。</li>
<li>顺序上与深度优先搜索的回溯过程类似。</li>
</ul>
</li>
<li><strong>递归代码：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root.left);            <span class="comment">// 遍历左子树</span></span><br><span class="line">    postOrder(root.right);           <span class="comment">// 遍历右子树</span></span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问当前节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>非递归代码 (使用栈)：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderIterative</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode lastVisited = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(current);      <span class="comment">// 压入当前节点</span></span><br><span class="line">            current = current.left;   <span class="comment">// 移动到左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode peekNode = stack.peek(); <span class="comment">// 查看栈顶节点</span></span><br><span class="line">        <span class="keyword">if</span> (peekNode.right != <span class="keyword">null</span> &amp;&amp; lastVisited != peekNode.right) &#123;</span><br><span class="line">            current = peekNode.right;    <span class="comment">// 右子树未访问过，转向右子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(peekNode.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问当前节点</span></span><br><span class="line">            lastVisited = stack.pop();   <span class="comment">// 弹出栈顶节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三种遍历方式总结</strong></p>
<table>
<thead>
<tr>
<th>遍历方式</th>
<th>访问顺序</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>前序遍历</td>
<td>根 → 左 → 右</td>
<td>树的复制、表达式构建</td>
</tr>
<tr>
<td>中序遍历</td>
<td>左 → 根 → 右</td>
<td>二叉搜索树排序</td>
</tr>
<tr>
<td>后序遍历</td>
<td>左 → 右 → 根</td>
<td>树的删除、表达式求值</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<p>假设二叉树如下：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / <span class="string">\</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   <span class="string">\</span>  / <span class="string">\</span></span><br><span class="line">    <span class="number">4</span> <span class="number">5</span>  <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>遍历结果：</p>
<ul>
<li><strong>前序遍历：</strong> <code>1 2 4 5 3</code></li>
<li><strong>中序遍历：</strong> <code>4 2 5 1 3</code></li>
<li><strong>后序遍历：</strong> <code>4 5 2 3 1</code></li>
</ul>
<p>遍历结果：</p>
<ul>
<li><strong>前序遍历：</strong> <code>1 2 4 3 5 6</code></li>
<li><strong>中序遍历：</strong> <code>2 4 1 5 3 6</code></li>
<li><strong>后序遍历：</strong> <code>4 2 5 6 3 1</code></li>
</ul>
<h4 id="问：非递归且不用额外空间（不用栈），如何遍历二叉树？"><a href="#问：非递归且不用额外空间（不用栈），如何遍历二叉树？" class="headerlink" title="问：非递归且不用额外空间（不用栈），如何遍历二叉树？"></a>问：非递归且不用额外空间（不用栈），如何遍历二叉树？</h4><p>要实现非递归、<strong>不使用额外空间</strong>（不用栈）遍历二叉树，可以采用 <strong>Morris 遍历</strong>，它通过修改树的结构来进行遍历，最终恢复树的原状。</p>
<p><strong>Morris 中序遍历</strong></p>
<ol>
<li><p><strong>核心思想</strong>：</p>
<ul>
<li>利用二叉树中的空闲左子树指针，将其临时指向前驱节点。</li>
<li>通过这个链接，实现沿着树结构的遍历，而无需额外栈空间。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li><p>初始化当前节点 <code>cur</code> 为根节点。</p>
</li>
<li><p>如果 <code>cur</code> 没有左子树：</p>
<ul>
<li>访问当前节点。</li>
<li>移动到右子树。</li>
</ul>
</li>
<li><p>如果 <code>cur</code> 有左子树：</p>
<ul>
<li><p>找到 <code>cur</code> 的左子树中的最右节点（即前驱节点 <code>pre</code>）。</p>
</li>
<li><p>如果 <code>pre</code> 的右指针为空：</p>
<ul>
<li>将 <code>pre</code> 的右指针指向 <code>cur</code>（建立临时链接）。</li>
<li>移动到左子树。</li>
</ul>
</li>
<li><p>如果 <code>pre</code> 的右指针已经指向 <code>cur</code> ：</p>
<ul>
<li>断开临时链接。</li>
<li>访问当前节点。</li>
<li>移动到右子树。</li>
</ul>
</li>
</ul>
</li>
<li><p>重复直到 <code>cur</code> 为 <code>null</code>。</p>
</li>
</ol>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morrisInorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问当前节点</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode pre = cur.left;</span><br><span class="line">            <span class="keyword">while</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right != cur) &#123;</span><br><span class="line">                pre = pre.right; <span class="comment">// 找前驱节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.right = cur; <span class="comment">// 建立链接</span></span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.right = <span class="keyword">null</span>; <span class="comment">// 断开链接</span></span><br><span class="line">                System.out.print(cur.val + <span class="string">&quot; &quot;</span>); <span class="comment">// 访问当前节点</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间和空间复杂度</strong></p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，每个节点最多被访问两次。</li>
<li><strong>空间复杂度</strong>：O(1)，不使用额外的栈或递归。</li>
</ul>
<p>类似地，可以调整访问顺序实现 Morris 的前序遍历和后序遍历。</p>
<h4 id="问：二叉树的深度优先搜素和广度优先搜素？"><a href="#问：二叉树的深度优先搜素和广度优先搜素？" class="headerlink" title="问：二叉树的深度优先搜素和广度优先搜素？"></a>问：二叉树的深度优先搜素和广度优先搜素？</h4><p><strong>1. 深度优先搜索（DFS）</strong></p>
<p>深度优先搜索（Depth-First Search，简称 <strong>DFS</strong>）是一种<strong>递归或使用栈</strong>的方式遍历树结构，优先沿着树的深度遍历，直到叶子节点后再回溯。</p>
<p><strong>常见的三种DFS遍历方式（即二叉树的遍历方式）：</strong></p>
<ol>
<li><strong>前序遍历（Preorder: 根 -&gt; 左 -&gt; 右）</strong></li>
<li><strong>中序遍历（Inorder: 左 -&gt; 根 -&gt; 右）</strong></li>
<li><strong>后序遍历（Postorder: 左 -&gt; 右 -&gt; 根）</strong></li>
</ol>
<p><strong>递归实现 DFS</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeDFS</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历（根 -&gt; 左 -&gt; 右）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历（左 -&gt; 根 -&gt; 右）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历（左 -&gt; 右 -&gt; 根）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        postOrder(root.left);</span><br><span class="line">        postOrder(root.right);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非递归实现 DFS（使用栈）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeDFSIterative</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 <strong>DFS 特点：</strong></p>
<ul>
<li>递归实现简单，但可能会导致栈溢出（当树过深）。</li>
<li>非递归使用栈模拟递归，适合处理大规模数据。</li>
</ul>
<p><strong>2. 广度优先搜索（BFS）</strong></p>
<p>广度优先搜索（Breadth-First Search，简称 <strong>BFS</strong>）是一种<strong>逐层遍历</strong>的方法，通常使用<strong>队列（Queue）</strong> 实现。</p>
<p><strong>BFS 通常用于：</strong></p>
<ul>
<li><strong>层序遍历</strong></li>
<li><strong>最短路径搜索</strong>（例如最短路径问题）</li>
<li><strong>求二叉树的最小深度</strong></li>
</ul>
<p><strong>BFS 代码实现（层序遍历）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 <strong>BFS 特点：</strong></p>
<ul>
<li>使用 <strong>队列（FIFO）</strong>，从上到下、从左到右逐层遍历。</li>
<li>适用于 <strong>最短路径搜索</strong>，因为 BFS 会<strong>先访问较近的节点</strong>。</li>
</ul>
<p>DFS 和 BFS 的比较</p>
<table>
<thead>
<tr>
<th><strong>比较项</strong></th>
<th><strong>DFS（深度优先搜索）</strong></th>
<th><strong>BFS（广度优先搜索）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据结构</strong></td>
<td>栈（递归或手动使用栈）</td>
<td>队列</td>
</tr>
<tr>
<td><strong>适用于</strong></td>
<td>1. 树的遍历（前/中/后序遍历） 2. 需要深入探索的搜索问题（如回溯）</td>
<td>1. 层序遍历  2. 最短路径问题</td>
</tr>
<tr>
<td><strong>时间复杂度</strong></td>
<td>O(N)</td>
<td>O(N)</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>O(h)（h为树高，最坏 O(N)）</td>
<td>O(N)（存储所有节点）</td>
</tr>
<tr>
<td><strong>访问顺序</strong></td>
<td><strong>沿深度优先遍历</strong>（优先访问叶子节点）</td>
<td><strong>按层遍历</strong>（优先访问广度上的节点）</td>
</tr>
<tr>
<td><strong>适用于</strong></td>
<td>1. 需要遍历所有路径的情况2. 解决回溯问题（如八皇后）</td>
<td>1. 求解最短路径问题2. 层次遍历问题</td>
</tr>
</tbody></table>
<p><strong>4. 示例分析</strong></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DFS（前序遍历）：</strong> <code>1 → 2 → 4 → 5 → 3 → 6</code></li>
<li><strong>BFS（层序遍历）：</strong> <code>1 → 2 → 3 → 4 → 5 → 6</code></li>
</ul>
<h4 id="问：讲讲红黑树？如何计算红黑树的时间复杂度？"><a href="#问：讲讲红黑树？如何计算红黑树的时间复杂度？" class="headerlink" title="问：讲讲红黑树？如何计算红黑树的时间复杂度？"></a>问：讲讲红黑树？如何计算红黑树的时间复杂度？</h4><p>红黑树算法：</p>
<p>平衡二叉树算法：插入时，需要判断是否会破坏树的平衡性，若是则要找到最小不平衡树，通过相应的旋转调整最小不平衡树中各个结点的关系，使其再度平衡。平衡因子就是左子树深度和右子树深度的差值，只能为-1、0、1。当最小不平衡子树的平衡因子和其子树的平衡因子符号相反时，要对结点先进行一次旋转使符号相同，再反向旋转一次完成平衡操作。</p>
<p>红黑树的时间复杂度：TODO</p>
<ul>
<li>红黑树通过严格的规则保证了高度平衡，确保操作复杂度为 O(log⁡n)。</li>
<li>它被广泛用于实现集合、映射等数据结构（如 Java 的 <code>TreeMap</code> 和 <code>TreeSet</code>）。</li>
</ul>
<ul>
<li><p>什么是红黑树？</p>
<ul>
<li>红黑树是一种 <strong>自平衡二叉查找树</strong>，确保在最坏情况下基本操作（如插入、删除和查找）的时间复杂度为 O(log⁡n)。它是一种二叉树，其中每个节点存储一个额外的“颜色”属性（红或黑），并通过规则维持树的平衡。</li>
</ul>
</li>
<li><p>核心：</p>
<ol>
<li><strong>节点颜色</strong>：每个节点要么是红色，要么是黑色。颜色表示父节点指向该节点的链接颜色。</li>
<li><strong>根节点黑色</strong>：根节点始终是黑色。</li>
<li><strong>红色节点</strong>：<ul>
<li>红色节点表示可以暂时不满足二叉树的平衡性。</li>
<li>红色左连接使当前红节点与其父黑节点合并为2-3树的3节点。红黑树拉平就是一个2-3树。</li>
<li>红色节点的子节点必须是黑色（不能有两个连续的红色节点）。</li>
<li>新增的节点默认为红色（不影响黑高）</li>
</ul>
</li>
<li><strong>黑高平衡</strong>：从任意节点到其每个叶子节点的所有路径，包含相同数量的黑色节点。</li>
<li><strong>叶节点（NIL）黑色</strong>：树的每个叶子节点（空节点）都是黑色。</li>
</ol>
</li>
<li><p>优点：</p>
<ul>
<li><strong>自平衡性</strong>：通过严格的规则，确保树的高度接近最小高度，避免性能退化成链表。</li>
<li><strong>动态操作高效性</strong>：支持快速插入、删除、查找等操作。</li>
</ul>
</li>
<li><p>基础操作：</p>
<ol>
<li><strong>旋转操作</strong>：<ul>
<li>某些操作后会出现红色右链接或者两条连续的红链接</li>
<li><strong>左旋：</strong>用于调整右倾的红链接。以红色右链接的父节点为中心，将其右子树提升为新的根，原节点变为新根的左子节点，新根的原左子节点变为原节点的新右子节点。</li>
<li><strong>右旋：</strong>用于调整左倾的红链接。以红色右链接的父节点为中心，将其左子树提升为新的根，原节点变为新根的右子节点，新根的原右子节点变为原节点的新左子节点。</li>
<li>什么时候旋转：<ol>
<li><strong>左黑右红左旋转</strong>：右子节点是红色，左子节点是黑色，则左旋转。</li>
<li><strong>连续左红右旋转</strong>：左子节点是红色，且其左子节点也是红色，则右旋转。</li>
<li><strong>左右皆红则变色</strong>：左右子节点都是红色，则进行颜色转换。</li>
</ol>
</li>
</ul>
</li>
<li><strong>插入操作</strong>：<ul>
<li>新插入的节点默认为红色。</li>
<li>可能违反红黑树的性质，需要通过<strong>旋转和重新着色</strong>来修复。</li>
<li>时间复杂度：O(log⁡n)，修复操作最多需要树的高度的旋转和着色操作。</li>
</ul>
</li>
<li><strong>删除操作</strong>：<ul>
<li>删除后可能会导致红黑树的性质被破坏，导致某条路径的黑色节点数量减少，通常会涉及修复操作（双重黑色处理）。</li>
<li>修复时可能需要多次旋转和重新着色。<ul>
<li><strong>兄弟节点染色调整：</strong>将兄弟节点变红或变黑以重新平衡。</li>
<li><strong>旋转操作：</strong>必要时调整树结构。</li>
</ul>
</li>
<li>时间复杂度：O(log⁡n)。</li>
</ul>
</li>
<li><strong>查找操作</strong>：<ul>
<li>类似二叉搜索树的查找，根据键值递归或迭代。</li>
<li>时间复杂度：O(log⁡n)。</li>
</ul>
</li>
</ol>
</li>
<li><p>时间复杂度：</p>
<ol>
<li><strong>高度分析</strong>：红黑树的性质保证树的高度 h 与节点个数 n 满足： h≤2log⁡(n+1) 因此，树的高度是对数级别。</li>
<li><strong>操作的时间复杂度</strong>：<ul>
<li><strong>查找</strong>：最多需要遍历树的高度，即 O(log⁡n)。</li>
<li><strong>插入</strong>：插入后需要从插入点向上修复树的性质，修复涉及的旋转和重新着色次数也是 O(log⁡n)。</li>
<li><strong>删除</strong>：与插入类似，删除后可能需要从删除点向上修复，时间复杂度为 O(log⁡n)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：<ul>
<li>红黑树存储每个节点的颜色，空间复杂度为 O(n)。</li>
<li>若递归实现查找、插入或删除，递归栈的空间复杂度为 O(log⁡n)。</li>
</ul>
</li>
</ol>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">boolean</span> color;</span><br><span class="line">        Node left, right, parent;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> key) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        Node y = x.right;</span><br><span class="line">        x.right = y.left;</span><br><span class="line">        <span class="keyword">if</span> (y.left != <span class="keyword">null</span>) y.left.parent = x;</span><br><span class="line"></span><br><span class="line">        y.parent = x.parent;</span><br><span class="line">        <span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) root = y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.left) x.parent.left = y;</span><br><span class="line">        <span class="keyword">else</span> x.parent.right = y;</span><br><span class="line"></span><br><span class="line">        y.left = x;</span><br><span class="line">        x.parent = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        Node y = x.left;</span><br><span class="line">        x.left = y.right;</span><br><span class="line">        <span class="keyword">if</span> (y.right != <span class="keyword">null</span>) y.right.parent = x;</span><br><span class="line"></span><br><span class="line">        y.parent = x.parent;</span><br><span class="line">        <span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) root = y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.right) x.parent.right = y;</span><br><span class="line">        <span class="keyword">else</span> x.parent.left = y;</span><br><span class="line"></span><br><span class="line">        y.right = x;</span><br><span class="line">        x.parent = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入修复</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixup</span><span class="params">(Node z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (z.parent != <span class="keyword">null</span> &amp;&amp; z.parent.color == RED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (z.parent == z.parent.parent.left) &#123;</span><br><span class="line">                Node y = z.parent.parent.right;</span><br><span class="line">                <span class="keyword">if</span> (y != <span class="keyword">null</span> &amp;&amp; y.color == RED) &#123;</span><br><span class="line">                    z.parent.color = BLACK;</span><br><span class="line">                    y.color = BLACK;</span><br><span class="line">                    z.parent.parent.color = RED;</span><br><span class="line">                    z = z.parent.parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (z == z.parent.right) &#123;</span><br><span class="line">                        z = z.parent;</span><br><span class="line">                        leftRotate(z);</span><br><span class="line">                    &#125;</span><br><span class="line">                    z.parent.color = BLACK;</span><br><span class="line">                    z.parent.parent.color = RED;</span><br><span class="line">                    rightRotate(z.parent.parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node y = z.parent.parent.left;</span><br><span class="line">                <span class="keyword">if</span> (y != <span class="keyword">null</span> &amp;&amp; y.color == RED) &#123;</span><br><span class="line">                    z.parent.color = BLACK;</span><br><span class="line">                    y.color = BLACK;</span><br><span class="line">                    z.parent.parent.color = RED;</span><br><span class="line">                    z = z.parent.parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (z == z.parent.left) &#123;</span><br><span class="line">                        z = z.parent;</span><br><span class="line">                        rightRotate(z);</span><br><span class="line">                    &#125;</span><br><span class="line">                    z.parent.color = BLACK;</span><br><span class="line">                    z.parent.parent.color = RED;</span><br><span class="line">                    leftRotate(z.parent.parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node z = <span class="keyword">new</span> Node(key);</span><br><span class="line">        Node y = <span class="keyword">null</span>;</span><br><span class="line">        Node x = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            y = x;</span><br><span class="line">            <span class="keyword">if</span> (z.key &lt; x.key) x = x.left;</span><br><span class="line">            <span class="keyword">else</span> x = x.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        z.parent = y;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="keyword">null</span>) root = z;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (z.key &lt; y.key) y.left = z;</span><br><span class="line">        <span class="keyword">else</span> y.right = z;</span><br><span class="line"></span><br><span class="line">        insertFixup(z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inorder(node.left);</span><br><span class="line">            System.out.print(node.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            inorder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RedBlackTree rbt = <span class="keyword">new</span> RedBlackTree();</span><br><span class="line">        rbt.insert(<span class="number">10</span>);</span><br><span class="line">        rbt.insert(<span class="number">20</span>);</span><br><span class="line">        rbt.insert(<span class="number">15</span>);</span><br><span class="line">        rbt.insert(<span class="number">25</span>);</span><br><span class="line">        rbt.insert(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        rbt.display();  <span class="comment">// In-order traversal: 10 15 20 25 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
<h4 id="问：红黑树和AVL树？"><a href="#问：红黑树和AVL树？" class="headerlink" title="问：红黑树和AVL树？"></a>问：红黑树和AVL树？</h4><ul>
<li>红黑树<strong>本质是2-3树</strong>，属于平衡二叉树，其2-结点等价于普通二叉树结点，<strong>3-结点本质是非平衡性的缓存</strong>。红黑树本质是用空间换时间，<strong>通过牺牲平衡性减少了插入/删除时的旋转次数</strong>，所以<strong>查询会略慢于AVL树</strong>，但综合各种情况来看性能会略优于AVL树。红黑树非严格平衡二叉树，因为其用红黑链+二叉树来实现3-结点的设计，导致无法严格控制所有空链接到根结点距离相等。</li>
<li>AVL树即平衡二叉查找树，要求是一个空树或左右子树高度差不能超过1，子树仍是平衡二叉树。AVL是其中一种平衡二叉树实现AVL树查询效率会略高于红黑树。AVL树被应用于Windows进程地址空间管理。</li>
</ul>
<p>综合：</p>
<ul>
<li>AVL是严格的平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</li>
<li>红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低开销；</li>
<li>红黑树综合性能略高，AVL查询速度略快。所以简单说，查询多选择AVL树，查询更新次数差不多选红黑树。</li>
<li>AVL树顺序插入和删除时有20%左右的性能优势，红黑树随机操作15%左右优势，现实应用当然一般都是随机情况，所以红黑树得到了更广泛的应用索引为B+树 Hashmap为红黑树。</li>
</ul>
<p>红黑树和AVL树是两种常见的 <strong>自平衡二叉搜索树</strong>，它们在设计和用途上有明显的区别。以下是它们的对比分析：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>红黑树</th>
<th>AVL树</th>
</tr>
</thead>
<tbody><tr>
<td>平衡性质</td>
<td>相对宽松的平衡：基于“黑高平衡”，红色节点可以连续。</td>
<td>严格的平衡：每个节点的左右子树高度差最多为 1。</td>
</tr>
<tr>
<td>主要用途</td>
<td><strong>适用于插入和删除操作较多的场景</strong>（如操作系统内核）。</td>
<td>适用于<strong>查找操作频繁、插入删除较少</strong>的场景。</td>
</tr>
<tr>
<td>平衡调整</td>
<td>通过红黑规则（颜色变化和旋转）进行调整。</td>
<td>通过旋转操作进行调整（单旋或双旋）。</td>
</tr>
<tr>
<td>平衡修复代价</td>
<td>调整代价较低，插入或删除时最多旋转 O(log⁡n)次。</td>
<td>调整代价较高，插入或删除可能触发多次旋转。</td>
</tr>
<tr>
<td>树高</td>
<td>树高为 O(log⁡n)，但比 AVL 树稍高。</td>
<td>树高为 O(log⁡n)，通常低于红黑树。</td>
</tr>
<tr>
<td><strong>查找</strong></td>
<td>O(log⁡n)，树高稍高，性能略低。</td>
<td>O(log⁡n)，更严格平衡，性能更高。</td>
</tr>
<tr>
<td><strong>插入</strong></td>
<td>O(log⁡n)，调整代价较低。</td>
<td>O(log⁡n)，可能触发多次旋转，代价较高。</td>
</tr>
<tr>
<td><strong>删除</strong></td>
<td>O(log⁡n)，调整代价较低。</td>
<td>O(log⁡n)，代价较高，需严格维持平衡。</td>
</tr>
<tr>
<td>常用场景</td>
<td>适合增删改操作频繁的场景，例如：1. STL 中的 <code>std::map</code> 和 <code>std::set</code>。2. Java 中的 <code>TreeMap</code> 和 <code>TreeSet</code>。3. 数据库索引（例如 MongoDB）。</td>
<td>适合查找操作频繁、插入删除较少的场景，例如：1. 数据库的少量动态索引。2. 只读或写入操作较少的结构化数据。</td>
</tr>
<tr>
<td>代码复杂度</td>
<td>实现相对复杂，需要处理颜色规则。</td>
<td>实现稍复杂，需要维护严格平衡条件。</td>
</tr>
<tr>
<td>调整代价</td>
<td>红黑规则放松，调整代价低。</td>
<td>严格平衡，调整代价高。</td>
</tr>
<tr>
<td><strong>优点</strong></td>
<td>1. 插入和删除性能更优（旋转和调整较少）。2. 应对高频动态操作时效率更高。</td>
<td>1. 查找效率更高（更低的树高）。2. 适合频繁查找操作的场景。</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>1. 查找效率比 AVL 稍低。</td>
<td>1. 插入和删除成本高（严格平衡条件）。</td>
</tr>
</tbody></table>
<p><strong>选择建议</strong></p>
<ul>
<li><p>红黑树：</p>
<ul>
<li>如果应用中 <strong>增删操作频繁</strong>，如实时动态更新的数据结构，选择红黑树更为合适。</li>
<li>实际应用中，许多主流库如 <code>TreeMap</code>、<code>TreeSet</code>、<code>std::map</code> 等都采用红黑树。</li>
</ul>
</li>
<li><p>AVL树：</p>
<ul>
<li>如果应用中 <strong>查找操作占主导</strong>，并且插入和删除较少，选择 AVL 树能提供更高的查找效率。</li>
</ul>
</li>
<li><p>适合索引查找等需要严格高效的读操作场景。</p>
</li>
</ul>
<ul>
<li>红黑树：平衡稍松，适合频繁动态操作。</li>
<li>AVL树：平衡严格，适合频繁查找操作。</li>
</ul>
<p>两者的核心权衡在于平衡效率与动态操作的代价，因此根据具体场景需求选择更合适的树结构。</p>
<h4 id="问：为啥redis-zset使用跳跃链表而不用红黑树实现？"><a href="#问：为啥redis-zset使用跳跃链表而不用红黑树实现？" class="headerlink" title="问：为啥redis zset使用跳跃链表而不用红黑树实现？"></a>问：为啥redis zset使用跳跃链表而不用红黑树实现？</h4><p>Redis 的 <code>zset</code>（有序集合）是通过 <strong>跳跃表（skiplist）</strong> 和 <strong>哈希表</strong> 结合实现的，而不是使用红黑树。</p>
<p><strong>1. 跳跃表的简单性与效率</strong></p>
<ul>
<li><strong>实现简单</strong>：跳跃表的代码实现比红黑树简单很多。红黑树的插入、删除和调整操作需要维护复杂的平衡规则，而跳跃表只需要通过随机化索引来保持结构的平均效率。</li>
<li><strong>时间复杂度相似</strong>：跳跃表的时间复杂度为 O(log⁡n，与红黑树相同。Redis 追求极高的性能，跳跃表能够提供足够快的操作效率，而无需引入复杂的红黑树实现。在并发环境下红黑树在插入和删除时需要rebalance，性能不如跳表。</li>
</ul>
<p><strong>2. 跳跃表更适合范围查询</strong></p>
<ul>
<li>跳跃表支持高效的 <strong>范围查询</strong>，例如 <code>ZRANGEBYSCORE</code> 和 <code>ZRANGEBYLEX</code> 操作。由于跳跃表是基于链表的结构，查找起点后，<strong>范围内的元素可以通过链表的线性遍历快速获取</strong>，逻辑简单高效。</li>
<li>红黑树虽然也支持范围查询，但由于它是一种树结构，<strong>范围内的遍历需要进行中序遍历</strong>，指针跳转复杂，效率相对较低。</li>
</ul>
<p><strong>3. 内存使用与存储结构</strong></p>
<ul>
<li>跳跃表的节点通过链表方式组织，存储紧凑，内存布局相对连续。相比之下，红黑树的节点是分散的，指针管理较多，可能带来额外的内存开销。</li>
<li>跳跃表还允许通过随机级别分布来平衡性能和内存使用，使得结构在大规模数据场景下更加灵活。</li>
</ul>
<p><strong>4. 易于实现持久化和数据转储</strong></p>
<ul>
<li>跳跃表的结构非常适合 Redis 的 <strong>RDB 持久化</strong> 和 <strong>AOF（Append Only File）日志</strong>。其数据结构序列化简单，可以直接遍历链表输出所有节点。</li>
<li>红黑树由于复杂的平衡逻辑和多指针结构，实现序列化和反序列化的成本更高。</li>
</ul>
<p><strong>5. 工程上的灵活性与扩展性</strong></p>
<ul>
<li>跳跃表易于实现水平扩展，例如<strong>通过增加跳表层数来支持更大的数据规模</strong>。</li>
<li>Redis 的 <code>zset</code> 不仅使用跳跃表存储数据，还结合了哈希表，用于快速定位特定元素。这种结合方式在跳跃表中实现相对简单，但在红黑树中实现则需要更复杂的设计。</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>跳跃表</th>
<th>红黑树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>时间复杂度</strong></td>
<td>O(log⁡n)</td>
<td>O(log⁡n)</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>简单，基于链表</td>
<td>较复杂，需维护平衡规则</td>
</tr>
<tr>
<td><strong>范围查询效率</strong></td>
<td>高效，链表结构遍历性能优越</td>
<td>较低，需通过中序遍历实现</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>内存利用率较高</td>
<td>节点分散，指针管理开销大</td>
</tr>
<tr>
<td><strong>序列化与持久化</strong></td>
<td>简单，链表遍历即可</td>
<td>复杂，需要特殊处理指针和结构</td>
</tr>
</tbody></table>
<p>Redis 选择跳跃表，是在满足性能需求的基础上，追求实现简单、代码可维护性高的结果。在 Redis 的使用场景中，跳跃表的性能完全足够，并且更适合于 Redis 的整体架构和设计理念。</p>
<h4 id="问：跳表和二叉树的区别？"><a href="#问：跳表和二叉树的区别？" class="headerlink" title="问：跳表和二叉树的区别？"></a>问：跳表和二叉树的区别？</h4><ul>
<li>跳表维持结构平衡的成本较低，完全依靠随机；二叉树则在多次插入删除后，通过再平衡操作来重新调整结构平衡。</li>
<li>跳表非树结构，分索引节点和底层链表节点，索引节点只有右边和下边两条索引，链表节点则只有下个节点索引，而二叉树节点则有左右子结点。</li>
</ul>
<p>补充：Redis通过跳跃表的优化实现Sorted-set维护有序集合，而关系型数据库则采用B+树。</p>
<p><strong>跳表</strong>和<strong>二叉树</strong>都是用于快速查找、插入和删除的数据结构，但它们的实现方式和适用场景不同。以下是两者的详细对比：</p>
<p><strong>1. 数据结构特点</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>跳表</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>结构</strong></td>
<td>多层链表，每层是有序链表</td>
<td>树状结构，每个节点最多有两个子节点</td>
</tr>
<tr>
<td><strong>节点关系</strong></td>
<td>水平和垂直连接，通过随机化生成多层索引</td>
<td>父节点和子节点关系由规则决定</td>
</tr>
<tr>
<td><strong>存储方式</strong></td>
<td>基于链表，节点之间通过指针连接</td>
<td>树状结构，节点之间通过父子指针连接</td>
</tr>
<tr>
<td><strong>平衡维护</strong></td>
<td>通过随机化索引层级近似实现平衡</td>
<td>自平衡二叉树（如红黑树、AVL树）严格保持平衡</td>
</tr>
</tbody></table>
<p><strong>2. 操作复杂度</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>跳表（时间复杂度）</th>
<th>二叉树（时间复杂度）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>查找</strong></td>
<td>O(log⁡n)</td>
<td>O(log⁡n)（平衡树）</td>
</tr>
<tr>
<td><strong>插入</strong></td>
<td>O(log⁡n)</td>
<td>O(log⁡n)（平衡树）</td>
</tr>
<tr>
<td><strong>删除</strong></td>
<td>O(log⁡n)</td>
<td>O(log⁡n)（平衡树）</td>
</tr>
</tbody></table>
<blockquote>
<p>如果二叉树未平衡（普通二叉搜索树），时间复杂度可能退化为 O(n)，但跳表通过随机化索引避免了这种退化。</p>
</blockquote>
<p><strong>3. 实现复杂度</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>跳表</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现复杂度</strong></td>
<td>简单，基于链表和随机化层级</td>
<td>较复杂，需维护平衡性（红黑树、AVL树）</td>
</tr>
<tr>
<td><strong>插入/删除调整</strong></td>
<td>只需更新少量索引</td>
<td>需调整树的平衡性</td>
</tr>
<tr>
<td><strong>代码维护难度</strong></td>
<td>较低，逻辑相对直观</td>
<td>较高，需理解平衡算法和旋转操作</td>
</tr>
</tbody></table>
<p><strong>4. 空间复杂度</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>跳表</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>节点存储</strong></td>
<td>每个节点有多个前进指针，约占 2n2n 指针空间</td>
<td>每个节点占用两个指针空间</td>
</tr>
<tr>
<td><strong>总空间复杂度</strong></td>
<td>O(n)O(n)</td>
<td>O(n)O(n)</td>
</tr>
</tbody></table>
<p><strong>5. 范围查询效率</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>跳表</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>范围查询</strong></td>
<td>高效，链表结构便于线性遍历</td>
<td>中序遍历效率相对较低，需频繁跳转指针</td>
</tr>
</tbody></table>
<p><strong>6. 应用场景</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>跳表</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>适合场景</strong></td>
<td>- Redis 中实现 <code>zset</code>- 内存操作较多</td>
<td>- 数据库索引（如 B+ 树）- 高性能查询</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>不适合磁盘存储，受限于随机化效果</td>
<td>实现复杂，尤其是维护平衡逻辑</td>
</tr>
</tbody></table>
<p><strong>7. 总结</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>跳表</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>优点</strong></td>
<td>- 简单高效，易实现- 范围查询性能更好</td>
<td>- 更严格的平衡性，最坏情况下性能稳定</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>- 查找性能依赖随机化- 空间开销略大</td>
<td>- 实现复杂，操作需要维护平衡</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>- 内存中快速查找、范围查询（如 Redis）</td>
<td>- 更高性能的查询，如数据库索引</td>
</tr>
</tbody></table>
<p>两者各有优劣，跳表更适合于简单实现、快速开发和轻量级场景，而二叉树更适合需要严格平衡、高性能和复杂查询的场景。</p>
<h4 id="问：讲下跳表怎么实现的-哈夫曼编码是怎么回事？"><a href="#问：讲下跳表怎么实现的-哈夫曼编码是怎么回事？" class="headerlink" title="问：讲下跳表怎么实现的?哈夫曼编码是怎么回事？"></a>问：讲下跳表怎么实现的?哈夫曼编码是怎么回事？</h4><p><strong>1. 跳跃表的实现</strong></p>
<p>跳跃表是一种 <strong>基于链表的多层结构</strong>，通过在链表中引入多级索引，实现快速查找、插入和删除操作。它是 Redis <code>zset</code> 的核心数据结构之一。</p>
<p><strong>跳跃表的基本构造</strong></p>
<ol>
<li><strong>层级结构</strong>：<ul>
<li><p>跳跃表是一个多层链表，每一层是一个有序链表。</p>
</li>
<li><p>上层链表比较稀疏，越下层越密集。最底层（Level 0）包含所有元素，表示完整的数据链表。</p>
</li>
<li><p>每一层的节点是下一层节点的子集，高层节点通过随机化生成。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-&gt;               <span class="number">31</span></span><br><span class="line">-&gt;<span class="number">2</span>-&gt;            <span class="number">31</span></span><br><span class="line">-&gt;<span class="number">2</span>-&gt;            <span class="number">31</span>-&gt;    <span class="number">96</span></span><br><span class="line">-&gt;<span class="number">2</span>-&gt;<span class="number">10</span>-&gt;<span class="number">15</span>-&gt;<span class="number">16</span>-&gt;<span class="number">31</span>-&gt;<span class="number">71</span>-&gt;<span class="number">96</span></span><br><span class="line">第一层：</span><br><span class="line">	从起点出发，沿着第一层的指针移动。</span><br><span class="line">	遇到的第一个元素是<span class="number">2</span>，小于<span class="number">16</span>，继续移动。</span><br><span class="line">	遇到的下一个元素是<span class="number">31</span>，大于<span class="number">16</span>，此时停下来，不能再沿着第一层移动了。</span><br><span class="line">第二层：</span><br><span class="line">	回到元素<span class="number">2</span>的位置，沿着第二层的指针移动。</span><br><span class="line">	遇到的第一个元素是<span class="number">10</span>，小于<span class="number">16</span>，继续移动。</span><br><span class="line">	遇到的下一个元素是<span class="number">15</span>，小于<span class="number">16</span>，继续移动。</span><br><span class="line">	遇到的下一个元素是<span class="number">16</span>，等于<span class="number">16</span>，查找成功！</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>节点结构</strong>：每个节点包含：<ul>
<li>数据值data。</li>
<li>多个前进指针（forward pointers），指向不同层的下一个节点。right指针和down指针。</li>
<li>（可选）一些额外的字段（如跨度、排名等）。</li>
</ul>
</li>
<li><strong>构造规则</strong>：节点的层数通过随机算法决定（如抛硬币法），使得节点层数的分布呈指数递减。先插入底层链表，再分别投掷硬币判断是否向上层链表插入。每向上一层预期节点会减少一半，高度预期为logn。</li>
</ol>
<p><strong>跳跃表的核心操作</strong></p>
<ol>
<li><strong>查找操作</strong>：<ul>
<li>从顶层开始，沿着当前层的链表查找目标节点。</li>
<li>如果目标值大于当前节点值，则向右移动；否则向下移动到下一层。</li>
<li>时间复杂度为 O(log⁡n)。</li>
</ul>
</li>
<li><strong>插入操作</strong>：<ul>
<li>查找插入位置后，将新节点插入到所有相关层级。</li>
<li>新节点的层数通过随机化决定。</li>
<li>时间复杂度为 O(log⁡n)。</li>
</ul>
</li>
<li><strong>删除操作</strong>：<ul>
<li>查找到目标节点后，将其从上到下所有相关层级中移除。</li>
<li>时间复杂度为 O(log⁡n)。</li>
</ul>
</li>
</ol>
<p><strong>2. 哈夫曼编码</strong></p>
<ul>
<li>哈夫曼编码是一种基于 <strong>贪心算法</strong> 的最优前缀编码，用于无损数据压缩。它通过频率最小化的方式，为更常用的字符分配更短的编码，从而实现高效压缩。</li>
</ul>
<p><strong>基本步骤</strong></p>
<ol>
<li><strong>统计字符频率</strong>：对于每个字符，统计其在数据中的出现频率。</li>
<li><strong>构建优先队列</strong>：将每个字符及其频率作为一个叶子节点放入优先队列（最小堆）。</li>
<li><strong>构建哈夫曼树</strong>：<ul>
<li>每次从队列中取出两个最小频率的节点，合并成一个新节点，新节点的频率等于两个子节点的频率之和。</li>
<li>将新节点放回队列，重复直到队列中只剩一个节点（根节点）。</li>
</ul>
</li>
<li><strong>生成编码</strong>：<ul>
<li>从根节点到叶节点的路径决定每个字符的编码。</li>
<li>通常向左为 <code>0</code>，向右为 <code>1</code>。</li>
</ul>
</li>
</ol>
<p><strong>时间复杂度</strong></p>
<ul>
<li><strong>构建哈夫曼树</strong>：O(nlog⁡n)，主要由优先队列操作决定。</li>
<li><strong>编码生成</strong>：O(n)。</li>
</ul>
<h4 id="问：什么是B树？什么是B-树？二者的区别？"><a href="#问：什么是B树？什么是B-树？二者的区别？" class="headerlink" title="问：什么是B树？什么是B+树？二者的区别？"></a>问：什么是B树？什么是B+树？二者的区别？</h4><ol>
<li><p><strong>什么是 B 树？</strong></p>
<ul>
<li><p>B树是一种<strong>自平衡</strong>的<strong>多路搜索</strong>树，保证数据的<strong>有序</strong>，一个节点拥有两个以上的子节点，实现<strong>高效</strong>的查找、插入和删除操作。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ol>
<li><p><strong>自平衡</strong>：每次的插入、删除操作，若破坏树的平衡性，则会调整至平衡。</p>
</li>
<li><p><strong>多路搜索树</strong>： </p>
<ul>
<li>平衡二叉树通常是指查找路径只有两种，而B树则不仅仅二叉，所以也叫<strong>平衡多路查找树</strong>。</li>
<li>每个节点可以有多个子节点，通常节点的最大子节点数用阶数 m 表示。</li>
<li>对于一个 m 阶 B 树，每个节点最多有 m−1 个关键字，最多 m 个子节点。</li>
<li>除根节点外，所有节点至少包含 Math.ceil(⌈m/2⌉) - 1 （向上取整）个子节点。</li>
<li>B 树通过限制阶数 m，保证树的高度尽可能低，从而提高搜索、插入、删除的效率。</li>
</ul>
</li>
<li><p><strong>节点有序</strong>：每个节点内的关键字（keys）按递增顺序存储，子节点分布在关键字的两侧。如下图，父节点键值为[10,20]，表示：</p>
<ul>
<li>左子节点的所有键值 &lt;10。</li>
<li>中间子节点的所有键值 ≥10 且 &lt;20。</li>
<li>右子节点的所有键值 ≥20。</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">[10, 20]</span></span><br><span class="line">     /   |   \</span><br><span class="line"><span class="comment">[1,5]</span>  <span class="comment">[12,15]</span> <span class="comment">[25,30]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>操作高效</strong>：查找、插入和删除的时间复杂度均为 <strong>O(log⁡n)</strong> 。</p>
</li>
</ol>
</li>
<li><p><strong>节点结构</strong>：B树的节点包含<strong>关键字</strong>（keys）和<strong>子节点指针</strong>，每个节点可以有<strong>多个子节点</strong>（最多m个）。</p>
</li>
<li><p><strong>数据存储：</strong> B树的每个节点同时<strong>存储数据</strong>，叶子节点包含了数据的完整信息（实际是指针）。</p>
</li>
<li><p><strong>查找方式：</strong> 通过节点间的指针进行逐层搜索，每一层的节点可以包含多个关键字，提高了查找效率。</p>
</li>
<li><p><strong>应用场景：</strong> 适用于内存空间有限，需要高效进行插入、删除和查找操作的场景，例如文件系统的索引结构。<strong>2-3树、红黑树都是常见的B树</strong>。</p>
</li>
<li><p><strong>B树相比平衡二叉树</strong>：B树在每个节点所包含的内容更多，在应用到数据库中的时候，充分利用了磁盘块的原理（磁盘数据存储是<strong>采用块的形式</strong>存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘块大小范围。所以<strong>树的节点能包含更多的内容后，树的层级比原来的二叉树少了</strong>，就可以<strong>减少数据查找的次数和复杂度</strong>。</p>
</li>
<li><p><strong>B树相对于B+树的优点</strong>：如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p>
</li>
<li><p>自平衡操作：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">初始状态，阶数 m=3，高度 h=3：</span><br><span class="line">  节点最多存储 m − 1 = 2个键值。</span><br><span class="line">  节点最少存储 Math.ceil(⌈m/2⌉) - 1 = 1个键值。</span><br><span class="line">  最多有m = 3和子节点。</span><br><span class="line">  </span><br><span class="line">               <span class="comment">[15]</span></span><br><span class="line">            /       \</span><br><span class="line">      <span class="comment">[5, 10]</span>      <span class="comment">[20, 25]</span></span><br><span class="line">     /   |   \      /   |   \</span><br><span class="line">   <span class="comment">[1]</span>  <span class="comment">[6]</span>  <span class="comment">[12]</span> <span class="comment">[17]</span> <span class="comment">[22]</span> <span class="comment">[27]</span></span><br><span class="line">插入键值 13：不破坏平衡</span><br><span class="line">                 <span class="comment">[15]</span></span><br><span class="line">            /            \</span><br><span class="line">      <span class="comment">[5, 10]</span>           <span class="comment">[20, 25]</span></span><br><span class="line">     /   |    \         /   |   \</span><br><span class="line">   <span class="comment">[1]</span>  <span class="comment">[6]</span>  <span class="comment">[12, 13]</span> <span class="comment">[17]</span> <span class="comment">[22]</span> <span class="comment">[27]</span></span><br><span class="line">插入键值 14：破坏平衡，<span class="comment">[12, 13, 14]</span> ，触发分裂，分裂为 <span class="comment">[12]</span> 和 <span class="comment">[14]</span>，中间值 13 上升到父节点 <span class="comment">[5,10]</span>超过上限，需进一步分裂为 <span class="comment">[5]</span> 和 <span class="comment">[13]</span>，中间值 10 上升到根节点：</span><br><span class="line">                  <span class="comment">[10, 15]</span></span><br><span class="line">             /         |         \</span><br><span class="line">          <span class="comment">[5]</span>       <span class="comment">[13]</span>       <span class="comment">[20, 25]</span></span><br><span class="line">        /   \       /   \       /   |   \</span><br><span class="line">      <span class="comment">[1]</span>   <span class="comment">[6]</span>  <span class="comment">[12]</span> <span class="comment">[14]</span>  <span class="comment">[17]</span> <span class="comment">[22]</span> <span class="comment">[27]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>什么是 B+ 树？</strong></p>
<ul>
<li><p>B+树是B树的一种<strong>变体</strong>，增加了链表结构，键值的拷贝被存储在内部结点，键值和记录则存储在叶子结点，叶子结点间相互链接组成一组有序链表。更适合范围查询和顺序访问。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ol>
<li><strong>平衡性：</strong>B+树的每个节点都保持平衡，即每个节点的子节点数量相同或相差1。<strong>能够保持数据稳定有序</strong>，其<strong>插入与修改拥有较稳定的对数时间复杂度</strong>。</li>
<li><strong>多路查找：</strong>B+树的每个节点可以存储多个键值对，因此查找效率较高。</li>
<li><strong>顺序访问：</strong>B+树的叶子节点通过指针连接在一起，形成一个有序链表，因此可以支持顺序访问。</li>
<li><strong>所有数据存储在叶子节点</strong>：<ul>
<li>非叶子节点只存储索引（关键字），不存储具体数据。</li>
<li>叶子节点包含所有关键字及数据，并通过链表相连。</li>
</ul>
</li>
<li><strong>叶子节点链表</strong>：叶子节点按关键字递增顺序排列，通过指针相互连接，便于范围查询。</li>
<li><strong>非叶子节点只起索引作用</strong>：非叶子节点用于导航，使B+树每个非叶子结点所能保存的关键字数大大增加，查找效率更高。</li>
</ol>
</li>
<li><p><strong>节点结构：</strong> B+树的内部节点/非叶子节点只包含关键字和子节点指针，叶子节点存储数据，只存储关键字和指向数据的指针。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">[10, 20]</span></span><br><span class="line">      /   |   \</span><br><span class="line">  <span class="comment">[1,5]</span> <span class="comment">[12,15]</span> <span class="comment">[25,30]</span></span><br><span class="line">   |       |       |</span><br><span class="line"><span class="comment">[1,5]</span>--&gt;<span class="comment">[12,15]</span>--&gt;<span class="comment">[25,30]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>数据存储：</strong> 数据只存储在叶子节点上，叶子节点之间通过两个指针分别指向前一个和后一个节点链接成双向链表，便于范围查询。</p>
</li>
<li><p><strong>查找方式：</strong> 通过内部节点的关键字进行搜索，查找到叶子节点后再进行线性查找，提高了范围查询的效率。</p>
</li>
<li><p><strong>应用场景：</strong> 适用于需要频繁进行范围查询和顺序遍历的场景，例如数据库中的索引结构。</p>
</li>
<li><p>B+ 树元素<strong>自底向上插入</strong>，这与二叉树恰好相反。</p>
</li>
<li><p>B+树叶子结点保存了父结点的所有关键字记录的指针，所有数据地址必须到叶子结点才能获取到，所以每次数据查询的次数都相同。B+树叶子结点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p>
</li>
<li><p>查找操作：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">假设<span class="selector-tag">B</span>+树结构为：</span><br><span class="line">            <span class="selector-attr">[1、10、20]</span></span><br><span class="line">            /</span><br><span class="line">       <span class="selector-attr">[1、4、7]</span>  ......</span><br><span class="line">        /    | </span><br><span class="line"><span class="selector-attr">[1、2、3]</span> <span class="selector-attr">[4、5、6]</span>  ......</span><br><span class="line">一条<span class="selector-tag">SQL</span>查询<span class="selector-tag">id</span>为<span class="selector-tag">5</span>的数据，首先于根节点进行比较，在<span class="selector-tag">1</span>和<span class="selector-tag">10</span>之间，所以到<span class="selector-tag">1</span>连接的第二层节点</span><br><span class="line">再比较后发现位于<span class="selector-tag">4</span>和<span class="selector-tag">7</span>之间，所以到<span class="selector-tag">4</span>连接的叶子节点，最终找到索引值为<span class="selector-tag">5</span>的数据。</span><br><span class="line">总共经历<span class="selector-tag">3</span>个节点，也就是<span class="selector-tag">3</span>个<span class="selector-tag">I</span>/<span class="selector-tag">O</span>操作。</span><br></pre></td></tr></table></figure>

<p>所以<strong>B+树相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。</strong></p>
<p>如果查询条件不是ID，比如走普通索引，则要先查普通索引的B+树找到id，再查主键索引的B+树。若普通索引字段能全部在叶子节点查到，即索引覆盖，无需再查一个B+树。</p>
</li>
<li><p>自平衡操作：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">高度为 3 的 B+ 树（阶数 3）：</span><br><span class="line"> 内部节点存储键值 m−1=2。</span><br><span class="line"> 叶子节点存储键值 m−1=2，并通过链表连接。</span><br><span class="line"> 根节点至少有 2 个子节点。</span><br><span class="line"> 所有键值存储在叶子节点中。</span><br><span class="line"> </span><br><span class="line">              <span class="comment">[15]</span></span><br><span class="line">          /           \</span><br><span class="line">      <span class="comment">[10]</span>             <span class="comment">[20]</span></span><br><span class="line">     /    \           /    \</span><br><span class="line"> <span class="comment">[5, 7]</span> <span class="comment">[10, 12]</span> <span class="comment">[17, 19]</span> <span class="comment">[22, 25]</span></span><br><span class="line">叶子链表: <span class="comment">[5, 7]</span> -&gt; <span class="comment">[10, 12]</span> -&gt; <span class="comment">[17, 19]</span> -&gt; <span class="comment">[22, 25]</span></span><br><span class="line"></span><br><span class="line">插入 键值 13：<span class="comment">[10, 12，13]</span>分裂，中间值12上升 </span><br><span class="line">               <span class="comment">[15]</span></span><br><span class="line">            /       \</span><br><span class="line">      <span class="comment">[10, 12]</span>       <span class="comment">[20]</span></span><br><span class="line">     /   |    \      /   \</span><br><span class="line"> <span class="comment">[5, 7]</span> <span class="comment">[10]</span> <span class="comment">[13]</span> <span class="comment">[17, 19]</span> <span class="comment">[22, 25]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>B 树与 B+ 树的区别？B树和B+树都是左小右大。</p>
<ul>
<li>B+树的<strong>层级更少</strong>：相较于B树，B+树的每个<strong>非叶子</strong>节点存储的关键字数更多（即阶数M更大），树的层级更少所以查询数据更快；</li>
<li>B+树<strong>查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>
<li>B+树<strong>天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>B 树</strong></th>
<th><strong>B+ 树</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据存储位置</strong></td>
<td>数据存储在所有节点中</td>
<td>数据只存储在叶子节点中</td>
</tr>
<tr>
<td><strong>索引节点</strong></td>
<td>非叶子节点存储数据和索引</td>
<td>非叶子节点只存储索引，不存储数据</td>
</tr>
<tr>
<td><strong>叶子节点链表</strong></td>
<td>无叶子节点链表</td>
<td>叶子节点通过链表连接，便于范围查询</td>
</tr>
<tr>
<td><strong>查询效率</strong></td>
<td>查询需要访问到目标数据节点</td>
<td>查询效率更高，因为索引更小</td>
</tr>
<tr>
<td><strong>范围查询效率</strong></td>
<td>需通过树结构遍历多个节点完成范围查询</td>
<td>通过叶子节点链表直接完成范围查询</td>
</tr>
<tr>
<td><strong>树的高度</strong></td>
<td>较高</td>
<td>较低，因为索引更小</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>插入、删除频繁的场景</td>
<td>查询频繁且范围查询需求高的场景</td>
</tr>
</tbody></table>
<p><strong>4. 使用场景对比</strong></p>
<ol>
<li><strong>B 树</strong>：<ul>
<li>用于需要频繁插入、删除以及随机访问的场景。</li>
<li>例如：存储数据较小的嵌入式系统。</li>
</ul>
</li>
<li><strong>B+ 树</strong>：<ul>
<li>用于数据库索引和文件系统索引（如 MySQL 的 InnoDB）。</li>
<li>因为支持顺序访问和范围查询，性能更优。</li>
</ul>
</li>
</ol>
<p>B+ 树是实际应用中更常见的选择，尤其是在数据库系统中，因其支持高效的顺序访问和范围查询。</p>
</li>
</ol>
<h4 id="问：数据库索引为什么不选用跳表，而是B-树"><a href="#问：数据库索引为什么不选用跳表，而是B-树" class="headerlink" title="问：数据库索引为什么不选用跳表，而是B+树"></a>问：数据库索引为什么不选用跳表，而是B+树</h4><p><strong>1. B+树对磁盘存储更友好</strong></p>
<p><strong>(1) 数据的块式组织</strong></p>
<ul>
<li>数据库的底层是基于磁盘的存储，而磁盘的读取是以块（通常为 4KB 或 8KB）为单位的。</li>
<li><strong>B+树</strong>将节点设计为多路平衡树，每个节点可以包含大量的键值，能够有效利用磁盘块，将多次访问压缩到少量的磁盘 I/O 操作。</li>
</ul>
<p><strong>(2) 顺序访问的高效性</strong></p>
<ul>
<li>B+树的叶子节点以链表方式连接，所有数据都存储在叶子节点中，支持顺序扫描。对范围查询特别高效。</li>
<li><strong>跳表</strong>虽然支持顺序访问，但它没有磁盘块的分组概念，不如 B+树对磁盘友好。</li>
</ul>
<p><strong>2. B+树的多层次索引</strong></p>
<ul>
<li><strong>B+树是多路平衡树</strong>（比如一个 B+树的阶数是 <code>m</code>，每个节点最多有 <code>m-1</code> 个键值和 <code>m</code> 个子节点）。</li>
<li>这种结构使得树的高度较低，即便是百万级或千万级数据，B+树的高度也通常在 3-5 层，查询时只需要访问少量节点。</li>
<li><strong>跳表的高度增长较快</strong>：<ul>
<li>跳表的高度与数据规模相关性较高，数据量增大时，跳表的层数也会增多，导致查询效率降低。</li>
<li>虽然跳表理论上支持 O(log n) 的查找，但其索引层的组织效率在大规模数据中不如 B+树。</li>
</ul>
</li>
</ul>
<p><strong>3. B+树支持范围查询更高效</strong></p>
<ul>
<li>B+树所有数据都存储在叶子节点，并且叶子节点通过链表连接：<ul>
<li>对于范围查询，B+树从某个叶子节点开始，只需沿着链表顺序扫描即可，无需回到上层节点。</li>
</ul>
</li>
<li>跳表支持范围查询，但效率较低：<ul>
<li>跳表需要通过每一层的指针跳跃找到范围的起始节点，然后在底层链表中遍历范围，额外的指针跳跃开销较高。</li>
</ul>
</li>
</ul>
<p><strong>4. B+树的查找效率更稳定</strong></p>
<ul>
<li><strong>B+树的每个节点都保持平衡</strong>，任何一次查找都需要从根节点到叶子节点，路径长度一致，性能稳定。</li>
<li>跳表的性能依赖于概率：<ul>
<li>跳表通过随机化方式生成索引层，虽然均摊复杂度为 O(log n)，但在某些情况下（例如生成的索引层高度偏低），性能可能不稳定。</li>
</ul>
</li>
</ul>
<p><strong>5. 实现的复杂度</strong></p>
<ul>
<li>B+树的实现虽然复杂，但其结构更适合数据库存储需求，已经有成熟的实现和优化。</li>
<li>跳表的实现相对简单，但在复杂的数据库场景下，维护索引层的随机化效果、优化磁盘 I/O 等方面略显不足。</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>B+树</strong></th>
<th><strong>跳表</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>磁盘友好性</strong></td>
<td>节点按磁盘块设计，能减少磁盘 I/O</td>
<td>无磁盘块优化</td>
</tr>
<tr>
<td><strong>范围查询</strong></td>
<td>高效，链表顺序遍历</td>
<td>支持但效率较低</td>
</tr>
<tr>
<td><strong>性能稳定性</strong></td>
<td>查找路径稳定，所有路径长度相同</td>
<td>依赖随机化，可能性能波动</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>复杂，但已成熟优化</td>
<td>简单，但缺乏针对磁盘优化</td>
</tr>
</tbody></table>
<p>由于 B+树更适合大规模数据存储和查询，能够更好地适应数据库索引需求，因此它成为数据库索引的首选，而跳表更适合轻量级应用场景（例如 Redis）。</p>
<h4 id="问：图的数据结构？遍历方法？"><a href="#问：图的数据结构？遍历方法？" class="headerlink" title="问：图的数据结构？遍历方法？"></a>问：图的数据结构？遍历方法？</h4><p>图（Graph）是一种<strong>非线性数据结构</strong>，由<strong>顶点（Vertices）</strong>和<strong>边（Edges）</strong>组成。它广泛用于社交网络、路径查找、计算机网络等领域。</p>
<p><strong>1. 基本概念</strong></p>
<p><strong>(1) 顶点（Vertex / Node）</strong></p>
<ul>
<li>图中的基本单位，通常用 <strong>V</strong> 表示顶点集合。</li>
<li>例如：<code>V = &#123;A, B, C, D, E&#125;</code> 表示 5 个顶点。</li>
</ul>
<p><strong>(2) 边（Edge）</strong></p>
<ul>
<li>顶点之间的连接，通常用 <strong>E</strong> 表示边的集合。</li>
<li>例如：<code>E = &#123;(A, B), (B, C), (C, D), (D, E)&#125;</code>。</li>
</ul>
<p><strong>(3) 图的类型</strong></p>
<p>根据边的方向性和权重，图可以分为：</p>
<ol>
<li>无向图（Undirected Graph）<ul>
<li>边是<strong>无方向</strong>的，<code>(A, B)</code> 表示 A 和 B 互相连接。</li>
<li>例如：<code>A —— B —— C</code></li>
</ul>
</li>
<li>有向图（Directed Graph, Digraph）<ul>
<li>边是<strong>有方向</strong>的，<code>(A → B)</code> 表示 A 指向 B。</li>
<li>例如：<code>A → B → C</code></li>
</ul>
</li>
<li>加权图（Weighted Graph）<ul>
<li>每条边都有一个<strong>权重（Weight）</strong>，表示连接的成本。</li>
<li>例如：<code>A ——(2)—— B ——(3)—— C</code></li>
</ul>
</li>
</ol>
<p><strong>2.存储方式</strong></p>
<p>图可以用<strong>邻接矩阵</strong>和<strong>邻接表</strong>两种方式存储。</p>
<p><strong>(1) 邻接矩阵（Adjacency Matrix）</strong></p>
<ul>
<li><p><strong>定义</strong>：使用一个 <code>N × N</code> 的矩阵 <code>graph[i][j]</code> 存储顶点 <code>i</code> 到 <code>j</code> 之间的边。</p>
</li>
<li><p>特点：</p>
<ul>
<li>适用于 <strong>稠密图（边较多）</strong>。</li>
<li>查询是否有边的时间复杂度为 <code>O(1)</code>。</li>
<li>**空间复杂度：O(N²)**（存储 N² 个元素）。</li>
</ul>
</li>
<li><p>示例（无向图）：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">顶点集合 V = &#123;A, B, C, D&#125;</span><br><span class="line"></span><br><span class="line">     A  B  C  D</span><br><span class="line">  A <span class="number"> 0 </span><span class="number"> 1 </span><span class="number"> 0 </span> 1</span><br><span class="line">  B <span class="number"> 1 </span><span class="number"> 0 </span><span class="number"> 1 </span> 1</span><br><span class="line">  C <span class="number"> 0 </span><span class="number"> 1 </span><span class="number"> 0 </span> 1</span><br><span class="line">  D <span class="number"> 1 </span><span class="number"> 1 </span><span class="number"> 1 </span> 0</span><br></pre></td></tr></table></figure></li>
<li><p>代码实现（Java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] adjMatrix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphMatrix</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        adjMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[size][size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        adjMatrix[u][v] = <span class="number">1</span>; <span class="comment">// 无向图</span></span><br><span class="line">        adjMatrix[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adjMatrix[u][v] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>(2) 邻接表（Adjacency List）</strong></p>
<ul>
<li><p><strong>定义</strong>：使用<strong>链表/列表</strong>存储每个顶点的邻接顶点集合。</p>
</li>
<li><p>特点：</p>
<ul>
<li>适用于 <strong>稀疏图（边较少）</strong>。</li>
<li>存储<strong>仅存在的边</strong>，节省空间。</li>
<li>**空间复杂度：O(N + E)**（存储 N 个顶点和 E 条边）。</li>
</ul>
</li>
<li><p>示例（无向图）：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">A</span><span class="operator">:</span> <span class="variable">B</span> → <span class="built_in">D</span></span><br><span class="line"><span class="variable">B</span><span class="operator">:</span> <span class="variable">A</span> → <span class="built_in">C</span> → <span class="built_in">D</span></span><br><span class="line"><span class="built_in">C</span><span class="operator">:</span> <span class="variable">B</span> → <span class="built_in">D</span></span><br><span class="line"><span class="built_in">D</span><span class="operator">:</span> <span class="variable">A</span> → <span class="variable">B</span> → <span class="built_in">C</span></span><br></pre></td></tr></table></figure></li>
<li><p>代码实现（Java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adjList = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        adjList.putIfAbsent(u, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        adjList.putIfAbsent(v, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        adjList.get(u).add(v);</span><br><span class="line">        adjList.get(v).add(u); <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNeighbors</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adjList.getOrDefault(v, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3. 图的遍历</strong></p>
<p><strong>(1) 深度优先搜索（DFS）</strong></p>
<ul>
<li><p>思路：</p>
<ol>
<li>选择一个起点，从当前节点继续深入访问，直到无法前进，再回溯。</li>
<li>适用于 <strong>连通分量搜索、路径搜索、拓扑排序</strong>。</li>
</ol>
</li>
<li><p>代码（递归实现）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphDFS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; adjList = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        adjList.putIfAbsent(u, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        adjList.putIfAbsent(v, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        adjList.get(u).add(v);</span><br><span class="line">        adjList.get(v).add(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(node)) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        visited.add(node);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : adjList.getOrDefault(node, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">            dfs(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>(2) 广度优先搜索（BFS）</strong></p>
<ul>
<li><p>思路：</p>
<ol>
<li>选择一个起点，先访问当前层的所有节点，再逐层深入。</li>
<li>适用于 <strong>最短路径搜索</strong>（如 <code>Dijkstra</code> 算法）。</li>
</ol>
</li>
<li><p>代码（使用队列实现）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphBFS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;Integer&gt;&gt; adjList = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        adjList.putIfAbsent(u, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        adjList.putIfAbsent(v, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        adjList.get(u).add(v);</span><br><span class="line">        adjList.get(v).add(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(start);</span><br><span class="line">        visited.add(start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">            System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : adjList.getOrDefault(node, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                    visited.add(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4. 图的应用</strong></p>
<table>
<thead>
<tr>
<th><strong>应用</strong></th>
<th><strong>描述</strong></th>
<th><strong>算法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>最短路径</strong></td>
<td>计算最短路径</td>
<td>Dijkstra, Bellman-Ford, Floyd-Warshall</td>
</tr>
<tr>
<td><strong>最小生成树</strong></td>
<td>计算连接所有点的最小代价</td>
<td>Prim, Kruskal</td>
</tr>
<tr>
<td><strong>拓扑排序</strong></td>
<td>依赖关系排序（如课程安排）</td>
<td>Kahn, DFS</td>
</tr>
<tr>
<td><strong>连通分量</strong></td>
<td>计算图中连通的部分</td>
<td>DFS, BFS</td>
</tr>
<tr>
<td><strong>二分图判定</strong></td>
<td>判断是否可二分</td>
<td>DFS</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>存储方式</strong></th>
<th><strong>邻接矩阵</strong></th>
<th><strong>邻接表</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>适用情况</strong></td>
<td>稠密图（边多）</td>
<td>稀疏图（边少）</td>
</tr>
<tr>
<td><strong>查询 O(1)</strong></td>
<td>✅</td>
<td>❌（遍历链表 O(N)）</td>
</tr>
<tr>
<td><strong>存储空间 O(N²)</strong></td>
<td>❌（占用空间大）</td>
<td>✅（占用空间小）</td>
</tr>
<tr>
<td><strong>遍历方式</strong></td>
<td>DFS、BFS</td>
<td>DFS、BFS</td>
</tr>
</tbody></table>
<p>如果是稀疏图，建议使用<strong>邻接表</strong>，如果是稠密图，建议使用<strong>邻接矩阵</strong>。🚀</p>
<h4 id="问：动态规划？"><a href="#问：动态规划？" class="headerlink" title="问：动态规划？"></a>问：动态规划？</h4><p><strong>动态规划（Dynamic Programming, DP）</strong>是一种<strong>递归 + 记忆化</strong>的优化思想，适用于<strong>最优子结构</strong>和<strong>重叠子问题</strong>的场景，广泛用于<strong>路径规划、子序列问题、背包问题</strong>等。</p>
<p><strong>1. 适用场景</strong></p>
<p>一个问题可以用动态规划解决，通常满足：</p>
<ol>
<li><strong>最优子结构（Optimal Substructure）</strong><ul>
<li>一个问题的最优解可以由其子问题的最优解推导得出。</li>
<li><strong>示例</strong>：最短路径问题，当前最短路径 = 子路径的最短路径 + 当前节点。</li>
</ul>
</li>
<li><strong>重叠子问题（Overlapping Subproblems）</strong><ul>
<li>相同的子问题会被重复计算，可通过<strong>记忆化存储（缓存）</strong>优化。</li>
<li><strong>示例</strong>：斐波那契数列，<code>F(n) = F(n-1) + F(n-2)</code>，<code>F(n-1)</code> 和 <code>F(n-2)</code> 会多次计算。</li>
</ul>
</li>
</ol>
<p><strong>2. 解题步骤</strong></p>
<p><strong>(1) 确定状态</strong></p>
<ul>
<li>定义 <code>dp[i]</code> 代表问题的某个子问题的解。</li>
<li>例如，斐波那契 <code>dp[i]</code> 代表第 <code>i</code> 个斐波那契数。</li>
</ul>
<p><strong>(2) 确定状态转移方程</strong></p>
<ul>
<li>通过<strong>最优子结构</strong>，找到状态的递推关系。</li>
<li>例如，<code>dp[i] = dp[i-1] + dp[i-2]</code>（斐波那契数列）。</li>
</ul>
<p><strong>(3) 确定初始值</strong></p>
<ul>
<li>例如，<code>dp[0] = 0, dp[1] = 1</code>。</li>
</ul>
<p><strong>(4) 计算顺序</strong></p>
<ul>
<li>一般从<strong>小到大</strong>计算，保证 <code>dp[i]</code> 计算时 <code>dp[i-1]</code> 已经计算好。</li>
</ul>
<p><strong>3. 经典动态规划问题</strong></p>
<p><strong>(1) 斐波那契数列</strong> </p>
<p><strong>问题描述</strong>：求第 <code>n</code> 个斐波那契数，<code>F(n) = F(n-1) + F(n-2)</code>，其中 <code>F(0) = 0, F(1) = 1</code>。</p>
<p><strong>递归（指数时间）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciRecursive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：大量重复计算，时间复杂度 <code>O(2^n)</code>。</p>
<p><strong>记忆化搜索（自顶向下，O(n)）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciMemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span> (memo.containsKey(n)) <span class="keyword">return</span> memo.get(n);</span><br><span class="line">        <span class="keyword">int</span> result = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">        memo.put(n, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态规划（自底向上，O(n)）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciDP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化空间复杂度（O(1)）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciOptimized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            temp = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>(2) 最长上升子序列（LIS）</strong></p>
<p><strong>问题描述</strong>：给定数组 <code>nums</code>，找到<strong>最长递增子序列</strong>的长度。<br><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [10, 9, 2, 5, 3, 7, 101, 18]</span><br><span class="line">输出: 4</span><br><span class="line">最长上升子序列是 [2, 3, 7, 101]</span><br></pre></td></tr></table></figure>

<p><strong>动态规划解法（O(n²)）</strong></p>
<ul>
<li><p><code>dp[i]</code> 代表<strong>以 <code>nums[i]</code> 结尾的最长上升子序列</strong>的长度。</p>
</li>
<li><p>状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以i结尾的队列最长上升子序列长度 = 小于i的各个位置最长上升子序列长度+1</span><br><span class="line">dp[i] = max(dp[j] + 1) for all j &lt; i where nums[j] &lt; nums[i]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>代码实现</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LIS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, maxLIS = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>); <span class="comment">// 初始每个元素自身算 LIS 长度为 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLIS = Math.max(maxLIS, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLIS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>(3) 0/1 背包问题</strong></p>
<p><strong>问题描述</strong>：给定 <code>N</code> 件物品，每件物品有重量 <code>w[i]</code> 和价值 <code>v[i]</code>，一个容量为 <code>W</code> 的背包，求<strong>最大总价值</strong>。</p>
<p><strong>动态规划解法</strong></p>
<ul>
<li><p><strong><code>dp[i][j]</code> 表示前 <code>i</code> 件物品，容量 <code>j</code> 时的最大价值</strong>。</p>
</li>
<li><p>状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前i件物品容量为j时最大价值 = 前i-1件物品容量-当前物品重量，与当前物品价值的最大值。</span><br><span class="line">dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dp[i-1][j]</code>：不选当前物品 <code>i</code>，价值不变。</li>
<li><code>dp[i-1][j-w[i]] + v[i]</code>：选当前物品 <code>i</code>，容量减少 <code>w[i]</code>，价值增加 <code>v[i]</code>。</li>
</ul>
</li>
<li><p><strong>代码实现</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0/1 背包问题 - 动态规划解法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> W 背包的最大容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weights 物品的重量数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 物品的价值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 能装入背包的最大总价值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = weights.length; <span class="comment">// 物品数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i][j] 表示前 i 个物品在容量 j 时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历每个物品（i 从 1 开始，因为 0 号行代表不选任何物品）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历背包容量（j 从 1 开始，因为容量为 0 时最大价值只能是 0）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weights[i - <span class="number">1</span>] &lt;= j) &#123; <span class="comment">// 当前物品能放入背包</span></span><br><span class="line">                    <span class="comment">// 选择：不放入当前物品 vs. 放入当前物品并更新价值</span></span><br><span class="line">                    dp[i][j] = Math.max(</span><br><span class="line">                        dp[i - <span class="number">1</span>][j], <span class="comment">// 不选当前物品，价值与前 i-1 件物品相同</span></span><br><span class="line">                        dp[i - <span class="number">1</span>][j - weights[i - <span class="number">1</span>]] + values[i - <span class="number">1</span>] <span class="comment">// 选当前物品</span></span><br><span class="line">                    );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不能放入当前物品，则价值等于前 i-1 件物品的最优解</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回能装入背包的最大总价值</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>问题</strong></th>
<th><strong>状态定义</strong></th>
<th><strong>状态转移方程</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>斐波那契数列</strong></td>
<td><code>dp[i]</code> 代表第 <code>i</code> 个数</td>
<td><code>dp[i] = dp[i-1] + dp[i-2]</code></td>
</tr>
<tr>
<td><strong>最长上升子序列</strong></td>
<td><code>dp[i]</code> 以 <code>nums[i]</code> 结尾的 LIS 长度</td>
<td><code>dp[i] = max(dp[j] + 1) if nums[j] &lt; nums[i]</code></td>
</tr>
<tr>
<td><strong>0/1 背包</strong></td>
<td><code>dp[i][j]</code> 前 <code>i</code> 个物品，容量 <code>j</code> 时最大价值</td>
<td><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])</code></td>
</tr>
</tbody></table>
<p>动态规划的核心是 <strong>状态定义 + 状态转移方程</strong>，掌握后可以解决大多数最优化问题！🚀</p>
<h4 id="问：哈夫曼编码？"><a href="#问：哈夫曼编码？" class="headerlink" title="问：哈夫曼编码？"></a>问：哈夫曼编码？</h4><p><strong>哈夫曼编码（Huffman Coding）</strong>是一种<strong>最优前缀编码</strong>（Optimal Prefix Code）算法，广泛用于<strong>数据压缩</strong>。它基于贪心策略，以最少的比特数表示出现频率高的字符，从而减少编码长度。</p>
<p><strong>主要特点：</strong></p>
<ul>
<li><strong>前缀编码</strong>：不会出现某个字符的编码是另一个字符编码的前缀，保证唯一可解。</li>
<li><strong>最优性</strong>：对于给定字符集的<strong>定长编码</strong>，哈夫曼编码是最优的。</li>
<li><strong>可变长编码</strong>：不同字符可能使用不同长度的编码，高频字符编码短，低频字符编码长。</li>
</ul>
<p>哈夫曼编码的核心是<strong>哈夫曼树</strong>，构造方式如下：</p>
<ol>
<li><strong>统计字符频率</strong>：计算每个字符出现的次数。</li>
<li><strong>构造优先队列</strong>：按<strong>频率升序</strong>排序，将每个字符视为独立的节点。</li>
<li>合并节点：<ul>
<li>取出频率最小的两个节点，构造一个新节点，权值为两者之和。</li>
<li>让新节点成为这两个节点的父节点，并放回优先队列。</li>
<li>重复此过程，直到队列中仅剩一个节点（即根节点）。</li>
</ul>
</li>
<li>编码生成：<ul>
<li>左子树路径标记为 <code>0</code>，右子树路径标记为 <code>1</code>。</li>
<li>遍历树生成字符对应的二进制编码。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong></p>
<p><strong>输入：</strong> <code>AABBCD</code><br><strong>字符频率统计：</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">A</span>: <span class="number">2</span>, B: <span class="number">2</span>, C: <span class="number">1</span>, D: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>哈夫曼树构造过程：</strong></p>
<ol>
<li>选取最小频率的两个字符 <code>C(1)</code> 和 <code>D(1)</code>，合并为 <code>CD(2)</code>。</li>
<li>选取 <code>CD(2)</code> 和 <code>B(2)</code>，合并为 <code>BCD(4)</code>。</li>
<li>选取 <code>BCD(4)</code> 和 <code>A(2)</code>，合并为 <code>root(6)</code>。</li>
</ol>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">(6)</span></span><br><span class="line">  /   \</span><br><span class="line">A<span class="comment">(2)</span> <span class="comment">(4)</span></span><br><span class="line">    /   \</span><br><span class="line">  B<span class="comment">(2)</span> <span class="comment">(2)</span></span><br><span class="line">     /   \</span><br><span class="line">   C<span class="comment">(1)</span>  D<span class="comment">(1)</span></span><br></pre></td></tr></table></figure>

<p><strong>生成编码表：</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">A</span>: <span class="number">0</span></span><br><span class="line"><span class="attribute">B</span>: <span class="number">10</span></span><br><span class="line"><span class="attribute">C</span>: <span class="number">110</span></span><br><span class="line"><span class="attribute">D</span>: <span class="number">111</span></span><br></pre></td></tr></table></figure>

<p><strong>编码结果：</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">AABBCD</span> → <span class="number">001010110111</span></span><br></pre></td></tr></table></figure>



<p><strong>Java 实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    HuffmanNode left, right;</span><br><span class="line"></span><br><span class="line">    HuffmanNode(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">        <span class="keyword">this</span>.freq = freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈夫曼编码主类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCoding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Character, String&gt; <span class="title">buildHuffmanCode</span><span class="params">(Map&lt;Character, Integer&gt; freqMap)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;HuffmanNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.freq));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建初始节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> entry : freqMap.entrySet()) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> HuffmanNode(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建哈夫曼树</span></span><br><span class="line">        <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            HuffmanNode left = pq.poll();</span><br><span class="line">            HuffmanNode right = pq.poll();</span><br><span class="line">            HuffmanNode parent = <span class="keyword">new</span> HuffmanNode(<span class="string">&#x27;\0&#x27;</span>, left.freq + right.freq);</span><br><span class="line">            parent.left = left;</span><br><span class="line">            parent.right = right;</span><br><span class="line">            pq.offer(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成哈夫曼编码表</span></span><br><span class="line">        Map&lt;Character, String&gt; huffmanCode = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        generateHuffmanCode(pq.poll(), <span class="string">&quot;&quot;</span>, huffmanCode);</span><br><span class="line">        <span class="keyword">return</span> huffmanCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateHuffmanCode</span><span class="params">(HuffmanNode node, String code, Map&lt;Character, String&gt; huffmanCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.ch != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            huffmanCode.put(node.ch, code);</span><br><span class="line">        &#125;</span><br><span class="line">        generateHuffmanCode(node.left, code + <span class="string">&quot;0&quot;</span>, huffmanCode);</span><br><span class="line">        generateHuffmanCode(node.right, code + <span class="string">&quot;1&quot;</span>, huffmanCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String text = <span class="string">&quot;AABBCD&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计字符频率</span></span><br><span class="line">        Map&lt;Character, Integer&gt; freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : text.toCharArray()) &#123;</span><br><span class="line">            freqMap.put(c, freqMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成哈夫曼编码</span></span><br><span class="line">        Map&lt;Character, String&gt; huffmanCode = buildHuffmanCode(freqMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出编码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Huffman Codes: &quot;</span> + huffmanCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编码文本</span></span><br><span class="line">        StringBuilder encodedText = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : text.toCharArray()) &#123;</span><br><span class="line">            encodedText.append(huffmanCode.get(c));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Encoded Text: &quot;</span> + encodedText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Huffman Codes: &#123;<span class="attribute">A</span>=0, <span class="attribute">B</span>=10, <span class="attribute">C</span>=110, <span class="attribute">D</span>=111&#125;</span><br><span class="line">Encoded Text: 001010110111</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>构造哈夫曼树</strong>（最小堆构建 + 合并节点） → <code>O(n log n)</code></li>
<li><strong>编码生成</strong>（DFS 遍历树） → <code>O(n)</code></li>
<li><strong>总时间复杂度</strong> → <strong><code>O(n log n)</code></strong></li>
</ul>
<p><strong>哈夫曼编码的应用</strong></p>
<ul>
<li>文件压缩（ZIP、JPEG、MP3）<ul>
<li>通过<strong>减少冗余</strong>实现压缩，减少存储空间。</li>
</ul>
</li>
<li>数据传输优化（Huffman-based TCP/IP Header Compression）<ul>
<li>在网络数据传输中减少数据大小，提高效率。</li>
</ul>
</li>
<li>图像 &amp; 语音压缩（JPEG、MP3、G.711 编码）<ul>
<li>JPEG 压缩中使用<strong>变长编码</strong>降低存储成本。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>哈夫曼编码利用<strong>贪心策略</strong>，每次选择最小频率字符合并。</li>
<li>生成的编码是<strong>前缀编码</strong>，不会有二义性。</li>
<li>复杂度 <code>O(n log n)</code>，适用于大规模数据压缩。</li>
</ul>
<p>哈夫曼编码在现代计算机科学和数据压缩中扮演着重要角色，是<strong>贪心算法的经典应用之一</strong>。</p>
<h4 id="问：贪心算法？"><a href="#问：贪心算法？" class="headerlink" title="问：贪心算法？"></a>问：贪心算法？</h4><p><strong>贪心算法（Greedy Algorithm）</strong>是一种在<strong>每一步都做出局部最优选择</strong>，最终希望能得到全局最优解的算法。它不回溯或修改之前的决定，而是直接走到问题的终点。</p>
<p><strong>核心思想：</strong></p>
<ul>
<li><strong>贪心选择性（Greedy Choice Property）</strong>：每一步都做出当前最优选择，最终能得到全局最优解。</li>
<li><strong>最优子结构（Optimal Substructure）</strong>：问题的最优解可以由子问题的最优解合并而成。</li>
</ul>
<p>贪心算法通常适用于 <strong>求最优解</strong> 或 <strong>近似最优解</strong> 的问题，常见应用包括 <strong>最小生成树、Huffman 编码、区间调度、活动选择等</strong>。</p>
<p><strong>常见应用</strong></p>
<p><strong>（1）区间选择问题</strong></p>
<p><strong>问题描述：</strong> 给定 <code>n</code> 个区间 <code>[start, end]</code>，求最多能选择多少个互不重叠的区间？</p>
<p><strong>贪心策略：</strong>每次选择<strong>结束时间最早的区间</strong>，然后排除与其重叠的区间。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntervalScheduling</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxNonOverlappingIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按照结束时间排序</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, end = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt;= end) &#123; <span class="comment">// 当前区间的起点 &gt;= 上一个区间的终点，说明不重叠</span></span><br><span class="line">                count++;</span><br><span class="line">                end = interval[<span class="number">1</span>]; <span class="comment">// 更新已选区间的结束时间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] intervals = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line">        System.out.println(maxNonOverlappingIntervals(intervals)); <span class="comment">// 输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>排序：<code>O(n log n)</code></li>
<li>遍历：<code>O(n)</code></li>
<li><strong>总复杂度：<code>O(n log n)</code></strong></li>
</ul>
<p><strong>（2）Huffman 编码</strong></p>
<p><strong>问题描述：</strong> 给定一组字符及其出现频率，构造最优二进制编码，使总编码长度最短。</p>
<p><strong>贪心策略：</strong></p>
<ul>
<li>频率越小的字符越应该用更长的编码。</li>
<li>采用<strong>哈夫曼树（Huffman Tree）</strong>：每次选取两个<strong>最小频率</strong>的节点合并。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    HuffmanNode left, right;</span><br><span class="line">    HuffmanNode(<span class="keyword">int</span> freq) &#123; <span class="keyword">this</span>.freq = freq; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈夫曼编码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCoding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">huffman</span><span class="params">(<span class="keyword">int</span>[] freq)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;HuffmanNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a.freq - b.freq);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化最小堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> f : freq) pq.offer(<span class="keyword">new</span> HuffmanNode(f));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造哈夫曼树</span></span><br><span class="line">        <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            HuffmanNode left = pq.poll(), right = pq.poll();</span><br><span class="line">            HuffmanNode newNode = <span class="keyword">new</span> HuffmanNode(left.freq + right.freq);</span><br><span class="line">            newNode.left = left;</span><br><span class="line">            newNode.right = right;</span><br><span class="line">            pq.offer(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pq.poll().freq; <span class="comment">// 最终根节点的频率即最优编码长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] freq = &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">45</span>&#125;; <span class="comment">// 字符出现频率</span></span><br><span class="line">        System.out.println(huffman(freq)); <span class="comment">// 输出 97（最优编码总长度）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>构造最小堆：<code>O(n log n)</code></li>
<li>取最小值 &amp; 插入堆：<code>O(n log n)</code></li>
<li><strong>总复杂度：<code>O(n log n)</code></strong></li>
</ul>
<p><strong>（3）最小生成树（MST）：Prim / Kruskal 算法</strong></p>
<p><strong>问题描述：</strong> 给定一个<strong>连通无向图</strong>，求最小生成树，使得所有顶点连通且边权总和最小。</p>
<p><strong>贪心策略：</strong></p>
<ul>
<li><strong>Prim 算法</strong>：从任意顶点开始，每次选取<strong>当前能到达的最短边</strong>，不断扩展树。</li>
<li><strong>Kruskal 算法</strong>：按照<strong>边权排序</strong>，然后用并查集（Union-Find）判断是否形成环，<strong>贪心地选取最小边</strong>。</li>
</ul>
<p><strong>Kruskal 代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, weight;</span><br><span class="line">    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> weight) &#123; <span class="keyword">this</span>.u = u; <span class="keyword">this</span>.v = v; <span class="keyword">this</span>.weight = weight; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent[x] == x ? x : (parent[x] = find(parent[x])); <span class="comment">// 路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        parent[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, List&lt;Edge&gt; edges)</span> </span>&#123;</span><br><span class="line">        Collections.sort(edges, (a, b) -&gt; a.weight - b.weight);</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mstWeight = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(edge.u) != find(edge.v)) &#123; <span class="comment">// 不连通则加入 MST</span></span><br><span class="line">                mstWeight += edge.weight;</span><br><span class="line">                union(edge.u, edge.v);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count == n - <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 选够 n-1 条边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Edge&gt; edges = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> Edge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> Edge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="keyword">new</span> Edge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">            <span class="keyword">new</span> Edge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="keyword">new</span> Edge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(kruskal(<span class="number">4</span>, edges)); <span class="comment">// 输出 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>边排序</strong>：<code>O(E log E)</code></li>
<li><strong>并查集查找+合并</strong>：<code>O(E log V)</code></li>
<li><strong>总复杂度：<code>O(E log E)</code></strong></li>
</ul>
<p><strong>贪心算法 vs. 动态规划</strong></p>
<table>
<thead>
<tr>
<th>比较</th>
<th><strong>贪心算法</strong></th>
<th><strong>动态规划</strong></th>
</tr>
</thead>
<tbody><tr>
<td>解决问题类型</td>
<td>最优化问题（局部最优）</td>
<td>复杂优化问题（全局最优）</td>
</tr>
<tr>
<td>是否回溯</td>
<td>不回溯</td>
<td>可能回溯</td>
</tr>
<tr>
<td>适用条件</td>
<td><strong>贪心选择性 + 最优子结构</strong></td>
<td><strong>最优子结构 + 重叠子问题</strong></td>
</tr>
<tr>
<td>常见应用</td>
<td>Huffman 编码、最小生成树、区间调度</td>
<td>背包问题、最长子序列、编辑距离</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>贪心算法</strong> 适用于局部最优能推出全局最优的情况，例如<strong>最小生成树、Huffman 编码、区间调度</strong>等。</li>
<li>需要满足<strong>贪心选择性</strong> 和 <strong>最优子结构</strong>。</li>
<li>若问题存在<strong>后效性</strong>（即当前决策影响未来决策），可能要用 <strong>动态规划</strong> 而非贪心。</li>
</ul>
<p>如果某问题不能保证局部最优能带来全局最优，就需要使用 <strong>动态规划</strong> 或 <strong>回溯</strong> 进行更精确的计算。</p>
<h2 id="三-基础算法题"><a href="#三-基础算法题" class="headerlink" title="三. 基础算法题"></a>三. 基础算法题</h2><h3 id="1-数组和字符串"><a href="#1-数组和字符串" class="headerlink" title="1. 数组和字符串"></a>1. 数组和字符串</h3><ul>
<li>给定一个整数数组，找出和为目标值的两个数（Two Sum 问题）。</li>
<li>判断一个字符串是否是回文字符串。</li>
<li>实现字符串的反转（不用内置函数）。</li>
<li>找到一个数组中连续子数组的最大和（Kadane’s Algorithm）。</li>
<li>给定两个字符串，判断是否是字母异位词（Anagram）。</li>
</ul>
<p>请依次给出如下基础算法的解析、代码、时间和空间复杂度：</p>
<h4 id="Two-Sum-问题：给定一个整数数组，找出和为目标值的两个数"><a href="#Two-Sum-问题：给定一个整数数组，找出和为目标值的两个数" class="headerlink" title="Two Sum 问题：给定一个整数数组，找出和为目标值的两个数"></a>Two Sum 问题：给定一个整数数组，找出和为目标值的两个数</h4><p>解析：</p>
<ul>
<li><strong>暴力法</strong>：通过双重循环遍历所有可能的数对，时间复杂度为 O(n^2)。</li>
<li><strong>哈希表法</strong>：通过哈希表存储已访问的元素，减少查找时间。时间复杂度为 O(n)。</li>
</ul>
<p>代码实现（哈希表法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 哈希表，键存数，值存坐标</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历数组，若与目标的差取不到，则将当前数放入Map，若取到则分别返回二者坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(complement), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;; <span class="comment">// 如果没有找到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TwoSum solution = <span class="keyword">new</span> TwoSum();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] result = solution.twoSum(nums, <span class="number">9</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Indices: [&quot;</span> + result[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + result[<span class="number">1</span>] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，我们只遍历数组一次。</li>
<li><strong>空间复杂度</strong>：O(n)，需要额外的空间来存储哈希表。</li>
</ul>
<h4 id="回文：判断一个字符串是否是回文字符串"><a href="#回文：判断一个字符串是否是回文字符串" class="headerlink" title="回文：判断一个字符串是否是回文字符串"></a>回文：判断一个字符串是否是回文字符串</h4><p><strong>回文字符串是指正着读和反着读都一样的字符串</strong>。可以通过<strong>双指针法</strong>来判断：</p>
<ul>
<li>一个指针从字符串的头开始，另一个指针从尾部开始，逐个比较字符，直到两个指针相遇。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Palindrome</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Palindrome solution = <span class="keyword">new</span> Palindrome();</span><br><span class="line">        System.out.println(solution.isPalindrome(<span class="string">&quot;racecar&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(solution.isPalindrome(<span class="string">&quot;hello&quot;</span>));   <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，我们只需一次遍历字符串。</li>
<li><strong>空间复杂度</strong>：O(1)，只使用常数空间。</li>
</ul>
<h4 id="字符反转：实现字符串的反转（不用内置函数）"><a href="#字符反转：实现字符串的反转（不用内置函数）" class="headerlink" title="字符反转：实现字符串的反转（不用内置函数）"></a>字符反转：实现字符串的反转（不用内置函数）</h4><p>可以通过双指针法来反转字符串，一个指针从头开始，另一个从尾部开始，交换两个指针指向的字符直到两个指针相遇。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[left];</span><br><span class="line">            chars[left] = chars[right];</span><br><span class="line">            chars[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseString solution = <span class="keyword">new</span> ReverseString();</span><br><span class="line">        System.out.println(solution.reverseString(<span class="string">&quot;hello&quot;</span>)); <span class="comment">// &quot;olleh&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，需要遍历整个字符串。</li>
<li><strong>空间复杂度</strong>：O(n)，需要转换为字符数组。</li>
</ul>
<h4 id="动态规划：找到一个数组中连续子数组的最大和（Kadane’s-Algorithm）"><a href="#动态规划：找到一个数组中连续子数组的最大和（Kadane’s-Algorithm）" class="headerlink" title="动态规划：找到一个数组中连续子数组的最大和（Kadane’s Algorithm）"></a>动态规划：找到一个数组中连续子数组的最大和（Kadane’s Algorithm）</h4><p>Kadane’s Algorithm 用于解决最大子数组和问题。通过动态规划的方法，可以在一次遍历中找到最大和：</p>
<ul>
<li>维护一个当前子数组和 <code>currentSum</code> 和最大子数组和 <code>maxSum</code>。</li>
<li>每一步，<code>currentSum</code> 为当前元素和之前的子数组和之和。如果小于当前元素，则从当前元素开始新子数组。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            currentSum = Math.max(nums[i], currentSum + nums[i]);</span><br><span class="line">            maxSum = Math.max(maxSum, currentSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaxSubArray solution = <span class="keyword">new</span> MaxSubArray();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxSubArray(nums)); <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，只需要遍历数组一次。</li>
<li><strong>空间复杂度</strong>：O(1)，只使用常数空间。</li>
</ul>
<h4 id="给定两个字符串，判断是否是字母异位词（Anagram）"><a href="#给定两个字符串，判断是否是字母异位词（Anagram）" class="headerlink" title="给定两个字符串，判断是否是字母异位词（Anagram）"></a>给定两个字符串，判断是否是字母异位词（Anagram）</h4><p>字母异位词是指<strong>两个字符串中的字符相同且出现的次数相同</strong>。常见的做法是排序法或计数法：</p>
<ul>
<li><strong>排序法</strong>：将两个字符串排序后比较是否相同，时间复杂度 O(nlog⁡n)。</li>
<li><strong>计数法</strong>：通过计数每个字符出现的次数，时间复杂度 O(n)。</li>
</ul>
<p>代码实现（计数法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anagram</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; <span class="comment">// 假设是小写字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            count[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Anagram solution = <span class="keyword">new</span> Anagram();</span><br><span class="line">        System.out.println(solution.isAnagram(<span class="string">&quot;anagram&quot;</span>, <span class="string">&quot;nagaram&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(solution.isAnagram(<span class="string">&quot;rat&quot;</span>, <span class="string">&quot;car&quot;</span>));         <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，遍历字符串两次。</li>
<li><strong>空间复杂度</strong>：O(1)，使用一个长度为 26 的数组，空间复杂度是常数。</li>
</ul>
<h3 id="2-排序与搜索"><a href="#2-排序与搜索" class="headerlink" title="2. 排序与搜索"></a>2. 排序与搜索</h3><h4 id="实现快速排序和归并排序"><a href="#实现快速排序和归并排序" class="headerlink" title="实现快速排序和归并排序"></a>实现快速排序和归并排序</h4><p>快速排序（Quick Sort）</p>
<p>解析：</p>
<p>快速排序是一种分治算法，它通过选择一个“基准”元素，将数组分为左右两部分，左边的元素比基准小，右边的元素比基准大，然后递归排序两部分。</p>
<ul>
<li>最坏情况：当每次选取的基准元素都接近数组的最大或最小值时，时间复杂度为 O(n^2)。</li>
<li>最好和平均情况：O(nlog⁡n)。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 对当前子数组进行分区操作，并返回基准元素的索引</span></span><br><span class="line">            <span class="keyword">int</span> pivotIndex = partition(arr, low, high);</span><br><span class="line">            quickSort(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分区方法：以 arr[high] 为基准，将小于等于基准的元素移到基准左侧，</span></span><br><span class="line"><span class="comment">     *          大于基准的元素移到右侧，并返回基准最终所在的索引。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选择当前子数组的最后一个元素作为基准</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[high];</span><br><span class="line">        <span class="comment">// i 表示已处理区域的最后一个位置，初始值为 low - 1</span></span><br><span class="line">        <span class="keyword">int</span> i = low - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素小于等于基准，右移处理区域指针，并交换当前元素到已处理区域的末尾</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把 pivot 放到正确的位置，即已处理区域的末尾</span></span><br><span class="line">        swap(arr, i + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        QuickSort solution = <span class="keyword">new</span> QuickSort();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        solution.quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted array: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：最坏情况 O(n^2)，最佳和平均情况 O(nlog⁡n)，分区总是均匀分割数组。</li>
<li><strong>空间复杂度</strong>：O(log⁡n)，因为递归栈的最大深度为 O(log⁡n)。</li>
</ul>
<p>归并排序（Merge Sort）</p>
<p>解析：</p>
<p>归并排序是一种稳定的排序算法，也是分治算法。通过递归地将数组分为两部分，分别排序，然后合并两个已排序的部分。</p>
<ul>
<li>时间复杂度：无论最坏、最好还是平均情况都是 O(nlog⁡n)O(n \log n)。</li>
<li>空间复杂度：O(n)O(n)，需要额外的空间用于合并。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = arr.length / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 分别复制左右半部分的子数组</span></span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(arr, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(arr, mid, arr.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别对左右半部分递归调用 mergeSort 进行排序</span></span><br><span class="line">        mergeSort(left);</span><br><span class="line">        mergeSort(right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并已排序的左右两部分</span></span><br><span class="line">        merge(arr, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分别指向 left、right 和 arr 的当前索引</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 比较 left 和 right 中的元素，将较小的放入 arr</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class="line">                arr[k++] = left[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k++] = right[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将左右数组剩余的元素放入 arr（如果有剩余）</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; left.length) arr[k++] = left[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; right.length) arr[k++] = right[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MergeSort solution = <span class="keyword">new</span> MergeSort();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        solution.mergeSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted array: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(nlog⁡n)，无论最坏、最好还是平均情况。</li>
<li><strong>空间复杂度</strong>：O(n)，需要额外的数组存储分割的部分。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><strong>归并排序</strong></th>
<th><strong>快速排序</strong></th>
</tr>
</thead>
<tbody><tr>
<td>算法思想</td>
<td>先将数组分成两部分，分别排序后再合并。</td>
<td>选取一个基准值（pivot），将数组划分为比基准值小和大的两部分，然后递归地对两部分排序。</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>时间复杂度稳定，无论数据分布如何，都是 O(nlogn)</td>
<td>平均时间复杂度为 O(nlog⁡n)，但在最坏情况下（比如数组已排序，且每次都选到最小或最大的基准值），退化为 O(n2)。 可通过随机选取基准值或三数取中法降低最坏情况发生的概率。</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>需要额外的数组来存储合并的结果，空间复杂度为 O(n)</td>
<td>不需要额外数组，空间复杂度为 O(log⁡n)（递归栈的深度）</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定排序，两个相等的元素在排序后相对顺序不会改变</td>
<td>不稳定排序，交换操作可能导致相等元素的相对顺序改变</td>
</tr>
</tbody></table>
<ul>
<li><strong>归并排序</strong>：<ul>
<li>对数组 <code>[8, 4, 3, 7, 6, 5, 2, 1]</code>：<ul>
<li>分割为 <code>[8, 4, 3, 7]</code> 和 <code>[6, 5, 2, 1]</code>。</li>
<li>再分割为 <code>[8, 4]</code>, <code>[3, 7]</code>, <code>[6, 5]</code>, <code>[2, 1]</code>。</li>
<li>合并为 <code>[4, 8]</code>, <code>[3, 7]</code>, <code>[5, 6]</code>, <code>[1, 2]</code>。</li>
<li>最终合并为 <code>[1, 2, 3, 4, 5, 6, 7, 8]</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>快速排序</strong>：<ul>
<li>对数组 <code>[8, 4, 3, 7, 6, 5, 2, 1]</code> ：<ul>
<li>选择基准值 <code>1</code>，划分为 <code>[ ]</code> 和 <code>[8, 4, 3, 7, 6, 5, 2]</code>。</li>
<li>递归处理右半部分，基准值 <code>2</code>，划分为 <code>[ ]</code> 和 <code>[8, 4, 3, 7, 6, 5]</code>。</li>
<li>重复直至排序完成。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="在一个旋转排序数组中查找目标值（如-4-5-6-7-0-1-2-）"><a href="#在一个旋转排序数组中查找目标值（如-4-5-6-7-0-1-2-）" class="headerlink" title="在一个旋转排序数组中查找目标值（如 [4, 5, 6, 7, 0, 1, 2]）"></a>在一个旋转排序数组中查找目标值（如 <code>[4, 5, 6, 7, 0, 1, 2]</code>）</h4><ul>
<li>解析：旋转排序数组是一个经过旋转的升序数组，目标是找到该数组中的目标值。我们可以使用修改版的二分查找来完成此任务。通过判断中间元素与左右元素的关系来确定目标值在哪个部分。</li>
<li>如：原始有序数组: [1, 2, 3, 4, 5, 6, 7] 旋转后（以索引 3 为分界点）: [4, 5, 6, 7, 1, 2, 3]</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchRotatedArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 中间值若命中直接返回</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若左边小于当前中间值，说明左侧是有序的</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 左侧有序，若目标值位于左侧，则更新右边界为左侧队尾</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左侧有序，目标值位于右侧，则更新左边界为右侧队首</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左侧无序，说明右侧有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                <span class="comment">// 右侧有序，若目标值位于右侧，则更新左边界为右侧队首</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右侧有序，且目标值位于左侧，则更新右边界为左侧队尾</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果目标值不存在</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SearchRotatedArray solution = <span class="keyword">new</span> SearchRotatedArray();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(solution.search(nums, <span class="number">0</span>)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(solution.search(nums, <span class="number">3</span>)); <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(log⁡n)，由于使用了二分查找。</li>
<li><strong>空间复杂度</strong>：O(1)，只使用常数空间。</li>
</ul>
<h4 id="找出第-K-个最大的元素"><a href="#找出第-K-个最大的元素" class="headerlink" title="找出第 K 个最大的元素"></a>找出第 K 个最大的元素</h4><p>解析：  可以使用快排的思想（快速选择）来找到第 K 个最大的元素。或者使用最小堆来找。</p>
<p>代码实现（快速选择）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLargestElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (pivotIndex == index) <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; index) <span class="keyword">return</span> quickSelect(nums, pivotIndex + <span class="number">1</span>, right, index);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="number">1</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, right);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        KthLargestElement solution = <span class="keyword">new</span> KthLargestElement();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(solution.findKthLargest(nums, <span class="number">2</span>)); <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)O(n) 平均情况下，最坏情况下 O(n2)O(n^2)。</li>
<li><strong>空间复杂度</strong>：O(1)O(1)，只使用常数空间。</li>
</ul>
<h2 id="中级算法题"><a href="#中级算法题" class="headerlink" title="中级算法题"></a>中级算法题</h2><h3 id="1-链表"><a href="#1-链表" class="headerlink" title="1. 链表"></a>1. 链表</h3><h4 id="反转一个单向链表"><a href="#反转一个单向链表" class="headerlink" title="反转一个单向链表"></a>反转一个单向链表</h4><p>解析：我们可以通过<strong>三指针法</strong>来反转链表，逐一改变节点的指向。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前一个指针</span></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 当前指针</span></span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="comment">// 循环链表</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 下一个指针，先指向当前节点的下一个节点</span></span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            <span class="comment">// 将当前节点本来指向nextTemp的指针，改为指向前一个节点prev</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            <span class="comment">// 分别将prev和curr后移一位处理下一个节点</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建链表 [1, 2, 3]</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        ReverseLinkedList solution = <span class="keyword">new</span> ReverseLinkedList();</span><br><span class="line">        ListNode reversedHead = solution.reverseList(head);</span><br><span class="line">        <span class="keyword">while</span> (reversedHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(reversedHead.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            reversedHead = reversedHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><p><strong>时间复杂度</strong>：O(n)，需要遍历一次链表。</p>
</li>
<li><p><strong>空间复杂度</strong>：O(1)，只使用常数空间。</p>
</li>
</ul>
<h4 id="判断一个链表是否有环，并找到环的起始点"><a href="#判断一个链表是否有环，并找到环的起始点" class="headerlink" title="判断一个链表是否有环，并找到环的起始点"></a>判断一个链表是否有环，并找到环的起始点</h4><p>解析：可以使用<strong>快慢指针</strong>的方法。通过快指针和慢指针相遇来判断链表是否有环，再通过另一个指针找出环的起始点。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListCycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="comment">// 循环遍历链表，慢指针移动一步，快指针移动两步，若二者相遇，说明有环</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="comment">// 有环，则让ptr从头追赶slow指针，相遇则为环的起点</span></span><br><span class="line">                ListNode ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 无环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建链表并构造环</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> ListNode(-<span class="number">4</span>);</span><br><span class="line">        head.next.next.next.next = head.next; <span class="comment">// 环</span></span><br><span class="line"></span><br><span class="line">        LinkedListCycle solution = <span class="keyword">new</span> LinkedListCycle();</span><br><span class="line">        ListNode cycleStart = solution.detectCycle(head);</span><br><span class="line">        <span class="keyword">if</span> (cycleStart != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cycle starts at node with value: &quot;</span> + cycleStart.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No cycle.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，快慢指针遍历链表。</li>
<li><strong>空间复杂度</strong>：O(1)，只使用常数空间。</li>
</ul>
<h4 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h4><p>解析：我们可以使用<strong>双指针</strong>方法，逐个比较两个链表的节点，并将较小的节点连接到结果链表中。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTwoSortedLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) current.next = l1;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) current.next = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个排序链表</span></span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        l1.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        l1.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        l2.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        l2.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        MergeTwoSortedLists solution = <span class="keyword">new</span> MergeTwoSortedLists();</span><br><span class="line">        ListNode mergedList = solution.mergeTwoLists(l1, l2);</span><br><span class="line">        <span class="keyword">while</span> (mergedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(mergedList.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            mergedList = mergedList.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n + m)，需要遍历两个链表。</li>
<li><strong>空间复杂度</strong>：O(1)，不需要额外的空间。</li>
</ul>
<h4 id="给定两个链表，找到它们的交点"><a href="#给定两个链表，找到它们的交点" class="headerlink" title="给定两个链表，找到它们的交点"></a>给定两个链表，找到它们的交点</h4><p>解析：可以使用<strong>双指针</strong>法，让两个指针从头开始走，当指针到达链表尾部时，跳到另一个链表的头部。最终指针会在交点相遇。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntersectionOfLinkedLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pA = headA;</span><br><span class="line">        ListNode pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = (pA == <span class="keyword">null</span>) ? headB : pA.next;</span><br><span class="line">            pB = (pB == <span class="keyword">null</span>) ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个链表并设置交点</span></span><br><span class="line">        ListNode headA = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        headA.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        headA.next.next = <span class="keyword">new</span> ListNode(<span class="number">8</span>);</span><br><span class="line">        headA.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        headA.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        ListNode headB = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        headB.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        headB.next.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        headB.next.next.next = headA.next.next; <span class="comment">// 交点</span></span><br><span class="line"></span><br><span class="line">        IntersectionOfLinkedLists solution = <span class="keyword">new</span> IntersectionOfLinkedLists();</span><br><span class="line">        ListNode intersection = solution.getIntersectionNode(headA, headB);</span><br><span class="line">        System.out.println(intersection != <span class="keyword">null</span> ? intersection.val : <span class="string">&quot;No intersection&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n + m)，需要遍历两个链表。</li>
<li><strong>空间复杂度</strong>：O(1)，只使用常数空间。</li>
</ul>
<h3 id="2-树与图"><a href="#2-树与图" class="headerlink" title="2. 树与图"></a>2. 树与图</h3><p>好的，下面是每个算法的解析、代码实现及时间和空间复杂度分析。</p>
<h4 id="实现二叉树的前序、中序、后序遍历（递归与非递归）"><a href="#实现二叉树的前序、中序、后序遍历（递归与非递归）" class="headerlink" title="实现二叉树的前序、中序、后序遍历（递归与非递归）"></a>实现二叉树的前序、中序、后序遍历（递归与非递归）</h4><p>前序遍历（递归和非递归）</p>
<p>解析：</p>
<ul>
<li><strong>递归方式</strong>：前序遍历是先访问根节点，再遍历左子树，最后遍历右子树。</li>
<li><strong>非递归方式</strong>：使用栈来模拟递归的过程。</li>
</ul>
<p>代码实现（递归方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreOrderTraversal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        PreOrderTraversal solution = <span class="keyword">new</span> PreOrderTraversal();</span><br><span class="line">        solution.preOrder(root);  <span class="comment">// Output: 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现（非递归方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreOrderTraversalNonRecursive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        PreOrderTraversalNonRecursive solution = <span class="keyword">new</span> PreOrderTraversalNonRecursive();</span><br><span class="line">        solution.preOrder(root);  <span class="comment">// Output: 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，需要遍历树的每个节点。</li>
<li><strong>空间复杂度</strong>：O(n)，最坏情况下栈的大小为树的高度，递归时栈深度为 O(h)。</li>
</ul>
<p>中序遍历（递归和非递归）</p>
<p>解析：</p>
<ul>
<li><strong>递归方式</strong>：先遍历左子树，访问根节点，再遍历右子树。</li>
<li><strong>非递归方式</strong>：使用栈来模拟递归的过程，栈保存访问的节点。</li>
</ul>
<p>代码实现（递归方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InOrderTraversal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        InOrderTraversal solution = <span class="keyword">new</span> InOrderTraversal();</span><br><span class="line">        solution.inOrder(root);  <span class="comment">// Output: 2 1 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现（非递归方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InOrderTraversalNonRecursive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode current = root;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(current);</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            current = stack.pop();</span><br><span class="line">            System.out.print(current.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        InOrderTraversalNonRecursive solution = <span class="keyword">new</span> InOrderTraversalNonRecursive();</span><br><span class="line">        solution.inOrder(root);  <span class="comment">// Output: 2 1 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，需要遍历树的每个节点。</li>
<li><strong>空间复杂度</strong>：O(n)，栈存储节点，最坏情况下为树的高度。</li>
</ul>
<p>后序遍历（递归和非递归）</p>
<p>解析：</p>
<ul>
<li><strong>递归方式</strong>：先遍历左子树，再遍历右子树，最后访问根节点。</li>
<li><strong>非递归方式</strong>：使用两个栈或一个栈和一个指针来模拟递归。</li>
</ul>
<p>代码实现（递归方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostOrderTraversal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        postOrder(root.left);</span><br><span class="line">        postOrder(root.right);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        PostOrderTraversal solution = <span class="keyword">new</span> PostOrderTraversal();</span><br><span class="line">        solution.postOrder(root);  <span class="comment">// Output: 2 3 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现（非递归方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostOrderTraversalNonRecursive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack1.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack1.pop();</span><br><span class="line">            stack2.push(node);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) stack1.push(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack1.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">            System.out.print(stack2.pop().val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        PostOrderTraversalNonRecursive solution = <span class="keyword">new</span> PostOrderTraversalNonRecursive();</span><br><span class="line">        solution.postOrder(root);  <span class="comment">// Output: 2 3 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，需要遍历树的每个节点。</li>
<li><strong>空间复杂度</strong>：O(n)，使用栈来存储节点。</li>
</ul>
<h4 id="求二叉树的最大深度"><a href="#求二叉树的最大深度" class="headerlink" title="求二叉树的最大深度"></a>求二叉树的最大深度</h4><p>解析：最大深度是从根节点到最远叶节点的路径长度。可以使用<strong>深度优先搜索</strong>（DFS）递归遍历树来计算最大深度。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxDepth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        MaxDepth solution = <span class="keyword">new</span> MaxDepth();</span><br><span class="line">        System.out.println(solution.maxDepth(root));  <span class="comment">// Output: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)O(n)，需要遍历树的每个节点。</li>
<li><strong>空间复杂度</strong>：O(h)O(h)，递归栈的空间复杂度，hh 是树的高度。</li>
</ul>
<h4 id="验证一个二叉树是否是二叉搜索树（BST）"><a href="#验证一个二叉树是否是二叉搜索树（BST）" class="headerlink" title="验证一个二叉树是否是二叉搜索树（BST）"></a>验证一个二叉树是否是二叉搜索树（BST）</h4><p>解析：二叉搜索树的特性是：左子树所有节点的值小于根节点的值，右子树所有节点的值大于根节点的值，且左右子树分别也是二叉搜索树。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateBST</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= min || root.val &gt;= max) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        ValidateBST solution = <span class="keyword">new</span> ValidateBST();</span><br><span class="line">        System.out.println(solution.isValidBST(root));  <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，需要遍历树的每个节点。</li>
<li><strong>空间复杂度</strong>：(O(h))，递归栈的空间复杂度，h 是树的高度。</li>
</ul>
<h4 id="找到二叉树中两个节点的最近公共祖先（LCA）"><a href="#找到二叉树中两个节点的最近公共祖先（LCA）" class="headerlink" title="找到二叉树中两个节点的最近公共祖先（LCA）"></a>找到二叉树中两个节点的最近公共祖先（LCA）</h4><p>解析：使用递归，遍历树。若当前节点是两个节点之一，则返回当前节点。如果左右子树分别包含这两个节点，则当前节点为它们的最近公共祖先。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowestCommonAncestor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        LowestCommonAncestor solution = <span class="keyword">new</span> LowestCommonAncestor();</span><br><span class="line">        System.out.println(solution.lowestCommonAncestor(root, root.left, root.right).val);  <span class="comment">// Output: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)O，需要遍历树的每个节点。</li>
<li><strong>空间复杂度</strong>：O(h)，递归栈的空间复杂度，h 是树的高度。</li>
</ul>
<h4 id="实现图的深度优先搜索（DFS）和广度优先搜索（BFS）"><a href="#实现图的深度优先搜索（DFS）和广度优先搜索（BFS）" class="headerlink" title="实现图的深度优先搜索（DFS）和广度优先搜索（BFS）"></a>实现图的深度优先搜索（DFS）和广度优先搜索（BFS）</h4><p>深度优先搜索（DFS）</p>
<p>解析：深度优先搜索通过递归或栈来遍历图，探索每一个节点的深度。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        dfsHelper(graph, start, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> node, Set&lt;Integer&gt; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(node)) <span class="keyword">return</span>;</span><br><span class="line">        visited.add(node);</span><br><span class="line">        System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.get(node)) &#123;</span><br><span class="line">            dfsHelper(graph, neighbor, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        graph.put(<span class="number">1</span>, Arrays.asList(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        graph.put(<span class="number">2</span>, Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">        graph.put(<span class="number">3</span>, Arrays.asList(<span class="number">1</span>));</span><br><span class="line">        graph.put(<span class="number">4</span>, Arrays.asList(<span class="number">2</span>));</span><br><span class="line">        graph.put(<span class="number">5</span>, Arrays.asList(<span class="number">2</span>));</span><br><span class="line">        DFS solution = <span class="keyword">new</span> DFS();</span><br><span class="line">        solution.dfs(graph, <span class="number">1</span>);  <span class="comment">// Output: 1 2 4 5 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(V + E)，其中 V 是图的顶点数，E 是图的边数。</li>
<li><strong>空间复杂度</strong>：O(V)，需要存储访问过的节点。</li>
</ul>
<p>广度优先搜索（BFS）</p>
<p>解析：广度优先搜索从起始节点开始，探索所有邻居节点，再逐层向外扩展。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(start);</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">            System.out.print(node + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.get(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                    visited.add(neighbor);</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        graph.put(<span class="number">1</span>, Arrays.asList(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        graph.put(<span class="number">2</span>, Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">        graph.put(<span class="number">3</span>, Arrays.asList(<span class="number">1</span>));</span><br><span class="line">        graph.put(<span class="number">4</span>, Arrays.asList(<span class="number">2</span>));</span><br><span class="line">        graph.put(<span class="number">5</span>, Arrays.asList(<span class="number">2</span>));</span><br><span class="line">        BFS solution = <span class="keyword">new</span> BFS();</span><br><span class="line">        solution.bfs(graph, <span class="number">1</span>);  <span class="comment">// Output: 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(V + E)，其中 V 是图的顶点数，E 是图的边数。</li>
<li><strong>空间复杂度</strong>：O(V)，需要存储访问过的节点。</li>
</ul>
<h4 id="判断一个图是否是连通图"><a href="#判断一个图是否是连通图" class="headerlink" title="判断一个图是否是连通图"></a>判断一个图是否是连通图</h4><p>解析：一个图是连通图，当且仅当图中从任意一个顶点出发，都能到达其他顶点。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsConnectedGraph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        dfs(graph, <span class="number">1</span>, visited);</span><br><span class="line">        <span class="keyword">return</span> visited.size() == n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> node, Set&lt;Integer&gt; visited)</span> </span>&#123;</span><br><span class="line">        visited.add(node);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.get(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                dfs(graph, neighbor, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        graph.put(<span class="number">1</span>, Arrays.asList(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        graph.put(<span class="number">2</span>, Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">        graph.put(<span class="number">3</span>, Arrays.asList(<span class="number">1</span>));</span><br><span class="line">        graph.put(<span class="number">4</span>, Arrays.asList(<span class="number">2</span>));</span><br><span class="line">        graph.put(<span class="number">5</span>, Arrays.asList(<span class="number">2</span>));</span><br><span class="line">        IsConnectedGraph solution = <span class="keyword">new</span> IsConnectedGraph();</span><br><span class="line">        System.out.println(solution.isConnected(graph, <span class="number">5</span>));  <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(V + E)，需要遍历图的每个节点和边。</li>
<li><strong>空间复杂度</strong>：O(V)，需要存储访问过的节点。</li>
</ul>
<h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3. 动态规划"></a>3. 动态规划</h3><h4 id="爬楼梯问题（Fibonacci-数列变种）"><a href="#爬楼梯问题（Fibonacci-数列变种）" class="headerlink" title="爬楼梯问题（Fibonacci 数列变种）"></a>爬楼梯问题（Fibonacci 数列变种）</h4><p>解析：爬楼梯问题是一个经典的动态规划问题。假设你每次可以爬 1 步或 2 步，那么问题变成了计算爬到第 n 阶楼梯的不同方式数。这个问题实际上是 Fibonacci 数列的变种，结果是 dp[i]=dp[i−1]+dp[i−2]，即到达第 i 阶的方法数是到达第 i−1 阶和第 i−2 阶的方法数之和。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>, second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClimbingStairs solution = <span class="keyword">new</span> ClimbingStairs();</span><br><span class="line">        System.out.println(solution.climbStairs(<span class="number">5</span>));  <span class="comment">// Output: 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)，需要遍历每个楼梯，计算方法数。</li>
<li><strong>空间复杂度</strong>：O(1)，只用了常数空间存储状态。</li>
</ul>
<h4 id="找到最长上升子序列（LIS）"><a href="#找到最长上升子序列（LIS）" class="headerlink" title="找到最长上升子序列（LIS）"></a>找到最长上升子序列（LIS）</h4><p>解析：最长上升子序列（LIS）问题是给定一个数组，求出其中的最长递增子序列。这个问题可以用动态规划（DP）来解决，状态转移方程为：<code>dp[i]=max⁡(dp[i],dp[j]+1) for all j &lt; i and nums[j] &lt; nums[i]</code>。最终的答案是所有 dp[i] 中的最大值。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestIncreasingSubsequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;  <span class="comment">// 最长递增子序列至少是该元素本身</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongestIncreasingSubsequence solution = <span class="keyword">new</span> LongestIncreasingSubsequence();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        System.out.println(solution.lengthOfLIS(nums));  <span class="comment">// Output: 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n^2)，双重循环遍历所有元素。</li>
<li><strong>空间复杂度</strong>：O(n)，存储 dp 数组。</li>
</ul>
<p><strong>优化</strong>：通过二分查找优化至 O(nlog⁡n)。</p>
<h4 id="找零钱问题：给定硬币面值数组，求最少硬币数使得总金额为目标值"><a href="#找零钱问题：给定硬币面值数组，求最少硬币数使得总金额为目标值" class="headerlink" title="找零钱问题：给定硬币面值数组，求最少硬币数使得总金额为目标值"></a>找零钱问题：给定硬币面值数组，求最少硬币数使得总金额为目标值</h4><p>解析：找零钱问题是一个典型的动态规划问题。可以通过定义一个数组 dp[i] 来表示金额 i 需要的最少硬币数。状态转移方程为：<code>dp[i]=min⁡(dp[i],dp[i−coin]+1)</code> 其中 coin 是硬币的面值。最后返回 dp[target] 即为答案。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinChange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);  <span class="comment">// 用一个大值初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 零金额不需要硬币</span></span><br><span class="line">        <span class="comment">// 遍历硬币</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// i表示金额，dp[i]表示当前金额所需的最小硬币数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CoinChange solution = <span class="keyword">new</span> CoinChange();</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(solution.coinChange(coins, <span class="number">11</span>));  <span class="comment">// Output: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n×m)，其中 n 是目标金额，m 是硬币的数量。</li>
<li><strong>空间复杂度</strong>：O(n)，用于存储 dp 数组。</li>
</ul>
<h4 id="编辑距离问题：计算两个字符串的最小编辑距离"><a href="#编辑距离问题：计算两个字符串的最小编辑距离" class="headerlink" title="编辑距离问题：计算两个字符串的最小编辑距离"></a>编辑距离问题：计算两个字符串的最小编辑距离</h4><p>解析：编辑距离问题是计算将字符串 A 转换成字符串 B 所需的最小操作次数，允许的操作有：插入、删除和替换字符。这个问题使用动态规划解决，定义 <code>dp[i][j]</code> 为将 <code>A[0..i−1]</code> 转换为 <code>B[0..j−1]</code> 的最小操作数。状态转移方程为： <code>dp[i][j] = min⁡(dp[i−1][j] + 1, dp[i][j−1] + 1, dp[i−1][j−1] + (A[i−1]==B[j−1]?0:1))</code></p>
<p>公式推导：</p>
<p><code>dp[i][j]</code> 表示将字符串 <code>A</code> 的前 <code>i</code> 个字符转换为字符串 <code>B</code> 的前 <code>j</code> 个字符所需的最小编辑步骤数。</p>
<p>计算 <code>dp[i][j]</code> 时，我们有三种情况：</p>
<ol>
<li><strong>删除 A[i-1]（即 A[0…i-1] 的最后一个字符）</strong><ul>
<li>此时 <code>A[0...i-2]</code> 需要变成 <code>B[0...j-1]</code>，然后再**删除 <code>A[i-1]</code>**。</li>
<li>所以 <code>dp[i][j] = dp[i-1][j] + 1</code>（+1 表示删除 <code>A[i-1]</code>）。</li>
</ul>
</li>
<li><strong>插入 B[j-1]（使 A[0…i-1] 变得和 B[0…j-1] 相等）</strong><ul>
<li>先让 <code>A[0...i-1]</code> 变成 <code>B[0...j-2]</code>，然后再**插入 <code>B[j-1]</code>**。</li>
<li>所以 <code>dp[i][j] = dp[i][j-1] + 1</code>（+1 表示插入 <code>B[j-1]</code>）。</li>
</ul>
</li>
<li><strong>替换 A[i-1] 变成 B[j-1]（或者如果已经相等就不操作）</strong><ul>
<li>先让 <code>A[0...i-2]</code> 变成 <code>B[0...j-2]</code> ，然后：<ul>
<li>如果 <code>A[i-1] == B[j-1]</code>，则不需要额外操作。</li>
<li>否则，需要**替换 <code>A[i-1]</code> 为 <code>B[j-1]</code>**。</li>
</ul>
</li>
<li>所以 <code>dp[i][j] = dp[i-1][j-1] + (A[i-1] == B[j-1] ? 0 : 1)</code>。</li>
</ul>
</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditDistance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EditDistance solution = <span class="keyword">new</span> EditDistance();</span><br><span class="line">        System.out.println(solution.minDistance(<span class="string">&quot;horse&quot;</span>, <span class="string">&quot;ros&quot;</span>));  <span class="comment">// Output: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(m×n)，需要遍历二维数组。</li>
<li><strong>空间复杂度</strong>：O(m×n)，用于存储 dp 数组。</li>
</ul>
<p><strong>优化</strong>：可以将空间复杂度优化为 O(min⁡(m,n))，只保留上一行或上一列。</p>
<h3 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4. 贪心算法"></a>4. 贪心算法</h3><h4 id="分发糖果问题"><a href="#分发糖果问题" class="headerlink" title="分发糖果问题"></a>分发糖果问题</h4><p>解析：</p>
<p>分发糖果问题是给定一个学生的评分数组，每个学生至少要分配一个糖果，且如果一个学生的评分高于邻居，则该学生分配的糖果数要多于邻居。问题的目标是最小化糖果的总数。</p>
<p>解决方案：可以采用贪心算法，首先从左到右遍历，确保每个学生的糖果数比前面的学生多（如果评分较高）；然后从右到左遍历，确保每个学生的糖果数比后面的学生多（如果评分较高）。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings == <span class="keyword">null</span> || ratings.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = ratings.length;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(candies, <span class="number">1</span>);  <span class="comment">// 每个学生至少一个糖果</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从左到右遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右到左遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = Math.max(candies[i], candies[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies) &#123;</span><br><span class="line">            result += candy;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Candy solution = <span class="keyword">new</span> Candy();</span><br><span class="line">        <span class="keyword">int</span>[] ratings = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(solution.candy(ratings));  <span class="comment">// Output: 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)O(n)，需要两次遍历评分数组。</li>
<li><strong>空间复杂度</strong>：O(n)O(n)，需要额外的 <code>candies</code> 数组存储糖果数。</li>
</ul>
<h4 id="合并区间问题"><a href="#合并区间问题" class="headerlink" title="合并区间问题"></a>合并区间问题</h4><p>解析：</p>
<p>给定一组区间，要求合并所有重叠的区间。可以首先对区间按起始位置排序，然后遍历区间，合并重叠部分。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeIntervals</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        merged.add(intervals[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] last = merged.get(merged.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= last[<span class="number">1</span>]) &#123;</span><br><span class="line">                last[<span class="number">1</span>] = Math.max(last[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MergeIntervals solution = <span class="keyword">new</span> MergeIntervals();</span><br><span class="line">        <span class="keyword">int</span>[][] intervals = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">8</span>, <span class="number">10</span>&#125;, &#123;<span class="number">15</span>, <span class="number">18</span>&#125;&#125;;</span><br><span class="line">        System.out.println(Arrays.deepToString(solution.merge(intervals)));  <span class="comment">// Output: [[1, 6], [8, 10], [15, 18]]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(nlog⁡n)O(n \log n)，排序的时间复杂度是主导因素。</li>
<li><strong>空间复杂度</strong>：O(n)O(n)，需要存储合并后的区间。</li>
</ul>
<h4 id="找出可以装入背包的最大价值（0-1-背包问题）"><a href="#找出可以装入背包的最大价值（0-1-背包问题）" class="headerlink" title="找出可以装入背包的最大价值（0/1 背包问题）"></a>找出可以装入背包的最大价值（0/1 背包问题）</h4><p>解析：</p>
<p>0/1 背包问题是一个经典的动态规划问题。给定一组物品，每个物品有一个重量和价值，目标是从中选择物品，使得总重量不超过背包容量，且总价值最大。我们使用动态规划来求解，定义状态 dp[i][j]dp[i][j] 为前 ii 个物品在背包容量为 jj 的情况下能获得的最大价值。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = weights.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= capacity; w++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weights[i - <span class="number">1</span>] &lt;= w) &#123;</span><br><span class="line">                    dp[i][w] = Math.max(dp[i - <span class="number">1</span>][w], dp[i - <span class="number">1</span>][w - weights[i - <span class="number">1</span>]] + values[i - <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Knapsack solution = <span class="keyword">new</span> Knapsack();</span><br><span class="line">        <span class="keyword">int</span>[] weights = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] values = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">5</span>;</span><br><span class="line">        System.out.println(solution.knapsack(weights, values, capacity));  <span class="comment">// Output: 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n×W)O(n \times W)，其中 nn 是物品数量，WW 是背包容量。</li>
<li><strong>空间复杂度</strong>：O(n×W)O(n \times W)，用于存储 dpdp 数组。</li>
</ul>
<h4 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h4><p>解析：</p>
<p>活动选择问题要求从一组活动中选择尽可能多的活动，使得它们之间不会重叠。这个问题可以通过贪心算法来解决：首先按活动的结束时间进行排序，然后从第一个活动开始选择每个结束时间最早的活动。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivitySelection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">activitySelection</span><span class="params">(<span class="keyword">int</span>[][] activities)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(activities, Comparator.comparingInt(a -&gt; a[<span class="number">1</span>]));  <span class="comment">// 按结束时间排序</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;  <span class="comment">// 至少可以选第一个活动</span></span><br><span class="line">        <span class="keyword">int</span> lastEndTime = activities[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; activities.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (activities[i][<span class="number">0</span>] &gt;= lastEndTime) &#123;  <span class="comment">// 如果当前活动的开始时间大于等于上一个活动的结束时间</span></span><br><span class="line">                count++;</span><br><span class="line">                lastEndTime = activities[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ActivitySelection solution = <span class="keyword">new</span> ActivitySelection();</span><br><span class="line">        <span class="keyword">int</span>[][] activities = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">5</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line">        System.out.println(solution.activitySelection(activities));  <span class="comment">// Output: 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(nlog⁡n)O(n \log n)，排序的时间复杂度是主导因素。</li>
<li><strong>空间复杂度</strong>：O(1)O(1)，只用了常数空间。</li>
</ul>
<h2 id="高级算法题"><a href="#高级算法题" class="headerlink" title="高级算法题"></a>高级算法题</h2><h3 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h3><ul>
<li>找到数组中只出现一次的数字（其他数字出现两次）。</li>
<li>找出两个整数的二进制位的不同个数。</li>
<li>不使用加减乘除实现加法。</li>
</ul>
<h4 id="找到数组中只出现一次的数字（其他数字出现两次）"><a href="#找到数组中只出现一次的数字（其他数字出现两次）" class="headerlink" title="找到数组中只出现一次的数字（其他数字出现两次）"></a>找到数组中只出现一次的数字（其他数字出现两次）</h4><p>解析：</p>
<p>可以通过异或操作来解决这个问题。由于异或具有交换律和结合律，并且 x⊕x=0x \oplus x = 0x⊕x=0，所有出现两次的数字会被消除，最终结果即为只出现一次的数字。</p>
<p>代码实现：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditpublic <span class="class"><span class="keyword">class</span> <span class="title">SingleNumber</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            result ^= num;  <span class="comment">// 对所有数字进行异或操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        SingleNumber solution = <span class="keyword">new</span> <span class="built_in">SingleNumber</span>();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.<span class="built_in">println</span>(solution.<span class="built_in">singleNumber</span>(nums));  <span class="comment">// Output: 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)O(n)O(n)，需要遍历整个数组。</li>
<li><strong>空间复杂度</strong>：O(1)O(1)O(1)，只用了常数空间。</li>
</ul>
<h4 id="找出两个整数的二进制位的不同个数"><a href="#找出两个整数的二进制位的不同个数" class="headerlink" title="找出两个整数的二进制位的不同个数"></a>找出两个整数的二进制位的不同个数</h4><p>解析：</p>
<p>可以通过异或操作得到两个整数的二进制位不同的部分，然后统计该部分的 1 的个数。</p>
<p>代码实现：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditpublic <span class="class"><span class="keyword">class</span> <span class="title">HammingDistance</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">xor</span> = x ^ y;  <span class="comment">// 获取不同的二进制位</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">xor</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            count += <span class="keyword">xor</span> &amp; <span class="number">1</span>;  <span class="comment">// 每次检查最低位是否为1</span></span><br><span class="line">            <span class="keyword">xor</span> &gt;&gt;= <span class="number">1</span>;  <span class="comment">// 右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        HammingDistance solution = <span class="keyword">new</span> <span class="built_in">HammingDistance</span>();</span><br><span class="line">        System.out.<span class="built_in">println</span>(solution.<span class="built_in">hammingDistance</span>(<span class="number">1</span>, <span class="number">4</span>));  <span class="comment">// Output: 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(log⁡n)O(\log n)O(logn)，因为每次右移一位，最多需要处理 O(log⁡n)O(\log n)O(logn) 次。</li>
<li><strong>空间复杂度</strong>：O(1)O(1)O(1)，只用了常数空间。</li>
</ul>
<h4 id="不使用加减乘除实现加法"><a href="#不使用加减乘除实现加法" class="headerlink" title="不使用加减乘除实现加法"></a>不使用加减乘除实现加法</h4><p>解析：</p>
<p>可以通过位运算实现加法。异或运算可以模拟加法的无进位部分，进位部分可以通过与运算计算出来，并左移一位再加到无进位部分上，直到进位为 0。</p>
<p>代码实现：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditpublic <span class="class"><span class="keyword">class</span> <span class="title">AddWithoutOperator</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = a &amp; b;  <span class="comment">// 计算进位</span></span><br><span class="line">            a = a ^ b;  <span class="comment">// 无进位加法</span></span><br><span class="line">            b = carry &lt;&lt; <span class="number">1</span>;  <span class="comment">// 进位左移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        AddWithoutOperator solution = <span class="keyword">new</span> <span class="built_in">AddWithoutOperator</span>();</span><br><span class="line">        System.out.<span class="built_in">println</span>(solution.<span class="built_in">add</span>(<span class="number">5</span>, <span class="number">7</span>));  <span class="comment">// Output: 12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(log⁡n)O(\log n)O(logn)，因为每次进位左移。</li>
<li><strong>空间复杂度</strong>：O(1)O(1)O(1)，只用了常数空间。</li>
</ul>
<p>总结</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>分发糖果问题</td>
<td>O(n)O(n)</td>
<td>O(n)O(n)</td>
</tr>
<tr>
<td>合并区间问题</td>
<td>O(nlog⁡n)O(n \log n)</td>
<td>O(n)O(n)</td>
</tr>
<tr>
<td>0/1 背包问题</td>
<td>O(n×W)O(n \times W)</td>
<td>O(n×W)O(n \times W)</td>
</tr>
<tr>
<td>活动选择问题</td>
<td>O(nlog⁡n)O(n \log n)</td>
<td>O(1)O(1)</td>
</tr>
<tr>
<td>找到只出现一次的数字</td>
<td>O(n)O(n)</td>
<td>O(1)O(1)</td>
</tr>
<tr>
<td>找出两个整数的二进制位差异</td>
<td>O(log⁡n)O(\log n)</td>
<td>O(1)O(1)</td>
</tr>
<tr>
<td>不使用加减乘除实现加法</td>
<td>O(log⁡n)O(\log n)</td>
<td>O(1)O(1)</td>
</tr>
</tbody></table>
<p>这些问题涵盖了常见的贪心算法、动态规划、位运算等常用技巧，适用于面试中的基础算法题。</p>
<h3 id="2-分治法"><a href="#2-分治法" class="headerlink" title="2. 分治法"></a>2. 分治法</h3><ul>
<li>实现大整数的快速乘法（Karatsuba 算法）。</li>
<li>求数组中的逆序对个数。</li>
</ul>
<p>下面是你提到的基础算法的解析、代码实现、时间复杂度和空间复杂度分析：</p>
<h4 id="实现大整数的快速乘法（Karatsuba-算法）"><a href="#实现大整数的快速乘法（Karatsuba-算法）" class="headerlink" title="实现大整数的快速乘法（Karatsuba 算法）"></a>实现大整数的快速乘法（Karatsuba 算法）</h4><p>解析：</p>
<p>Karatsuba 算法通过分治法来实现大整数乘法，可以将时间复杂度从 O(n2)O(n^2) 降低到 O(nlog⁡23)O(n^{\log_2 3})（约为 O(n1.585)O(n^{1.585})）。该算法将两个大整数分为两部分，然后递归计算它们的乘积。</p>
<p><strong>基本思想</strong>：</p>
<ul>
<li>将两个大整数 xx 和 yy 分为两部分：高位和低位。</li>
<li>计算三个部分的乘积：<ol>
<li>z0=low1×low2z_0 = \text{low1} \times \text{low2}</li>
<li>z1=(low1+high1)×(low2+high2)z_1 = (\text{low1} + \text{high1}) \times (\text{low2} + \text{high2})</li>
<li>z2=high1×high2z_2 = \text{high1} \times \text{high2}</li>
</ol>
</li>
<li>使用这些结果计算最终的乘积。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Karatsuba</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">karatsuba</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基础情形：数字足够小，直接计算</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">10</span> || y &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = Math.max(Long.toString(x).length(), Long.toString(y).length());</span><br><span class="line">        <span class="keyword">int</span> half = m / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> high1 = x / (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, half);</span><br><span class="line">        <span class="keyword">long</span> low1 = x % (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, half);</span><br><span class="line">        <span class="keyword">long</span> high2 = y / (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, half);</span><br><span class="line">        <span class="keyword">long</span> low2 = y % (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, half);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        <span class="keyword">long</span> z0 = karatsuba(low1, low2);</span><br><span class="line">        <span class="keyword">long</span> z1 = karatsuba(low1 + high1, low2 + high2);</span><br><span class="line">        <span class="keyword">long</span> z2 = karatsuba(high1, high2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最终结果</span></span><br><span class="line">        <span class="keyword">return</span> z2 * (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, <span class="number">2</span> * half) + (z1 - z2 - z0) * (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, half) + z0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(karatsuba(<span class="number">1234</span>, <span class="number">5678</span>));  <span class="comment">// Output: 7006652</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(nlog⁡23)O(n^{\log_2 3})，通过分治法将时间复杂度降低。</li>
<li><strong>空间复杂度</strong>：O(n)O(n)，递归调用栈的空间消耗。</li>
</ul>
<hr>
<h4 id="求数组中的逆序对个数"><a href="#求数组中的逆序对个数" class="headerlink" title="求数组中的逆序对个数"></a>求数组中的逆序对个数</h4><p>解析：</p>
<p>逆序对是数组中一对元素 (i,j)(i, j)，满足 i&lt;ji &lt; j 且 arr[i]&gt;arr[j]arr[i] &gt; arr[j]。可以通过修改归并排序来解决，时间复杂度为 O(nlog⁡n)O(n \log n)。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InversionCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeCount</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = mergeCount(arr, temp, left, mid) + mergeCount(arr, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        count += merge(arr, temp, left, mid, right);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = left, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[k++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = arr[j++];</span><br><span class="line">                count += (mid - i + <span class="number">1</span>);  <span class="comment">// 逆序对数目</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.arraycopy(temp, left, arr, left, right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countInversions</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">return</span> mergeCount(arr, temp, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(countInversions(arr));  <span class="comment">// Output: 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(nlog⁡n)O(n \log n)，通过归并排序合并子数组。</li>
<li><strong>空间复杂度</strong>：O(n)O(n)，需要额外的临时数组。</li>
</ul>
<hr>
<h3 id="3-高级数据结构"><a href="#3-高级数据结构" class="headerlink" title="3. 高级数据结构"></a>3. 高级数据结构</h3><ul>
<li>实现 LRU 缓存机制。</li>
<li>用栈实现队列。</li>
<li>设计一个支持常数时间插入、删除和随机访问的数据结构。</li>
</ul>
<h4 id="实现-LRU-缓存机制"><a href="#实现-LRU-缓存机制" class="headerlink" title="实现 LRU 缓存机制"></a>实现 LRU 缓存机制</h4><p>解析：</p>
<p>LRU（Least Recently Used）缓存机制要求在缓存已满时，淘汰最久未使用的元素。可以使用 <strong>双向链表</strong> 和 <strong>哈希表</strong> 的结合来实现。</p>
<ul>
<li>哈希表用于快速查找元素。</li>
<li>双向链表用于维护元素的访问顺序，头部表示最近使用，尾部表示最久未使用。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer, Long&gt; accessOrder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        accessOrder = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(capacity, <span class="number">0.75f</span>, <span class="keyword">true</span>);  <span class="comment">// 使用LRU策略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        accessOrder.put(key, System.nanoTime());  <span class="comment">// 更新使用时间</span></span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt;= capacity) &#123;</span><br><span class="line">            <span class="comment">// 找到并删除访问最少的元素</span></span><br><span class="line">            <span class="keyword">long</span> oldest = Long.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> keyToRemove = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : accessOrder.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() &lt; oldest) &#123;</span><br><span class="line">                    oldest = entry.getValue();</span><br><span class="line">                    keyToRemove = entry.getKey();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cache.remove(keyToRemove);</span><br><span class="line">            accessOrder.remove(keyToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">        accessOrder.put(key, System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache lruCache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line">        lruCache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        lruCache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">1</span>));  <span class="comment">// Output: 1</span></span><br><span class="line">        lruCache.put(<span class="number">3</span>, <span class="number">3</span>);                  <span class="comment">// Evicts key 2</span></span><br><span class="line">        System.out.println(lruCache.get(<span class="number">2</span>));  <span class="comment">// Output: -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：<code>get</code> 和 <code>put</code> 操作的时间复杂度为 O(1)O(1)，因为哈希表提供常数时间的查找和插入。</li>
<li><strong>空间复杂度</strong>：O(n)O(n)，缓存存储大小为 nn。</li>
</ul>
<hr>
<h4 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h4><p>解析：</p>
<p>可以使用两个栈来模拟队列。一个栈用于入队，另一个栈用于出队。当出队栈为空时，将入队栈的元素全部转移到出队栈中，这样就可以实现队列的先进先出（FIFO）特性。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue queue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">        queue.push(<span class="number">1</span>);</span><br><span class="line">        queue.push(<span class="number">2</span>);</span><br><span class="line">        System.out.println(queue.peek());  <span class="comment">// Output: 1</span></span><br><span class="line">        System.out.println(queue.pop());   <span class="comment">// Output: 1</span></span><br><span class="line">        System.out.println(queue.empty()); <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：<code>push</code> 操作为</li>
</ul>
<p>O(1)O(1)，<code>pop</code> 和 <code>peek</code> 操作的最坏时间复杂度为 O(n)O(n)，因为每次都需要将所有元素从一个栈移动到另一个栈。</p>
<ul>
<li><strong>空间复杂度</strong>：O(n)O(n)，需要存储两个栈。</li>
</ul>
<hr>
<h4 id="设计一个支持常数时间插入、删除和随机访问的数据结构"><a href="#设计一个支持常数时间插入、删除和随机访问的数据结构" class="headerlink" title="设计一个支持常数时间插入、删除和随机访问的数据结构"></a>设计一个支持常数时间插入、删除和随机访问的数据结构</h4><p>解析：</p>
<p>为了支持常数时间的插入、删除和随机访问，可以使用一个 <strong>哈希表</strong> 和一个 <strong>动态数组</strong> 的结合。哈希表用于通过值查找索引，动态数组用于存储元素并支持随机访问。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        map.put(val, list.size());</span><br><span class="line">        list.add(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> index = map.get(val);</span><br><span class="line">        <span class="keyword">int</span> lastElement = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">        list.set(index, lastElement);</span><br><span class="line">        map.put(lastElement, index);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        map.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> list.get(rand.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomizedSet randomizedSet = <span class="keyword">new</span> RandomizedSet();</span><br><span class="line">        System.out.println(randomizedSet.insert(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(randomizedSet.remove(<span class="number">2</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(randomizedSet.insert(<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(randomizedSet.getRandom()); <span class="comment">// 1 or 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度：</p>
<ul>
<li><p>时间复杂度</p>
<p>：</p>
<ul>
<li><code>insert</code> 和 <code>remove</code> 操作：O(1)O(1)，因为我们通过哈希表和数组的索引来进行操作。</li>
<li><code>getRandom</code> 操作：O(1)O(1)，因为随机访问数组是常数时间操作。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：O(n)O(n)，存储哈希表和动态数组。</p>
</li>
</ul>
<hr>
<p>总结</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>Karatsuba 快速乘法</td>
<td>O(nlog⁡23)O(n^{\log_2 3})</td>
<td>O(n)O(n)</td>
</tr>
<tr>
<td>逆序对计数</td>
<td>O(nlog⁡n)O(n \log n)</td>
<td>O(n)O(n)</td>
</tr>
<tr>
<td>LRU 缓存</td>
<td>O(1)O(1)</td>
<td>O(n)O(n)</td>
</tr>
<tr>
<td>用栈实现队列</td>
<td>O(1)O(1) (均摊)</td>
<td>O(n)O(n)</td>
</tr>
<tr>
<td>支持常数时间插入删除</td>
<td>O(1)O(1)</td>
<td>O(n)O(n)</td>
</tr>
</tbody></table>
<p>这些算法覆盖了从数值计算到数据结构设计的不同应用，展示了高效的操作和实现技巧。</p>
<h3 id="4-图论与网络流"><a href="#4-图论与网络流" class="headerlink" title="4. 图论与网络流"></a>4. 图论与网络流</h3><ul>
<li>最短路径问题（Dijkstra 算法，Floyd-Warshall 算法）。</li>
<li>最小生成树（Kruskal 或 Prim 算法）。</li>
<li>拓扑排序。</li>
<li>最大流问题（Edmonds-Karp 算法）。</li>
</ul>
<p>以下是你要求的各个基础算法的解析、代码、时间复杂度和空间复杂度。</p>
<h4 id="最短路径问题（Dijkstra-算法，Floyd-Warshall-算法）"><a href="#最短路径问题（Dijkstra-算法，Floyd-Warshall-算法）" class="headerlink" title="最短路径问题（Dijkstra 算法，Floyd-Warshall 算法）"></a>最短路径问题（Dijkstra 算法，Floyd-Warshall 算法）</h4><p><strong>Dijkstra 算法</strong></p>
<p><strong>解析：</strong> Dijkstra 算法用于计算从单个源节点到所有其他节点的最短路径。适用于边权非负的图。它通过贪心算法每次选择当前距离源节点最近的未处理节点来逐步扩展最短路径。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> source) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[source] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a[<span class="number">1</span>]));</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;source, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] current = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> u = current[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[u] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[u][v] != <span class="number">0</span> &amp;&amp; !visited[v]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newDist = dist[u] + graph[u][v];</span><br><span class="line">                    <span class="keyword">if</span> (newDist &lt; dist[v]) &#123;</span><br><span class="line">                        dist[v] = newDist;</span><br><span class="line">                        pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;v, dist[v]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] graph = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dist = dijkstra(graph, <span class="number">0</span>);</span><br><span class="line">        System.out.println(Arrays.toString(dist));  <span class="comment">// Output: [0, 1, 4, 3, 7, 9]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(Elog⁡V)O(E \log V)，其中 VV 是顶点数，EE 是边数。 <strong>空间复杂度：</strong> O(V+E)O(V + E)，需要存储图、距离数组和优先队列。</p>
<p><strong>Floyd-Warshall 算法</strong></p>
<p><strong>解析：</strong> Floyd-Warshall 算法用于计算所有节点对之间的最短路径，适用于带负权边的图（不含负权回路）。它使用动态规划逐步更新路径矩阵。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydWarshall</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] floydWarshall(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化距离矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (graph[i][j] != <span class="number">0</span>) dist[i][j] = graph[i][j];</span><br><span class="line">                <span class="keyword">else</span> dist[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐步更新路径矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k] != Integer.MAX_VALUE &amp;&amp; dist[k][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] graph = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] dist = floydWarshall(graph);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : dist) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(row));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(V3)O(V^3)，适用于小规模图。 <strong>空间复杂度：</strong> O(V2)O(V^2)，需要存储距离矩阵。</p>
<hr>
<h4 id="最小生成树（Kruskal-或-Prim-算法）"><a href="#最小生成树（Kruskal-或-Prim-算法）" class="headerlink" title="最小生成树（Kruskal 或 Prim 算法）"></a>最小生成树（Kruskal 或 Prim 算法）</h4><p><strong>Kruskal 算法</strong></p>
<p><strong>解析：</strong> Kruskal 算法是基于边的贪心算法，选择权重最小的边，逐步合并不同的集合，直到形成一个最小生成树。需要使用并查集（Union-Find）来判断是否形成环。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, weight;</span><br><span class="line">        Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> weight) &#123;</span><br><span class="line">            <span class="keyword">this</span>.u = u;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] parent, rank;</span><br><span class="line">        UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x), rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) parent[rootY] = rootX;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) parent[rootX] = rootY;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent[rootY] = rootX;</span><br><span class="line">                    rank[rootX]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, List&lt;Edge&gt; edges)</span> </span>&#123;</span><br><span class="line">        edges.sort(Comparator.comparingInt(e -&gt; e.weight));</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line">        <span class="keyword">int</span> mstWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf.find(edge.u) != uf.find(edge.v)) &#123;</span><br><span class="line">                uf.union(edge.u, edge.v);</span><br><span class="line">                mstWeight += edge.weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Edge&gt; edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        edges.add(<span class="keyword">new</span> Edge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        edges.add(<span class="keyword">new</span> Edge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">        edges.add(<span class="keyword">new</span> Edge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        edges.add(<span class="keyword">new</span> Edge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">        edges.add(<span class="keyword">new</span> Edge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">        System.out.println(kruskal(<span class="number">4</span>, edges));  <span class="comment">// Output: 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(Elog⁡E)O(E \log E)，边排序的时间复杂度。 <strong>空间复杂度：</strong> O(V+E)O(V + E)，需要存储边和并查集。</p>
<p><strong>Prim 算法</strong></p>
<p><strong>解析：</strong> Prim 算法是基于顶点的贪心算法，每次从已连接的点中选择权重最小的边来扩展最小生成树。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prim</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] minEdge = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(minEdge, Integer.MAX_VALUE);</span><br><span class="line">        minEdge[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 从第一个顶点开始</span></span><br><span class="line">        <span class="keyword">int</span> mstWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a[<span class="number">1</span>]));</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] current = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> u = current[<span class="number">0</span>], weight = current[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[u] = <span class="keyword">true</span>;</span><br><span class="line">            mstWeight += weight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; graph[u][v] != <span class="number">0</span> &amp;&amp; graph[u][v] &lt; minEdge[v]) &#123;</span><br><span class="line">                    minEdge[v] = graph[u][v];</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;v, graph[u][v]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mstWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][]</span><br></pre></td></tr></table></figure>

<p>graph = { {0, 1, 2, 0}, {1, 0, 1, 3}, {2, 1, 0, 4}, {0, 3, 4, 0} }; System.out.println(prim(4, graph));  // Output: 6 } }</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">**时间复杂度：** \(<span class="built_in">O</span>(E \log V)\)，使用优先队列。</span><br><span class="line">**空间复杂度：** \(<span class="built_in">O</span>(V + E)\)。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 拓扑排序</span><br><span class="line"></span><br><span class="line">**解析：**</span><br><span class="line">拓扑排序用于有向无环图（DAG），它将图中的顶点按照依赖关系进行排序，确保每个顶点都排在其所有依赖顶点之前。</span><br><span class="line"></span><br><span class="line">**代码实现：**</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopologicalSort</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">topologicalSort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[i][j] != <span class="number">0</span>) inDegree[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) queue.<span class="built_in">offer</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = queue.<span class="built_in">poll</span>();</span><br><span class="line">            result.<span class="built_in">add</span>(u);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (graph[u][v] != <span class="number">0</span> &amp;&amp; --inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.<span class="built_in">offer</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] graph = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">topologicalSort</span>(<span class="number">4</span>, graph));  <span class="comment">// Output: [0, 1, 2, 3]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(V+E)O(V + E)，需要遍历所有的顶点和边。 <strong>空间复杂度：</strong> O(V+E)O(V + E)，存储图和入度数组。</p>
<hr>
<h4 id="最大流问题（Edmonds-Karp-算法）"><a href="#最大流问题（Edmonds-Karp-算法）" class="headerlink" title="最大流问题（Edmonds-Karp 算法）"></a>最大流问题（Edmonds-Karp 算法）</h4><p><strong>解析：</strong> Edmonds-Karp 算法是 Ford-Fulkerson 算法的实现，它通过广度优先搜索（BFS）找到增广路径，并增加流量，直到无法找到增广路径。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdmondsKarp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] capacity, <span class="keyword">int</span>[] parent, <span class="keyword">int</span> source, <span class="keyword">int</span> sink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = capacity.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(parent, -<span class="number">1</span>);</span><br><span class="line">        visited[source] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; capacity[u][v] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">                    parent[v] = u;</span><br><span class="line">                    <span class="keyword">if</span> (v == sink) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">edmondsKarp</span><span class="params">(<span class="keyword">int</span>[][] capacity, <span class="keyword">int</span> source, <span class="keyword">int</span> sink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = capacity.length;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> maxFlow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bfs(capacity, parent, source, sink) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pathFlow = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = sink; v != source; v = parent[v]) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = parent[v];</span><br><span class="line">                pathFlow = Math.min(pathFlow, capacity[u][v]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = sink; v != source; v = parent[v]) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = parent[v];</span><br><span class="line">                capacity[u][v] -= pathFlow;</span><br><span class="line">                capacity[v][u] += pathFlow;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxFlow += pathFlow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] capacity = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">16</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(edmondsKarp(capacity, <span class="number">0</span>, <span class="number">5</span>));  <span class="comment">// Output: 23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(V×E2)O(V \times E^2)，BFS每次查找增广路径，最多进行 EE 次，每次增广可能消耗 O(V)O(V) 时间。 <strong>空间复杂度：</strong> O(V2)O(V^2)，需要存储容量矩阵。</p>
<hr>
<h3 id="5-字符串匹配"><a href="#5-字符串匹配" class="headerlink" title="5. 字符串匹配"></a>5. 字符串匹配</h3><ul>
<li>实现 KMP 算法。</li>
<li>查找字符串中最长的回文子串。</li>
<li>实现 Trie 树。</li>
</ul>
<h4 id="实现-KMP-算法"><a href="#实现-KMP-算法" class="headerlink" title="实现 KMP 算法"></a>实现 KMP 算法</h4><p><strong>解析：</strong> KMP（Knuth-Morris-Pratt）算法用于高效地查找字符串中的子串。它通过预处理模式串来避免多余的字符匹配。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] buildLPS(String pattern) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = pattern.length();</span><br><span class="line">        <span class="keyword">int</span>[] lps = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;  <span class="comment">// 长度为当前最长前后缀长度</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(i) == pattern.charAt(length)) &#123;</span><br><span class="line">                length++;</span><br><span class="line">                lps[i] = length;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (length != <span class="number">0</span>) &#123;</span><br><span class="line">                    length = lps[length - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lps[i] = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KMPsearch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = text.length();</span><br><span class="line">        <span class="keyword">int</span> m = pattern.length();</span><br><span class="line">        <span class="keyword">int</span>[] lps = buildLPS(pattern);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(j) == text.charAt(i)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - j;  <span class="comment">// 找到匹配</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; pattern.charAt(j) != text.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                    j = lps[j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 未找到匹配</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String text = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">        String pattern = <span class="string">&quot;ABABCABAB&quot;</span>;</span><br><span class="line">        System.out.println(KMPsearch(text, pattern));  <span class="comment">// Output: 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(n+m)O(n + m)，其中 nn 是文本长度，mm 是模式串长度。 <strong>空间复杂度：</strong> O(m)O(m)，需要存储最长前后缀数组。</p>
<hr>
<h4 id="查找字符串中最长的回文子串"><a href="#查找字符串中最长的回文子串" class="headerlink" title="查找字符串中最长的回文子串"></a>查找字符串中最长的回文子串</h4><p><strong>解析：</strong> 该问题要求找到字符串中的最长回文子串，可以使用动态规划来解决。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestPalindromicSubstring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        String longest = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">1</span>) dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">2</span>) dp[i][j] = (s.charAt(i) == s.charAt(j));</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; len &gt; longest.length()) &#123;</span><br><span class="line">                    longest = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;babad&quot;</span>;</span><br><span class="line">        System.out.println(longestPalindrome(s));  <span class="comment">// Output: &quot;bab&quot; or &quot;aba&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(n2)O(n^2)，需要填充一个 n×nn \times n 的动态规划表。 <strong>空间复杂度：</strong> O(n2)O(n^2)，存储动态规划表。</p>
<hr>
<h4 id="实现Trie-树"><a href="#实现Trie-树" class="headerlink" title="实现Trie 树"></a>实现Trie 树</h4><p><strong>解析：</strong> Trie 树是一种用于存储字符串的树形数据结构，可以高效地进行前缀查找。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">boolean</span> isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEndOfWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        trie.insert(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        System.out.println(trie.search(<span class="string">&quot;apple&quot;</span>));  <span class="comment">// Output: true</span></span><br><span class="line">        System.out.println(trie.search(<span class="string">&quot;app&quot;</span>));    <span class="comment">// Output: false</span></span><br><span class="line">        System.out.println(trie.startsWith(<span class="string">&quot;app&quot;</span>)); <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(m)O(m)，其中 mm 是单词的长度。 <strong>空间复杂度：</strong> O(m×N)O(m \times N)，mm 是单词的长度，NN 是字符集的大小。</p>
<p><strong>实际应用场景题</strong></p>
<ol>
<li>实现一个固定大小的滑动窗口最大值。</li>
<li>模拟生产者消费者问题。</li>
<li>设计一个电梯调度算法。</li>
<li>给定一组会议时间段，判断是否可以安排所有会议。</li>
<li>分配任务给员工，使得完成所有任务所需的时间最短。</li>
</ol>
<h4 id="实现一个固定大小的滑动窗口最大值"><a href="#实现一个固定大小的滑动窗口最大值" class="headerlink" title="实现一个固定大小的滑动窗口最大值"></a>实现一个固定大小的滑动窗口最大值</h4><p><strong>解析：</strong> 滑动窗口最大值问题要求在一个固定大小的窗口内，找到每个位置的最大值。可以使用双端队列（Deque）来解决，队列保持索引，保证队列中的元素是按值递减的，这样每次滑动窗口时，我们可以高效地获取当前窗口的最大值。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlidingWindowMaximum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 移除窗口外的元素</span></span><br><span class="line">            <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 保持队列内元素的递减性</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从第 k 个元素开始记录最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                result[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow(nums, k)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(n)O(n)，每个元素最多被访问两次（一次进队列，一次出队列）。 <strong>空间复杂度：</strong> O(k)O(k)，队列的最大空间使用为 kk。</p>
<hr>
<h4 id="模拟生产者消费者问题"><a href="#模拟生产者消费者问题" class="headerlink" title="模拟生产者消费者问题"></a>模拟生产者消费者问题</h4><p><strong>解析：</strong> 生产者消费者问题是一个经典的多线程问题，生产者生产数据并将其放入缓冲区，而消费者从缓冲区获取数据。我们可以使用 <code>wait()</code> 和 <code>notify()</code> 来协调生产者和消费者之间的同步。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == MAX_SIZE) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();  <span class="comment">// 缓冲区满，等待消费者消费</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced item, queue size: &quot;</span> + queue.size());</span><br><span class="line">                    queue.notifyAll();  <span class="comment">// 通知消费者可以消费</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者线程</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();  <span class="comment">// 缓冲区空，等待生产者生产</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed item, queue size: &quot;</span> + queue.size());</span><br><span class="line">                    queue.notifyAll();  <span class="comment">// 通知生产者可以生产</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Producer</span><span class="params">()</span>)</span>;</span><br><span class="line">        Thread consumerThread = <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span>)</span>;</span><br><span class="line"></span><br><span class="line">        producerThread.start();</span><br><span class="line">        consumerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong></p>
<ul>
<li>生产者和消费者的操作是常数时间操作。</li>
<li>总体时间复杂度取决于线程的数量和执行时间。</li>
</ul>
<p><strong>空间复杂度：</strong> O(n)O(n)，队列最大大小是 MAX_SIZEMAX_SIZE。</p>
<hr>
<h4 id="设计一个电梯调度算法"><a href="#设计一个电梯调度算法" class="headerlink" title="设计一个电梯调度算法"></a>设计一个电梯调度算法</h4><p><strong>解析：</strong> 电梯调度算法的目标是根据当前电梯的状态和目标楼层来确定最优的调度策略。常见的方法包括：</p>
<ul>
<li><strong>最短寻道时间优先（SSTF）</strong>：选择离当前电梯最近的请求。</li>
<li><strong>扫描算法（SCAN）</strong>：电梯在一方向上移动，直到最远的请求，之后改变方向。</li>
</ul>
<p>在这里，我们使用一个简单的最短寻道时间优先（SSTF）算法来实现。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElevatorScheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FLOOR = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> currentFloor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; requests = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addRequest</span><span class="params">(<span class="keyword">int</span> floor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (floor &gt;= <span class="number">0</span> &amp;&amp; floor &lt; MAX_FLOOR) &#123;</span><br><span class="line">            requests.add(floor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processRequests</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!requests.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 寻找距离当前楼层最近的请求</span></span><br><span class="line">            <span class="keyword">int</span> closestFloor = findClosestFloor();</span><br><span class="line">            System.out.println(<span class="string">&quot;Going to floor: &quot;</span> + closestFloor);</span><br><span class="line">            currentFloor = closestFloor;</span><br><span class="line">            requests.remove(Integer.valueOf(closestFloor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findClosestFloor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> closest = requests.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> minDistance = Math.abs(currentFloor - closest);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> floor : requests) &#123;</span><br><span class="line">            <span class="keyword">int</span> distance = Math.abs(currentFloor - floor);</span><br><span class="line">            <span class="keyword">if</span> (distance &lt; minDistance) &#123;</span><br><span class="line">                closest = floor;</span><br><span class="line">                minDistance = distance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        addRequest(<span class="number">2</span>);</span><br><span class="line">        addRequest(<span class="number">8</span>);</span><br><span class="line">        addRequest(<span class="number">3</span>);</span><br><span class="line">        addRequest(<span class="number">6</span>);</span><br><span class="line">        processRequests();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(n2)O(n^2)，每次查找最近楼层需要遍历请求队列，删除操作也需要 O(n)O(n)。 <strong>空间复杂度：</strong> O(n)O(n)，存储电梯的请求队列。</p>
<hr>
<h4 id="给定一组会议时间段，判断是否可以安排所有会议"><a href="#给定一组会议时间段，判断是否可以安排所有会议" class="headerlink" title="给定一组会议时间段，判断是否可以安排所有会议"></a>给定一组会议时间段，判断是否可以安排所有会议</h4><p><strong>解析：</strong> 这个问题可以转化为判断是否有两个会议的时间段重叠。如果有重叠，说明无法安排所有会议。我们可以按会议开始时间排序，检查相邻会议是否有重叠。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meeting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">    Meeting(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeetingScheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canScheduleAllMeetings</span><span class="params">(List&lt;Meeting&gt; meetings)</span> </span>&#123;</span><br><span class="line">        meetings.sort(Comparator.comparingInt(m -&gt; m.start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; meetings.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meetings.get(i).start &lt; meetings.get(i - <span class="number">1</span>).end) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 存在重叠，不能安排所有会议</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// 所有会议可以安排</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Meeting&gt; meetings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        meetings.add(<span class="keyword">new</span> Meeting(<span class="number">0</span>, <span class="number">30</span>));</span><br><span class="line">        meetings.add(<span class="keyword">new</span> Meeting(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">        meetings.add(<span class="keyword">new</span> Meeting(<span class="number">15</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(canScheduleAllMeetings(meetings));  <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> O(nlog⁡n)O(n \log n)，需要对会议进行排序。 <strong>空间复杂度：</strong> O(n)O(n)，存储会议列表。</p>
<hr>
<h4 id="分配任务给员工，使得完成所有任务所需的时间最短"><a href="#分配任务给员工，使得完成所有任务所需的时间最短" class="headerlink" title="分配任务给员工，使得完成所有任务所需的时间最短"></a>分配任务给员工，使得完成所有任务所需的时间最短</h4><p><strong>解析：</strong> 这是一个经典的负载平衡问题。我们希望在任务数量和任务时间不同的情况下，使得每个员工的工作时间尽可能相同。可以通过将任务按时间排序，分配给工作负载最小的员工来实现。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskScheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minimumTime</span><span class="params">(<span class="keyword">int</span>[] tasks, <span class="keyword">int</span> numEmployees)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numEmployees == <span class="number">0</span> || tasks == <span class="keyword">null</span> || tasks.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(tasks);</span><br><span class="line">        <span class="keyword">int</span>[] employees = <span class="keyword">new</span> <span class="keyword">int</span>[numEmployees];  <span class="comment">// 员工的工作时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tasks.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Arrays.sort(employees);</span><br><span class="line">            employees[<span class="number">0</span>] += tasks[i];  <span class="comment">// 给最空闲的员工分配任务</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> time : employees) &#123;</span><br><span class="line">            maxTime = Math.max(maxTime, time);  <span class="comment">// 找到工作时间最长的员工</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tasks = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> numEmployees = <span class="number">3</span>;</span><br><span class="line">        System.out.println(minimumTime(tasks, numEmployees));  <span class="comment">// Output: 8 &#125; &#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>时间复杂度：</strong> (O(n \log n))，排序任务和员工数组。<br><strong>空间复杂度：</strong> (O(n))，存储任务和员工的工作时间。</p>
<h2 id="四-手撕"><a href="#四-手撕" class="headerlink" title="四.手撕"></a>四.手撕</h2><h4 id="问：找出无序数组中相隔距离最长的逆序对？"><a href="#问：找出无序数组中相隔距离最长的逆序对？" class="headerlink" title="问：找出无序数组中相隔距离最长的逆序对？"></a>问：找出无序数组中相隔距离最长的逆序对？</h4><ul>
<li><strong>逆序对</strong>的定义是：在数组中，对于一对元素 i,j，如果 i&lt;j 且 arr[i]&gt;arr[j]，则称这对元素为逆序对。</li>
<li><strong>相隔距离</strong>：逆序对 (i,j) 的距离是 j−i。</li>
</ul>
<p>要找出无序数组中相隔距离最长的逆序对，可以采用以下思路：</p>
<ol>
<li>确保逆序对满足 arr[i]&gt;arr[j]。</li>
<li>在所有逆序对中找到距离最大的那对。</li>
</ol>
<p>解题思路：</p>
<ol>
<li><strong>暴力法（O(n^2)）</strong>：<ul>
<li>通过两层循环，遍历所有的逆序对，记录下最大距离。</li>
<li>时间复杂度为 O(n^2)，空间复杂度为 O(1)，不适合数据量较大的情况。</li>
</ul>
</li>
<li><strong>优化方法（基于归并排序思想）</strong>：<ul>
<li>我们可以通过改进的归并排序方法来在 O(nlog⁡n) 时间复杂度内找到逆序对，空间复杂度O(n)，需要额外的数组来进行归并操作。这是一种优化后的方法，适用于较大的数组。如果数组较小，可以使用暴力法。</li>
<li>在归并排序过程中，每当我们进行合并操作时，可以计算逆序对的个数，并且可以追踪这些逆序对的位置，进而找到相隔距离最长的逆序对。</li>
</ul>
</li>
</ol>
<p>实现代码（优化方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMaxDistanceReversePairs(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;; <span class="comment">// 无逆序对</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 存储结果的数组，返回最长逆序对的起始位置和终止位置</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxDistance = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 归并排序</span></span><br><span class="line">        mergeSortAndTrack(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归地分割数组，并在合并过程中记录逆序对的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortAndTrack</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSortAndTrack(arr, left, mid, result);</span><br><span class="line">        mergeSortAndTrack(arr, mid + <span class="number">1</span>, right, result);</span><br><span class="line">        mergeAndCount(arr, left, mid, right, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在合并过程中计算逆序对并且更新最大距离的逆序对。具体地，当发现 arr[i]&gt;arr[j]arr[i] &gt; arr[j] 时，我们计算当前逆序对的距离并更新最远的逆序对</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeAndCount</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录逆序对</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[k++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 逆序对：arr[i] &gt; arr[j]</span></span><br><span class="line">                temp[k++] = arr[j++];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = i; p &lt;= mid; p++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> distance = j - p;</span><br><span class="line">                    <span class="keyword">if</span> (distance &gt; result[<span class="number">1</span>] - result[<span class="number">0</span>]) &#123;</span><br><span class="line">                        result[<span class="number">0</span>] = p;</span><br><span class="line">                        result[<span class="number">1</span>] = j - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将剩余元素放入temp数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把临时数组copy回原数组</span></span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, arr, left, temp.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="comment">// 给定数组 `[2, 4, 1, 3, 5]`，我们会得到逆序对 `[4, 1]` 和 `[2, 1]`，并返回最大逆序对的位置。</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] result = solution.findMaxDistanceReversePairs(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;最长逆序对的位置: [&quot;</span> + result[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + result[<span class="number">1</span>] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="问：给出一个rand5-，实现一个分布均匀的rand7-生成器？"><a href="#问：给出一个rand5-，实现一个分布均匀的rand7-生成器？" class="headerlink" title="问：给出一个rand5()，实现一个分布均匀的rand7()生成器？"></a>问：给出一个rand5()，实现一个分布均匀的rand7()生成器？</h4><p>要实现一个基于 <code>rand5()</code> 的分布均匀的 <code>rand7()</code>，可以利用随机数生成器的组合技术。以下是代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rand7FromRand5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mock implementation of rand5() which generates a random number between 1 and 5 (inclusive)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rand5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">5</span>) + <span class="number">1</span>; <span class="comment">// Generates a number in [1, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implementation of rand7() using rand5()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Generate a number in [1, 25] using two rand5() calls</span></span><br><span class="line">            <span class="keyword">int</span> num = (rand5() - <span class="number">1</span>) * <span class="number">5</span> + rand5();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Accept numbers in [1, 21] and discard others</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= <span class="number">21</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">7</span> + <span class="number">1</span>; <span class="comment">// Map to [1, 7]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Test rand7() function</span></span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> random = rand7();</span><br><span class="line">            counts[random - <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print distribution</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            System.out.println((i + <span class="number">1</span>) + <span class="string">&quot;: &quot;</span> + counts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>代码说明：</p>
<ol>
<li><strong>rand5() 的模拟</strong>：<ul>
<li>生成一个 1 到 5 的均匀随机数。</li>
</ul>
</li>
<li><strong>生成 [1, 25] 的均匀随机数</strong>：<ul>
<li><code>(rand5() - 1) * 5 + rand5()</code> 将两个 <code>rand5()</code> 的结果组合成一个 1 到 25 的随机数。</li>
</ul>
</li>
<li>**限制范围为 [1, 21]**：<ul>
<li>舍弃 22 到 25 的值以确保均匀性。<code>21 % 7 == 0</code>，可以完美地映射到 1 到 7。</li>
</ul>
</li>
<li>**映射到 [1, 7]**：<ul>
<li><code>(num - 1) % 7 + 1</code> 将 1 到 21 均匀分布的随机数映射到 1 到 7。</li>
</ul>
</li>
</ol>
<p>输出结果：</p>
<ul>
<li>程序运行后，将打印每个数字（1 到 7）在 1,000,000 次测试中的出现次数，验证其分布均匀性。</li>
</ul>
<p>这是实现基于 <code>rand5()</code> 的 <code>rand7()</code> 的常用方法，兼具效率和正确性。</p>
<h4 id="问：实现堆排序"><a href="#问：实现堆排序" class="headerlink" title="问：实现堆排序"></a>问：实现堆排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main method to sort an array using heap sort</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build a max heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, n, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Extract elements from the heap one by one</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// Move the current root to the end</span></span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Call heapify on the reduced heap</span></span><br><span class="line">            heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To heapify a subtree rooted at index i</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = i; <span class="comment">// Initialize largest as root</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// Left child index</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// Right child index</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the left child is larger than the root</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the right child is larger than the largest so far</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the largest is not the root</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Recursively heapify the affected subtree</span></span><br><span class="line">            heapify(arr, n, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Utility method to swap two elements in an array</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method to test the sorting algorithm</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Original array: &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        heapSort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted array: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>时间复杂度</p>
<ol>
<li><strong>构建最大堆：</strong><br>构建最大堆的时间复杂度为 O(n)。虽然在最坏情况下堆化的单个操作是 O(log⁡n)，但因为堆化是从底层非叶子节点逐层向上进行的，实际复杂度更低，整体为 O(n)。</li>
<li><strong>堆排序过程：</strong><br>对于每一个元素，将堆顶（最大值）与最后一个元素交换，然后对剩下的 n−1,n−2,…,1个元素重新进行堆化。堆化每次的时间复杂度是 O(log⁡n)，总共需要 n−1 次操作，因此排序过程的时间复杂度为 O(nlog⁡n)。</li>
</ol>
<p><strong>总时间复杂度：</strong><br>构建堆和排序过程的复杂度相加，最终为 O(nlog⁡n)O(n \log n)O(nlogn)。</p>
<p>空间复杂度</p>
<p>堆排序是原地排序算法，不需要额外的数组或结构存储中间结果，只使用少量临时变量，空间复杂度为 O(1)O(1)O(1)。</p>
<h4 id="问：给了长度为N的有重复元素的数组，要求输出第10大的数。"><a href="#问：给了长度为N的有重复元素的数组，要求输出第10大的数。" class="headerlink" title="问：给了长度为N的有重复元素的数组，要求输出第10大的数。"></a>问：给了长度为N的有重复元素的数组，要求输出第10大的数。</h4><p>以下是解决该问题的 Java 实现代码，使用 <strong>优先队列（最小堆）</strong> 来高效地找到第 10 大的数，同时总结时间和空间复杂度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Find10thLargest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find10thLargest</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Array must have at least 10 elements.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Min-heap to store the top 10 largest elements</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// Add the number to the heap</span></span><br><span class="line">            <span class="keyword">if</span> (minHeap.size() &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                minHeap.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; minHeap.peek()) &#123;</span><br><span class="line">                <span class="comment">// Replace the smallest element if the current number is larger</span></span><br><span class="line">                minHeap.poll();</span><br><span class="line">                minHeap.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The root of the heap is the 10th largest element</span></span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;The 10th largest number is: &quot;</span> + find10thLargest(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析</p>
<p>时间复杂度：</p>
<ol>
<li>遍历数组需要 O(N)O(N)。</li>
<li>对于每个元素：<ul>
<li>插入或移除堆的时间复杂度为 O(log⁡10)=O(1)O(\log 10) = O(1)。</li>
</ul>
</li>
</ol>
<p>因此，总时间复杂度为 **O(N)O(N)**。</p>
<p>空间复杂度：</p>
<p>优先队列始终存储最多 10 个元素，空间复杂度为 **O(10)=O(1)O(10) = O(1)**。</p>
<h4 id="问：手写一个对象池"><a href="#问：手写一个对象池" class="headerlink" title="问：手写一个对象池"></a>问：手写一个对象池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectPool</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BlockingQueue to hold pool objects</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;T&gt; pool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory&lt;T&gt; factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor to initialize the pool with the given size and factory</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectPool</span><span class="params">(<span class="keyword">int</span> size, ObjectFactory&lt;T&gt; factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pool = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pre-create objects and add them to the pool</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            pool.offer(factory.create());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method to borrow an object from the pool</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">borrowObject</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pool.take();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method to return an object back to the pool</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnObject</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pool.offer(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Factory interface for object creation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Example: Object pool for StringBuilder objects</span></span><br><span class="line">        ObjectPool&lt;StringBuilder&gt; stringBuilderPool = <span class="keyword">new</span> ObjectPool&lt;&gt;(<span class="number">5</span>, StringBuilder::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Borrow an object from the pool</span></span><br><span class="line">            StringBuilder builder = stringBuilderPool.borrowObject();</span><br><span class="line">            builder.append(<span class="string">&quot;Hello, Object Pool!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use the object</span></span><br><span class="line">            System.out.println(builder.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Clear and return the object back to the pool</span></span><br><span class="line">            builder.setLength(<span class="number">0</span>);</span><br><span class="line">            stringBuilderPool.returnObject(builder);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析</p>
<p>功能说明</p>
<ol>
<li><strong>对象复用</strong>：使用预先分配的对象，避免频繁的对象创建和销毁。</li>
<li><strong>线程安全</strong>：使用 <code>BlockingQueue</code> 保障多线程环境下的安全操作。</li>
<li><strong>灵活扩展</strong>：通过 <code>ObjectFactory</code> 提供自定义对象创建逻辑。</li>
</ol>
<p>时间复杂度</p>
<ul>
<li><strong>借用对象</strong>：从队列中取对象，时间复杂度为 **O(1)O(1)O(1)**。</li>
<li><strong>归还对象</strong>：将对象放回队列，时间复杂度为 **O(1)O(1)O(1)**。</li>
</ul>
<p>空间复杂度</p>
<ul>
<li>队列中存储 NNN 个对象，空间复杂度为 **O(N)O(N)O(N)**。</li>
<li>每个对象占用的具体空间取决于其实现。</li>
</ul>
<p>优点</p>
<ul>
<li>提高对象使用效率。</li>
<li>减少垃圾回收压力。</li>
<li>灵活扩展，支持多种对象类型。</li>
</ul>
<p>注意事项</p>
<ul>
<li>池化对象需要线程安全的初始化和归还操作。</li>
<li>对象池的大小应根据实际场景进行合理配置，过小可能导致等待，过大会占用多余内存。</li>
</ul>
<h4 id="问：一致性-Hash-算法？其应用场景？"><a href="#问：一致性-Hash-算法？其应用场景？" class="headerlink" title="问：一致性 Hash 算法？其应用场景？"></a>问：一致性 Hash 算法？其应用场景？</h4><p>一致性 Hash 算法</p>
<p>一致性 Hash 是一种分布式哈希算法，常用于解决动态扩容、减少数据迁移等问题。该算法的核心思想是将 <strong>哈希值</strong> 空间组织成一个<strong>环形结构</strong>，数据和节点（例如缓存服务器）都通过哈希函数映射到这个环上。</p>
<p>核心思想</p>
<ol>
<li><p><strong>环形哈希空间</strong>： 哈希值范围设定为 [0,232−1][0, 2^{32}-1]，将其视为一个逻辑上的环形空间。</p>
</li>
<li><p><strong>节点映射</strong>： 每个节点（例如缓存服务器）通过哈希函数映射到环上的某个点。</p>
</li>
<li><p>数据映射</p>
<p>： 数据通过相同的哈希函数映射到环上的某个点。</p>
<ul>
<li>数据顺时针找到距离最近的节点存储。</li>
</ul>
</li>
<li><p>节点变动影响最小</p>
<p>：</p>
<ul>
<li><strong>新增节点</strong>：只需重新分配部分环上的数据到新节点。</li>
<li><strong>移除节点</strong>：只需将该节点的数据重新分配到其相邻节点。</li>
</ul>
</li>
</ol>
<p>算法步骤</p>
<ol>
<li><p>使用一个哈希函数 </p>
<p>hashhash</p>
<p>，将节点 </p>
<p>NN</p>
<p> 和数据 </p>
<p>KK</p>
<p> 映射到哈希环。</p>
<ul>
<li>节点位置：hash(N)hash(N)</li>
<li>数据位置：hash(K)hash(K)</li>
</ul>
</li>
<li><p>将数据存储到顺时针方向的第一个节点。</p>
</li>
<li><p>如果节点增删，仅受影响的部分数据需要重新分配，保证迁移量最小。</p>
</li>
</ol>
<p>虚拟节点</p>
<p>为了解决节点分布不均导致的负载不均问题，引入 <strong>虚拟节点</strong>：</p>
<ol>
<li>为每个实际节点生成多个虚拟节点，每个虚拟节点通过不同哈希值映射到环上。</li>
<li>数据仍按原始规则映射到虚拟节点，再对应到实际节点。</li>
</ol>
<p>应用场景</p>
<ol>
<li><p>分布式缓存</p>
<p>：</p>
<ul>
<li>常用于 Redis、Memcached 等场景，保证扩容或缩容时数据迁移量最小。</li>
</ul>
</li>
<li><p>分布式存储</p>
<p>：</p>
<ul>
<li>HDFS、Cassandra 等分布式存储系统用于减少数据分片在节点变动时的迁移。</li>
</ul>
</li>
<li><p>负载均衡</p>
<p>：</p>
<ul>
<li>动态调整后端服务器时，尽量保证流量均匀分布。</li>
</ul>
</li>
<li><p>分布式任务调度</p>
<p>：</p>
<ul>
<li>将任务动态分配到节点中，任务的节点调整时减少重调度任务数量。</li>
</ul>
</li>
</ol>
<p>优点</p>
<ol>
<li><strong>数据迁移量小</strong>： 只影响环上的一小部分数据。</li>
<li><strong>动态扩展性强</strong>： 支持节点动态增删，系统运行时无需停止。</li>
<li><strong>负载均衡</strong>： 配合虚拟节点，提升数据分布均匀性。</li>
</ol>
<p>缺点</p>
<ol>
<li><p>节点哈希分布不均</p>
<p>：</p>
<ul>
<li>实际节点少时，可能导致负载倾斜问题。</li>
<li>虚拟节点引入后需要增加计算量。</li>
</ul>
</li>
<li><p>复杂性</p>
<p>：</p>
<ul>
<li>初期设计复杂度较高。</li>
<li>对哈希函数性能要求高。</li>
</ul>
</li>
</ol>
<p>示例应用</p>
<p>分布式缓存场景</p>
<ol>
<li><p>系统中有三个缓存节点 N1,N2,N3N1, N2, N3，用户请求数据 K1,K2K1, K2。</p>
</li>
<li><p>使用一致性 Hash 算法将 </p>
<p>K1,K2K1, K2</p>
<p> 映射到环上：</p>
<ul>
<li>如果 hash(K1)hash(K1) 落在 N1N1 和 N2N2 之间，数据存储到 N2N2。</li>
</ul>
</li>
<li><p>节点增加</p>
<p>：</p>
<ul>
<li>新增节点 N4N4，仅需要将 N3N3 到 N4N4 之间的部分数据迁移。</li>
</ul>
</li>
<li><p>节点故障</p>
<p>：</p>
<ul>
<li>如果 N2N2 下线，迁移数据到其相邻节点 N3N3。</li>
</ul>
</li>
</ol>
<p>这种方式避免了传统取模算法因节点变化导致全量数据迁移的问题，提高了系统可扩展性和高效性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.SortedMap;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hash 环</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; circle = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 虚拟节点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> virtualNodeCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsistentHashing</span><span class="params">(<span class="keyword">int</span> virtualNodeCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.virtualNodeCount = virtualNodeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hash 函数（可以选择更好的哈希函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key.hashCode() &amp; <span class="number">0x7fffffff</span>; <span class="comment">// 转为正数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(String node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; virtualNodeCount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> hash = hash(node + <span class="string">&quot;#&quot;</span> + i); <span class="comment">// 为每个虚拟节点生成唯一哈希值</span></span><br><span class="line">            circle.put(hash, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(String node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; virtualNodeCount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> hash = hash(node + <span class="string">&quot;#&quot;</span> + i);</span><br><span class="line">            circle.remove(hash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找数据存储的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNode</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (circle.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="comment">// 找到第一个大于或等于该哈希值的节点</span></span><br><span class="line">        SortedMap&lt;Integer, String&gt; tailMap = circle.tailMap(hash);</span><br><span class="line">        <span class="keyword">int</span> nodeHash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();</span><br><span class="line">        <span class="keyword">return</span> circle.get(nodeHash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一致性哈希环，设置虚拟节点数量为 3</span></span><br><span class="line">        ConsistentHashing consistentHashing = <span class="keyword">new</span> ConsistentHashing(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加节点</span></span><br><span class="line">        consistentHashing.addNode(<span class="string">&quot;Node1&quot;</span>);</span><br><span class="line">        consistentHashing.addNode(<span class="string">&quot;Node2&quot;</span>);</span><br><span class="line">        consistentHashing.addNode(<span class="string">&quot;Node3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印数据分布</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Node for Key &#x27;Data1&#x27;: &quot;</span> + consistentHashing.getNode(<span class="string">&quot;Data1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Node for Key &#x27;Data2&#x27;: &quot;</span> + consistentHashing.getNode(<span class="string">&quot;Data2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Node for Key &#x27;Data3&#x27;: &quot;</span> + consistentHashing.getNode(<span class="string">&quot;Data3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加新节点</span></span><br><span class="line">        consistentHashing.addNode(<span class="string">&quot;Node4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;After adding Node4:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Node for Key &#x27;Data1&#x27;: &quot;</span> + consistentHashing.getNode(<span class="string">&quot;Data1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Node for Key &#x27;Data2&#x27;: &quot;</span> + consistentHashing.getNode(<span class="string">&quot;Data2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Node for Key &#x27;Data3&#x27;: &quot;</span> + consistentHashing.getNode(<span class="string">&quot;Data3&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码解析</p>
<ol>
<li><strong>Hash 环的实现</strong>：<ul>
<li>使用 <code>TreeMap</code> 来存储节点及其对应的哈希值，<code>TreeMap</code> 保证了键的自然顺序。</li>
<li>数据插入时间复杂度为 O(log⁡N)O(\log N)O(logN)，查找时间复杂度为 O(log⁡N)O(\log N)O(logN)。</li>
</ul>
</li>
<li><strong>虚拟节点</strong>：<ul>
<li>为每个实际节点生成多个虚拟节点，提升数据分布均匀性。</li>
<li>虚拟节点的数量可调，默认为 3（可以根据实际场景调整）。</li>
</ul>
</li>
<li><strong>节点查找</strong>：<ul>
<li>使用 <code>TreeMap.tailMap()</code> 找到顺时针方向第一个大于等于数据哈希值的节点。</li>
<li>如果未找到（哈希值超过最大值），回到环的起点。</li>
</ul>
</li>
<li><strong>动态扩容与缩容</strong>：<ul>
<li>动态添加或删除节点时，受影响的仅是部分数据，迁移量小。</li>
</ul>
</li>
</ol>
<p>时间复杂度</p>
<ul>
<li><strong>节点插入或删除</strong>：O(Mlog⁡N)O(M \log N)O(MlogN)，其中 MMM 是虚拟节点数量，NNN 是总节点数量。</li>
<li><strong>节点查找</strong>：O(log⁡N)O(\log N)O(logN)，依赖于 <code>TreeMap</code> 的查找效率。</li>
</ul>
<h4 id="问：TopK-问题？"><a href="#问：TopK-问题？" class="headerlink" title="问：TopK 问题？"></a>问：TopK 问题？</h4><p><strong>问题描述</strong>：给定一个包含 N 个元素的数组，找到其中最大的 K 个元素或最小的 K 个元素。</p>
<p>解决方案</p>
<ol>
<li><strong>排序法</strong><ul>
<li>对数组进行排序后，直接提取最大的 KK 个或最小的 KK 个元素。</li>
<li><strong>时间复杂度</strong>：O(Nlog⁡N)</li>
<li><strong>空间复杂度</strong>：O(1)（原地排序）</li>
</ul>
</li>
<li><strong>堆排序（推荐方法）</strong><ul>
<li>使用最小堆（找最大 K 个元素）或最大堆（找最小 K 个元素）。</li>
<li>维护一个大小为 K的堆：<ul>
<li>如果当前元素比堆顶大，则替换堆顶并重新调整堆。</li>
</ul>
</li>
<li><strong>时间复杂度</strong>：O(Nlog⁡K)<br>（堆的插入/删除操作的复杂度为 O(log⁡K)，需要操作 N 次）</li>
<li><strong>空间复杂度</strong>：O(K)</li>
</ul>
</li>
<li><strong>快速选择（QuickSelect）</strong><ul>
<li>改进的快速排序，利用分治思想，定位到第 K 大的元素位置，不需要对整个数组排序。</li>
<li><strong>时间复杂度</strong>：O(N)（平均）<br>O(N^2)（最坏情况，当划分极端不均匀时）</li>
<li><strong>空间复杂度</strong>：O(1)</li>
</ul>
</li>
<li><strong>计数排序（适用于整数范围较小的情况）</strong><ul>
<li>使用一个计数数组记录每个数字的出现次数。</li>
<li>统计后从大到小输出前 K 个数。</li>
<li><strong>时间复杂度</strong>：O(N + R)，R 是整数值的范围。</li>
<li><strong>空间复杂度</strong>：O(R)</li>
</ul>
</li>
</ol>
<p>Java 实现：堆排序法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKElements</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findTopK(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minHeap.size() &lt; k) &#123;</span><br><span class="line">                minHeap.offer(num); <span class="comment">// 直接加入堆</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; minHeap.peek()) &#123;</span><br><span class="line">                minHeap.poll(); <span class="comment">// 移除堆顶</span></span><br><span class="line">                minHeap.offer(num); <span class="comment">// 插入当前元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将堆中的元素输出到数组</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : minHeap) &#123;</span><br><span class="line">            result[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] topK = findTopK(nums, k);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Top &quot;</span> + k + <span class="string">&quot; elements:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : topK) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 实现：快速选择法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKQuickSelect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findTopK(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(nums, nums.length - k, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(nums, left, right);</span><br><span class="line">        <span class="keyword">if</span> (pivot == k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivot &lt; k) &#123;</span><br><span class="line">            quickSelect(nums, pivot + <span class="number">1</span>, right, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quickSelect(nums, left, pivot - <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                swap(nums, i++, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, right);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] topK = findTopK(nums, k);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Top &quot;</span> + k + <span class="string">&quot; elements:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : topK) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择合适方法的建议</p>
<ul>
<li>数据规模小：排序法。</li>
<li>数据规模大，KK 小：堆排序法。</li>
<li>数据无序，且只需一次结果：快速选择法。</li>
<li>数据范围较小：计数排序法。</li>
</ul>
<p>以上代码分别适用于不同场景，可根据实际需求选择合适的实现方式。</p>
<h4 id="问：试着实现一下LRU算法？"><a href="#问：试着实现一下LRU算法？" class="headerlink" title="问：试着实现一下LRU算法？"></a>问：试着实现一下LRU算法？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Main method to sort an array using heap sort</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build a max heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, n, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Extract elements from the heap one by one</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// Move the current root to the end</span></span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Call heapify on the reduced heap</span></span><br><span class="line">            heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To heapify a subtree rooted at index i</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = i; <span class="comment">// Initialize largest as root</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// Left child index</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// Right child index</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the left child is larger than the root</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the right child is larger than the largest so far</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the largest is not the root</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Recursively heapify the affected subtree</span></span><br><span class="line">            heapify(arr, n, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Utility method to swap two elements in an array</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method to test the sorting algorithm</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Original array: &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        heapSort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted array: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>时间复杂度和空间复杂度</p>
<ul>
<li><strong>时间复杂度</strong>:<ul>
<li><code>get</code>: O(1), 因为通过哈希表访问节点和移动节点到头部均为常数时间。</li>
<li><code>put</code>: O(1), 因为更新或添加节点涉及的操作（哈希表和链表）均为常数时间。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>:<ul>
<li>O(C), 其中 C 是缓存的容量，主要用于存储哈希表和链表节点。</li>
</ul>
</li>
</ul>
<h4 id="问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。"><a href="#问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。" class="headerlink" title="问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。"></a>问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。</h4><p>一开始以为这道题是道动态规划的题目，但是老想不出递推关系式。问了下是不是贪心的思路，面试官说是贪心，然后给了个例子以及一波暗示，我才终于发现其实每次都跳到加血的蘑菇位置就行了。然后赶紧写了波代码，就这样过去了</p>
<p>这道题可以通过动态规划解决，记录每个位置的最大剩余生命值，逐步推算至终点。以下是问题的分解和解法：</p>
<p>解题思路</p>
<ol>
<li><p><strong>定义状态</strong>:<br>用 <code>dp[i]</code> 表示到达位置 <code>i</code> 时的最大剩余生命值。如果位置 <code>i</code> 不可达，设为负无穷（<code>Integer.MIN_VALUE</code>）。</p>
</li>
<li><p><strong>状态转移方程</strong>:<br>从位置 <code>j</code> 跳到位置 <code>i</code> 的条件是 j+k=ij + k = ij+k=i 且 dp[j]−k&gt;0dp[j] - k &gt; 0dp[j]−k&gt;0。<br>如果满足，更新:</p>
<p>dp[i]=max⁡(dp[i],dp[j]−k+蘑菇值[i])dp[i] = \max(dp[i], dp[j] - k + \text{蘑菇值}[i])dp[i]=max(dp[i],dp[j]−k+蘑菇值[i])</p>
</li>
<li><p><strong>初始化</strong>:<br>dp[0]=ndp[0] = ndp[0]=n，表示初始生命值为 nnn。</p>
</li>
<li><p><strong>返回结果</strong>:</p>
<ul>
<li>如果可以到达终点，返回 dp[终点]dp[\text{终点}]dp[终点] 的值。</li>
<li>如果终点不可达，返回 -1。</li>
</ul>
</li>
<li><p><strong>优化方向</strong>:</p>
<ul>
<li>可以使用滑动窗口或队列优化来加速跨步检查的过程，避免暴力计算所有可能的跳跃。</li>
</ul>
</li>
</ol>
<p>Java 实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MushroomJump</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLifeRemaining</span><span class="params">(<span class="keyword">int</span>[] mushrooms, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = mushrooms.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Arrays.fill(dp, Integer.MIN_VALUE); <span class="comment">// 初始化为负无穷</span></span><br><span class="line">        dp[<span class="number">0</span>] = n; <span class="comment">// 初始位置生命值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历每个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; k++) &#123; <span class="comment">// 从 i-k 跳到 i</span></span><br><span class="line">                <span class="keyword">int</span> prevPos = i - k;</span><br><span class="line">                <span class="keyword">if</span> (prevPos &gt;= <span class="number">0</span> &amp;&amp; dp[prevPos] - k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[prevPos] - k + mushrooms[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查终点生命值</span></span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>] &gt; <span class="number">0</span> ? dp[length - <span class="number">1</span>] : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] mushrooms = &#123;<span class="number">0</span>, -<span class="number">2</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, -<span class="number">3</span>&#125;; <span class="comment">// 每个位置的蘑菇值</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>; <span class="comment">// 初始生命值</span></span><br><span class="line">        System.out.println(maxLifeRemaining(mushrooms, n)); <span class="comment">// 输出最大剩余生命值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度</p>
<ul>
<li><strong>时间复杂度</strong>:<br>O(N^2), 由于对于每个位置 iii，需要检查所有可能跳跃步数 k。</li>
<li><strong>空间复杂度</strong>:<br>O(N), 仅使用了一个长度为 N 的数组存储中间结果。</li>
</ul>
<p>优化（滑动窗口法）</p>
<p>在实际应用中，计算 dp[i] 的过程中，我们可以记录上一轮 dp[j]−k 的最大值，从而避免重复计算，时间复杂度可以优化到 O(N)。</p>
<p>这道题可以用贪心的思路来解决，但贪心和动态规划的核心不同：<strong>贪心是一种局部最优的策略，而动态规划通过综合考虑所有可能的选择来寻找全局最优解</strong>。</p>
<p>贪心思路</p>
<ol>
<li><strong>贪心策略</strong>:<br>在每个位置，我们尽量选择能够使剩余生命值最大的跳跃（即尽量多吃好蘑菇、少扣坏蘑菇）。<ul>
<li>在可跳跃的范围内 kkk，选择一个使得 剩余生命值−k+蘑菇值[i]\text{剩余生命值} - k + \text{蘑菇值}[i]剩余生命值−k+蘑菇值[i] 最大的位置 jjj 作为下一步。</li>
<li>如果当前生命值不足以跳到任何下一位置，则直接返回 -1。</li>
</ul>
</li>
<li><strong>实现过程</strong>:<ul>
<li>逐步跳跃，记录当前位置生命值。</li>
<li>每次计算可跳跃范围内的最优下一步，更新当前位置和生命值。</li>
<li>如果到达终点，返回最大剩余生命值；否则返回 -1。</li>
</ul>
</li>
<li><strong>贪心的局限</strong>:<ul>
<li>贪心不保证全局最优。例如，当某条路需要短期减少生命值但长期收益更高时，贪心可能无法识别这种路径。</li>
</ul>
</li>
</ol>
<p>贪心实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MushroomJumpGreedy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLifeRemainingGreedy</span><span class="params">(<span class="keyword">int</span>[] mushrooms, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = mushrooms.length;</span><br><span class="line">        <span class="keyword">int</span> currentLife = n;</span><br><span class="line">        <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (position &lt; length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxNextLife = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> nextPosition = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在当前可跳跃范围内选择最优下一步</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k + position &lt; length; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextPos = position + k;</span><br><span class="line">                <span class="keyword">int</span> nextLife = currentLife - k + mushrooms[nextPos];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nextLife &gt; <span class="number">0</span> &amp;&amp; nextLife &gt; maxNextLife) &#123;</span><br><span class="line">                    maxNextLife = nextLife;</span><br><span class="line">                    nextPosition = nextPos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 无法跳到任何位置</span></span><br><span class="line">            <span class="keyword">if</span> (nextPosition == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新当前位置和生命值</span></span><br><span class="line">            position = nextPosition;</span><br><span class="line">            currentLife = maxNextLife;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentLife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] mushrooms = &#123;<span class="number">0</span>, -<span class="number">2</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, -<span class="number">3</span>&#125;; <span class="comment">// 每个位置的蘑菇值</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>; <span class="comment">// 初始生命值</span></span><br><span class="line">        System.out.println(maxLifeRemainingGreedy(mushrooms, n)); <span class="comment">// 输出最大剩余生命值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贪心和动态规划的关系</p>
<ul>
<li><strong>动态规划的特点</strong>:<br>动态规划保存了所有可能路径的中间结果，并通过状态转移方程综合考虑，确保全局最优。</li>
<li><strong>贪心和动态规划的对比</strong>:<ul>
<li><strong>优点</strong>: 贪心的时间复杂度更低，通常是 O(N⋅K)O(N \cdot K)O(N⋅K) 或更优。</li>
<li><strong>缺点</strong>: 贪心容易漏掉某些可能更优的路径，因为它只考虑了当前最优，而动态规划则可以回溯之前的选择，寻找全局最优解。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>如果问题具有贪心选择性质（局部最优解可以导出全局最优解），贪心是理想选择。</li>
<li>如果问题需要对所有路径综合考虑（如复杂的生命值变化或路径选择问题），动态规划更可靠。</li>
</ul>
</li>
</ul>
<p>贪心在本题的适用性</p>
<p>本题中，贪心能够快速求解，并且在一些情况下可以得到较优解。但如果问题中路径间存在复杂的交叉影响（如短期损失换取长期收益），动态规划更具普适性。</p>
<h4 id="问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？"><a href="#问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？" class="headerlink" title="问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？"></a>问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？</h4><p>这道题包括两个问题：一次交易和多次交易的最大利润。两种问题分别可以用贪心和动态规划方法解决。</p>
<p>一次交易的最大利润</p>
<p>问题描述</p>
<p>给定一个数组表示股票价格，只能买入和卖出一次，求最大利润。</p>
<p>解题思路</p>
<p>只需找到股票价格的最低点和最高点，并保证最低点在最高点之前。<br> <strong>关键点</strong>：从左到右遍历，记录当前的最低价格，然后在每个价格点计算可能的最大利润。</p>
<p>实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockProfit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大利润，进行一次交易</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfitOneTransaction</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minPrice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="comment">// 更新最低价格</span></span><br><span class="line">            minPrice = Math.min(minPrice, price);</span><br><span class="line">            <span class="comment">// 计算当前利润，并更新最大利润</span></span><br><span class="line">            maxProfit = Math.max(maxProfit, price - minPrice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices = &#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Max profit with one transaction: &quot;</span> + maxProfitOneTransaction(prices)); <span class="comment">// 输出 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度</p>
<ul>
<li>时间复杂度：O(N)（只需一次遍历）</li>
<li>空间复杂度：O(1) （只使用常数空间）</li>
</ul>
<p>多次交易的最大利润</p>
<p>问题描述</p>
<p>可以进行多次交易（但不能同时持有多份股票，必须卖出后再买入），求最大利润。</p>
<p>解题思路</p>
<p>贪心算法：对于每次价格上升（今天的价格比昨天高），累加这段上涨的差值即可。<br> <strong>关键点</strong>：股票的每次有效上涨都视为一次交易。</p>
<p>实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockProfit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大利润，进行多次交易</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfitMultipleTransactions</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 累加每次上涨的差值</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                maxProfit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices = &#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Max profit with multiple transactions: &quot;</span> + maxProfitMultipleTransactions(prices)); <span class="comment">// 输出 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度</p>
<ul>
<li>时间复杂度：O(N) （一次遍历计算所有上涨区间）</li>
<li>空间复杂度：O(1) （只使用常数空间）</li>
</ul>
<p>总结</p>
<ol>
<li><strong>一次交易</strong>：<ul>
<li>策略：找到最低点和最高点。</li>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
</li>
<li><strong>多次交易</strong>：<ul>
<li>策略：累加所有上涨区间的利润。</li>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
</li>
</ol>
<h4 id="问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？"><a href="#问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？" class="headerlink" title="问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？"></a>问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？</h4><p>答：用字典树来做，省略100字。</p>
<p><strong>1. 判断新网址是否和已知网址重复（使用字典树）</strong></p>
<p>思路：</p>
<ul>
<li>构造一个字典树（Trie），以字符为节点存储所有已知的网址。</li>
<li>判断时，将新的 URL 逐字符遍历，沿字典树查找。如果最终可以完全匹配，则说明重复；否则，将其插入字典树。</li>
</ul>
<p>字典树的优势：</p>
<ul>
<li>能够有效判断字符串是否存在，并支持前缀匹配。</li>
</ul>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">256</span>]; <span class="comment">// 每个字符节点，支持ASCII码</span></span><br><span class="line">    <span class="keyword">boolean</span> isEnd = <span class="keyword">false</span>; <span class="comment">// 是否是URL的结尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlTrie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入URL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : url.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = ch; <span class="comment">// ASCII值作为索引</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在URL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : url.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = ch;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlChecker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UrlTrie trie = <span class="keyword">new</span> UrlTrie();</span><br><span class="line">        trie.insert(<span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;https://openai.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(trie.search(<span class="string">&quot;http://example.com&quot;</span>)); <span class="comment">// 输出 true</span></span><br><span class="line">        System.out.println(trie.search(<span class="string">&quot;http://google.com&quot;</span>)); <span class="comment">// 输出 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<ul>
<li>插入/查找：O(L)O(L)，LL 是 URL 的长度。</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>O(N×L)O(N \times L)，NN 是 URL 数量，LL 是 URL 的平均长度。</li>
</ul>
<p><strong>总结：</strong>字典树：</p>
<ul>
<li><strong>优点</strong>：支持前缀查询，适合需要前缀匹配的场景。</li>
<li><strong>缺点</strong>：空间占用大。</li>
<li><strong>复杂度</strong>：时间 O(L)O(L)，空间 O(N×L)O(N \times L)。</li>
</ul>
<h4 id="问：url很长，字典树很占空间怎么办？"><a href="#问：url很长，字典树很占空间怎么办？" class="headerlink" title="问：url很长，字典树很占空间怎么办？"></a>问：url很长，字典树很占空间怎么办？</h4><p>答：对url进行分段哈希，然后再放到树节点中，而不是直接把每一个字符作为一个树节点。</p>
<p><strong>2. 字典树占用空间优化（分段哈希）</strong></p>
<p>思路：</p>
<ul>
<li>对于 URL 较长的情况，使用分段哈希存储。</li>
<li>将 URL 分为固定长度的片段，每个片段计算哈希值，将哈希值存入哈希表，而非存储完整字符。</li>
</ul>
<p>优点：</p>
<ul>
<li>减少字典树节点数量，降低空间占用。</li>
<li>哈希值替代字符存储，相对高效。</li>
</ul>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Boolean&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEGMENT_LENGTH = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeHash</span><span class="params">(String segment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> segment.hashCode(); <span class="comment">// 使用 Java 默认的哈希函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入URL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; url.length(); i += SEGMENT_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = Math.min(i + SEGMENT_LENGTH, url.length());</span><br><span class="line">            String segment = url.substring(i, end);</span><br><span class="line">            hashMap.put(computeHash(segment), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在URL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; url.length(); i += SEGMENT_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = Math.min(i + SEGMENT_LENGTH, url.length());</span><br><span class="line">            String segment = url.substring(i, end);</span><br><span class="line">            <span class="keyword">if</span> (!hashMap.containsKey(computeHash(segment))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlChecker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SegmentHash hashChecker = <span class="keyword">new</span> SegmentHash();</span><br><span class="line">        hashChecker.insert(<span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line">        hashChecker.insert(<span class="string">&quot;https://openai.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hashChecker.search(<span class="string">&quot;http://example.com&quot;</span>)); <span class="comment">// 输出 true</span></span><br><span class="line">        System.out.println(hashChecker.search(<span class="string">&quot;http://google.com&quot;</span>)); <span class="comment">// 输出 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<ul>
<li>插入/查找：O(L/k)O(L / k)，kk 是分段长度。</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>O(N×L/k)O(N \times L / k)，降低了存储开销。</li>
</ul>
<p><strong>分段哈希</strong>：</p>
<ul>
<li><strong>优点</strong>：显著降低空间开销。</li>
<li><strong>缺点</strong>：实现相对复杂。</li>
<li><strong>复杂度</strong>：时间 O(L/k)，空间 O(N×L/k)。</li>
</ul>
<h4 id="问：你刚才提到了哈希，那说一下哈希的实现？"><a href="#问：你刚才提到了哈希，那说一下哈希的实现？" class="headerlink" title="问：你刚才提到了哈希，那说一下哈希的实现？"></a>问：你刚才提到了哈希，那说一下哈希的实现？</h4><p><strong>3. 使用哈希实现快速判断</strong></p>
<p>思路：</p>
<ul>
<li>将每个 URL 使用哈希函数计算出固定的哈希值，存入哈希表。</li>
<li>查找时直接查哈希表。</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：查找速度快，空间占用小。</li>
<li>缺点：可能存在哈希冲突，需要解决冲突问题。</li>
</ul>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlHashChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Integer&gt; urlHashes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入URL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        urlHashes.add(url.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在URL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> urlHashes.contains(url.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UrlHashChecker hashChecker = <span class="keyword">new</span> UrlHashChecker();</span><br><span class="line">        hashChecker.insert(<span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line">        hashChecker.insert(<span class="string">&quot;https://openai.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(hashChecker.search(<span class="string">&quot;http://example.com&quot;</span>)); <span class="comment">// 输出 true</span></span><br><span class="line">        System.out.println(hashChecker.search(<span class="string">&quot;http://google.com&quot;</span>)); <span class="comment">// 输出 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<ul>
<li>插入/查找：O(1)O(1)。</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>O(N)O(N)，存储每个 URL 的哈希值。</li>
</ul>
<p><strong>全哈希</strong>：</p>
<ul>
<li><strong>优点</strong>：查找速度最快，空间占用最小。</li>
<li><strong>缺点</strong>：不支持前缀匹配，可能有哈希冲突。</li>
<li><strong>复杂度</strong>：时间 O(1)O(1)，空间 O(N)O(N)。</li>
</ul>
<p>答：说了下STL里面unordered_map的大概实现原理，哈希函数，二次探测，开链，省略100字。</p>
<p>以下是关于 <code>HashMap</code> 和类似于 <code>unordered_map</code> 的实现原理及相关扩容、哈希机制的解释，针对 Java：</p>
<p><strong>1. Java 中 <code>HashMap</code> 的实现原理</strong></p>
<ul>
<li><p><strong>底层结构</strong>：<code>HashMap</code> 是基于哈希表实现的，内部使用一个数组，每个数组元素是一个链表（JDK 1.8 之前）或红黑树（JDK 1.8 及之后）。</p>
</li>
<li><p><strong>哈希函数</strong>：通过 <code>key.hashCode()</code> 计算键的哈希值，然后通过取模或按位操作计算数组索引： index=hashCode(key)&amp;(table.length−1)\text{index} = \text{hashCode(key)} &amp; (\text{table.length} - 1) 这里使用 <code>&amp;</code> 而非 <code>%</code> 提高效率。</p>
</li>
<li><p>冲突解决：使用 </p>
<p>开链法</p>
<p>（链表或红黑树）解决哈希冲突。</p>
<ul>
<li>JDK 1.8 引入了红黑树，当单个桶的链表长度超过 8 时，会转化为红黑树，提高查询效率。</li>
</ul>
</li>
</ul>
<p><strong>2. 扩容机制</strong></p>
<p><strong>扩容的触发条件</strong></p>
<ol>
<li><strong>负载因子（Load Factor）</strong>： load factor=元素个数 / 桶的数量。默认负载因子为 0.75。</li>
<li>当元素数量超过 (桶的数量×负载因子)时，触发扩容。</li>
</ol>
<p><strong>扩容的具体过程</strong></p>
<ol>
<li><strong>容量翻倍</strong>：将桶的数量扩容为原来的 2 倍。</li>
<li>重新哈希：<ul>
<li>因为桶数量变化，元素的索引会受到影响，需要重新分配每个元素的位置。</li>
<li>在 JDK 1.8 中，利用二进制特性优化了重新哈希的过程，判断是否需要移动到新的桶位置。</li>
</ul>
</li>
</ol>
<p><strong>为什么扩容倍数是 2？</strong></p>
<ol>
<li><strong>效率</strong>：哈希值按位与操作适合二进制结构，翻倍扩容仅需判断哈希值的高位。</li>
<li><strong>均匀分布</strong>：新的桶数量可以更均匀地分配元素。</li>
<li><strong>性能与内存的平衡</strong>：翻倍扩容在性能和内存浪费之间取得了较好的权衡。</li>
</ol>
<p><strong>3. 哈希冲突解决</strong></p>
<p><strong>开链法（Separate Chaining）</strong></p>
<ol>
<li>每个桶存储一个链表或红黑树。</li>
<li>如果多个键映射到同一个桶，通过链表（或树）的形式存储冲突的元素。</li>
<li>查询时需要遍历链表（或树）查找目标键。</li>
</ol>
<p><strong>红黑树</strong></p>
<ul>
<li>当单个桶的链表长度超过 8 时，链表转化为红黑树，时间复杂度由 O(n) 降低到 O(log⁡n)。</li>
</ul>
<p><strong>4. Java 哈希函数实现</strong></p>
<p>Java 默认使用对象的 <code>hashCode()</code> 方法生成哈希值，可以通过重写 <code>hashCode</code> 和 <code>equals</code> 方法自定义键的比较逻辑。</p>
<p><strong>5. 二次探测与开放地址法</strong></p>
<p>Java 的 <code>HashMap</code> 使用开链法解决冲突，未采用二次探测或开放地址法，因为：</p>
<ul>
<li>开链法在动态扩容时更高效。</li>
<li>开链法的分布均匀性和性能在大多数场景下优于开放地址法。</li>
</ul>
<p><strong>6. 示例代码：自定义简单的 HashMap</strong></p>
<p>以下是一个简单的 <code>HashMap</code> 实现示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Node&lt;K, V&gt;&gt;[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        Node(K key, V value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = <span class="keyword">new</span> LinkedList[INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(key);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K, V&gt; node : table[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.key.equals(key)) &#123;</span><br><span class="line">                node.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        table[index].add(<span class="keyword">new</span> Node&lt;&gt;(key, value));</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">float</span>) size / table.length &gt; LOAD_FACTOR) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(key);</span><br><span class="line">        <span class="keyword">if</span> (table[index] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K, V&gt; node : table[index]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.key.equals(key)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> node.value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key.hashCode() &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Node&lt;K, V&gt;&gt;[] oldTable = table;</span><br><span class="line">        table = <span class="keyword">new</span> LinkedList[table.length * <span class="number">2</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (LinkedList&lt;Node&lt;K, V&gt;&gt; bucket : oldTable) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K, V&gt; node : bucket) &#123;</span><br><span class="line">                    put(node.key, node.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> SimpleHashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;cherry&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;apple&quot;</span>));  <span class="comment">// Output: 1</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;banana&quot;</span>)); <span class="comment">// Output: 2</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;cherry&quot;</span>)); <span class="comment">// Output: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. 小结</strong></p>
<ul>
<li><code>HashMap</code> 是基于哈希表实现，使用开链法解决冲突。</li>
<li>扩容时桶数量翻倍，重新计算所有元素的哈希索引。</li>
<li>默认负载因子为 0.75，适合大多数场景。</li>
<li>哈希函数可以自定义，以提高冲突解决效率。</li>
</ul>
<h4 id="问：哈希在什么情况下需要扩容？怎么扩容？"><a href="#问：哈希在什么情况下需要扩容？怎么扩容？" class="headerlink" title="问：哈希在什么情况下需要扩容？怎么扩容？"></a>问：哈希在什么情况下需要扩容？怎么扩容？</h4><p>答：说了下饱和度过大时需要扩容，每次容量翻一倍。</p>
<h4 id="问：为什么扩容时是翻一倍呢？而不是两倍，三倍？"><a href="#问：为什么扩容时是翻一倍呢？而不是两倍，三倍？" class="headerlink" title="问：为什么扩容时是翻一倍呢？而不是两倍，三倍？"></a>问：为什么扩容时是翻一倍呢？而不是两倍，三倍？</h4><p>答：（这我就真不知道了😖，一顿乱猜）于是说了下STL内存分配器的特点以及里面内存池的结构可能更适合这样分配，才算糊弄过去😅。</p>
<h4 id="问：服务器中有大量数据需要迁移，如何在不停止对外服务的情况下安全的迁移数据？"><a href="#问：服务器中有大量数据需要迁移，如何在不停止对外服务的情况下安全的迁移数据？" class="headerlink" title="问：服务器中有大量数据需要迁移，如何在不停止对外服务的情况下安全的迁移数据？"></a>问：服务器中有大量数据需要迁移，如何在不停止对外服务的情况下安全的迁移数据？</h4><p>答：一开始没明白意思，说这个直接复制就行噻😃，</p>
<p>在不停止对外服务的情况下迁移大量数据是一项复杂的任务，需要考虑数据一致性、服务可用性、性能影响等问题。以下是一个通用的迁移方案：</p>
<p><strong>1. 问题分析</strong></p>
<ul>
<li><strong>数据一致性</strong>：迁移过程中，源和目标数据库可能出现数据不一致的问题。</li>
<li><strong>服务可用性</strong>：对外服务需要保持可用，迁移操作不能阻塞读写请求。</li>
<li><strong>性能影响</strong>：迁移操作可能对现有服务性能造成影响，需要最小化对生产环境的冲击。</li>
</ul>
<p><strong>2. 数据迁移的基本流程</strong></p>
<p><strong>阶段 1：准备阶段</strong></p>
<ol>
<li>评估数据量与系统性能：<ul>
<li>确定迁移数据的总量。</li>
<li>评估现有系统的负载能力，合理规划迁移速度。</li>
</ul>
</li>
<li>目标数据库初始化：<ul>
<li>在目标服务器上创建与源数据库相同的结构（表、索引、存储过程等）。</li>
</ul>
</li>
<li>工具选择：<ul>
<li>使用成熟的迁移工具，例如 <code>DataX</code>、<code>Canal</code>、<code>AWS DMS</code> 等。</li>
<li>或者开发自定义迁移脚本。</li>
</ul>
</li>
<li>日志与监控：<ul>
<li>设置迁移的日志记录和监控机制，跟踪迁移进度和错误。</li>
</ul>
</li>
</ol>
<p><strong>阶段 2：数据迁移阶段</strong></p>
<ol>
<li><p><strong>全量迁移</strong>：</p>
<ul>
<li><p>先进行一次数据的全量拷贝。</p>
</li>
<li><p>使用批量操作减少对服务的影响（例如分页批量处理，每次迁移一定数量的记录）。</p>
</li>
<li><p>示例代码（伪代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> batchSize = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>; ; offset += batchSize) &#123;</span><br><span class="line">    List&lt;Data&gt; batch = sourceDb.fetchData(offset, batchSize);</span><br><span class="line">    <span class="keyword">if</span> (batch.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">    targetDb.insertData(batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>增量同步</strong>：</p>
<ul>
<li>使用 <strong>CDC（Change Data Capture）</strong> 工具或机制捕获源数据库中的增量变化。</li>
<li>将新增、更新、删除操作实时同步到目标数据库。</li>
<li>常见工具：<ul>
<li><strong>Canal</strong>：解析 MySQL 的 binlog。</li>
<li><strong>Debezium</strong>：支持 MySQL、PostgreSQL 等多种数据库的增量数据捕获。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>阶段 3：切换与验证</strong></p>
<ol>
<li>灰度切换：<ul>
<li>部署一部分流量到目标数据库，验证其是否工作正常。</li>
<li>如果发现问题，可以回滚到源数据库。</li>
</ul>
</li>
<li>一致性校验：<ul>
<li>对比源数据库与目标数据库的数据一致性。</li>
<li>常见方法：<ul>
<li><strong>行数校验</strong>：检查记录总数是否一致。</li>
<li><strong>抽样校验</strong>：随机抽取数据并对比。</li>
<li><strong>全量校验</strong>：对比每条记录的内容（适合小数据集或离线校验）。</li>
</ul>
</li>
</ul>
</li>
<li>最终切换：<ul>
<li>将所有读写流量切换到目标数据库。</li>
<li>停止源数据库的写操作。</li>
</ul>
</li>
</ol>
<p><strong>3. 技术细节与优化</strong></p>
<ol>
<li>分批迁移：<ul>
<li>按主键范围或时间分片进行迁移，减少对单次查询的压力。</li>
</ul>
</li>
<li>流量限速：<ul>
<li>为迁移任务设置限速，防止占用过多资源影响线上服务。</li>
<li>示例：通过令牌桶算法控制迁移速率。</li>
</ul>
</li>
<li>数据校验工具：<ul>
<li>使用工具如 <code>DataDiff</code> 对数据一致性进行快速对比。</li>
</ul>
</li>
</ol>
<p><strong>4. 常见问题及应对</strong></p>
<ol>
<li>迁移过程中写操作频繁：<ul>
<li>使用双写机制：写操作同时写入源和目标数据库。</li>
<li>或者延迟迁移较活跃的表。</li>
</ul>
</li>
<li>迁移工具性能不足：<ul>
<li>通过并发批量迁移提高效率。</li>
</ul>
</li>
<li>目标数据库性能瓶颈：<ul>
<li>增加目标数据库的硬件资源。</li>
<li>暂时关闭目标数据库的非必要索引，提高写入速度。</li>
</ul>
</li>
</ol>
<p><strong>5. 总结</strong></p>
<ul>
<li><strong>全量迁移 + 增量同步</strong> 是数据迁移的标准流程。</li>
<li><strong>CDC 工具</strong> 是解决增量同步的关键，推荐使用成熟工具。</li>
<li>在迁移过程中，保持服务的可用性和数据的一致性是首要目标。</li>
<li>完整迁移流程需要严格验证，确保切换后业务无影响。</li>
</ul>
<h4 id="问：然后面试官提醒要是数据迁移的过程中数据被改动了怎么办？"><a href="#问：然后面试官提醒要是数据迁移的过程中数据被改动了怎么办？" class="headerlink" title="问：然后面试官提醒要是数据迁移的过程中数据被改动了怎么办？"></a>问：然后面试官提醒要是数据迁移的过程中数据被改动了怎么办？</h4><p>答：需要对数据加锁。</p>
<p>数据迁移过程中数据被改动是一个常见的风险，尤其是在需要保持服务可用的情况下。要解决这个问题，通常需要结合 <strong>增量同步</strong> 和 <strong>一致性校验</strong> 来确保数据迁移的正确性和完整性。以下是详细的应对方案：</p>
<p><strong>1. 问题分析</strong></p>
<p>在迁移过程中，数据被改动可能导致：</p>
<ul>
<li><strong>目标数据库与源数据库不一致</strong>。</li>
<li><strong>部分数据丢失或覆盖</strong>。</li>
<li><strong>切换后查询结果异常</strong>。</li>
</ul>
<p>可能的改动原因包括：</p>
<ul>
<li>数据在迁移过程中被更新、删除或新增。</li>
<li>并发写入导致迁移的部分数据过时。</li>
</ul>
<p><strong>2. 解决方案</strong></p>
<p>为了解决迁移过程中数据被改动的问题，可以采取以下措施：</p>
<p><strong>(1) 增量同步</strong></p>
<p>增量同步是保证数据一致性的关键步骤。</p>
<ul>
<li><p><strong>Change Data Capture（CDC）</strong>：</p>
<ul>
<li>捕获源数据库的实时变更（新增、修改、删除）。</li>
<li>通过工具（如 Canal、Debezium）解析数据库的变更日志（如 MySQL binlog）。</li>
<li>将变更同步到目标数据库，保证目标数据库实时更新。</li>
</ul>
<p>示例（使用 Canal 捕获增量变更）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo-code for capturing and applying changes</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    List&lt;ChangeLog&gt; changes = fetchChangeLogsFromSource();</span><br><span class="line">    applyChangesToTarget(changes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>双写机制</strong>：</p>
<ul>
<li>在迁移过程中，所有写操作同时写入源数据库和目标数据库。</li>
<li>缺点：增加了业务代码复杂性。</li>
</ul>
</li>
</ul>
<p><strong>(2) 数据校验</strong></p>
<p>在迁移完成后进行数据一致性校验，确保数据没有因改动产生差异。</p>
<ul>
<li><p><strong>行数校验</strong>：</p>
<ul>
<li><p>对比源和目标表的记录总数。</p>
</li>
<li><p>SQL 示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> source_table;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> target_table;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>内容校验</strong>：</p>
<ul>
<li><p>对比每条记录的字段内容，适合小数据量或分片抽样。</p>
</li>
<li><p>示例（基于主键范围的校验）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> source_table <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> target_table <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Hash 校验</strong>：</p>
<ul>
<li><p>为表生成全量或分片的哈希值，快速对比一致性。</p>
</li>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> MD5(GROUP_CONCAT(field1, field2)) <span class="keyword">FROM</span> source_table;</span><br><span class="line"><span class="keyword">SELECT</span> MD5(GROUP_CONCAT(field1, field2)) <span class="keyword">FROM</span> target_table;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>(3) 延迟切换</strong></p>
<p>延迟切换允许源和目标数据库同时工作一段时间，确保增量同步完成。</p>
<ul>
<li>在完成全量迁移后，源数据库仍接受写入，同时记录所有变更。</li>
<li>等到目标数据库的增量同步完全跟上后，再切换流量到目标数据库。</li>
</ul>
<p><strong>3. 防范改动的策略</strong></p>
<p><strong>(1) 数据库锁定</strong></p>
<p>在全量迁移时，为减少数据改动，考虑对源数据库加锁（仅限业务低峰时段）。</p>
<ul>
<li>缺点：锁定会影响业务写入操作，不适用于高可用场景。</li>
</ul>
<p><strong>(2) 分片迁移</strong></p>
<p>将数据按分片（如主键范围或时间）逐步迁移，避免长时间占用资源，同时减少因并发写入导致的改动。</p>
<ul>
<li>增量同步的压力也会降低。</li>
</ul>
<p><strong>(3) 增量补偿</strong></p>
<p>在迁移完成后，通过再次增量同步捕获遗漏的改动数据，确保最终一致性。</p>
<p><strong>4. 实现流程</strong></p>
<p>以下是结合增量同步和校验的完整迁移流程：</p>
<ol>
<li><strong>全量迁移</strong>：逐步迁移数据，并记录迁移时间点。</li>
<li><strong>增量捕获</strong>：通过 CDC 工具捕获从迁移时间点之后的数据改动。</li>
<li><strong>应用变更</strong>：将捕获的增量数据实时同步到目标数据库。</li>
<li><strong>一致性校验</strong>：对比源和目标数据库，确保无数据差异。</li>
<li><strong>切换流量</strong>：确认一致后，将业务流量切换到目标数据库。</li>
<li><strong>观察回滚</strong>：切换后继续监控一段时间，如果出现问题，可以快速切换回源数据库。</li>
</ol>
<p><strong>5. 总结</strong></p>
<p>迁移过程中数据改动的问题可以通过以下方式解决：</p>
<ul>
<li><strong>增量同步</strong>：通过 CDC 工具捕获和同步实时变更。</li>
<li><strong>双写机制</strong>：同时写入源和目标数据库，确保一致性。</li>
<li><strong>数据校验</strong>：迁移完成后，通过行数、内容或哈希值校验验证一致性。</li>
<li><strong>延迟切换</strong>：在源和目标数据库并行运行一段时间，确保所有数据完全同步。</li>
</ul>
<p>这种方案兼顾了服务可用性和数据一致性，适合生产环境中的无缝迁移需求。</p>
<h4 id="问：加锁了不就没法对外服务了吗？"><a href="#问：加锁了不就没法对外服务了吗？" class="headerlink" title="问：加锁了不就没法对外服务了吗？"></a>问：加锁了不就没法对外服务了吗？</h4><p>答：可以把数据分成许多段，复制某一段的时候就把这一段数据加锁。</p>
<h4 id="问：找出数组中只出现一次的那个数，其他都出现两次；-异或-接上面，如果数组中有两个数只出现一次呢？"><a href="#问：找出数组中只出现一次的那个数，其他都出现两次；-异或-接上面，如果数组中有两个数只出现一次呢？" class="headerlink" title="问：找出数组中只出现一次的那个数，其他都出现两次；(异或) 接上面，如果数组中有两个数只出现一次呢？"></a>问：找出数组中只出现一次的那个数，其他都出现两次；(异或) 接上面，如果数组中有两个数只出现一次呢？</h4><p>问题分析</p>
<p>这两个问题可以用 <strong>位运算</strong> 的技巧解决。异或运算的特性是：</p>
<ol>
<li>相同的数异或结果为 <code>0</code>。</li>
<li>任意数与 <code>0</code> 异或，结果为该数本身。</li>
<li>异或满足交换律和结合律。</li>
</ol>
<p><strong>第一问：数组中只有一个数出现一次，其他数都出现两次</strong></p>
<p><strong>思路</strong>:<br> 遍历数组，将所有元素进行异或运算，最终的结果就是只出现一次的那个数。因为成对出现的数会互相抵消。</p>
<p><strong>时间复杂度</strong>:</p>
<ul>
<li>时间复杂度：O(N) （遍历一次数组）</li>
<li>空间复杂度：O(1) （仅使用常量空间）</li>
</ul>
<p><strong>代码实现</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSingleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            result ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Single number: &quot;</span> + findSingleNumber(nums)); <span class="comment">// Output: 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二问：数组中有两个数只出现一次，其他数都出现两次</strong></p>
<p><strong>思路</strong>:</p>
<ol>
<li><p>如果数组中有两个只出现一次的数，则最终的异或结果为 <code>x ^ y</code>（x 和 y 是这两个数），其值不为 <code>0</code>。</p>
</li>
<li><p>找到 </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span><span class="regexp"> ^</span> y</span><br></pre></td></tr></table></figure>

<p> 结果中任意为 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p> 的位（例如最低位的 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>），通过这一位将数组分成两组：</p>
<ul>
<li>一组中，该位为 <code>1</code>。</li>
<li>另一组中，该位为 <code>0</code>。</li>
</ul>
</li>
<li><p>这样，两个只出现一次的数会分别落在两个组中，而每组中的其他数都会因为两两相同被抵消。</p>
</li>
<li><p>对每组分别异或即可得到结果。</p>
</li>
</ol>
<p><strong>时间复杂度</strong>:</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>代码实现</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumbers</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findTwoSingleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// Step 1: XOR all numbers to get x ^ y</span></span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            xor ^= num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2: Find the rightmost set bit in xor (bit where x and y differ)</span></span><br><span class="line">        <span class="keyword">int</span> diff = xor &amp; (-xor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3: Divide numbers into two groups and XOR separately</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; diff) == <span class="number">0</span>) &#123;</span><br><span class="line">                x ^= num; <span class="comment">// Group where the bit is 0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                y ^= num; <span class="comment">// Group where the bit is 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] result = findTwoSingleNumbers(nums);</span><br><span class="line">        System.out.println(<span class="string">&quot;Two single numbers: &quot;</span> + result[<span class="number">0</span>] + <span class="string">&quot; and &quot;</span> + result[<span class="number">1</span>]); <span class="comment">// Output: 4 and 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ol>
<li><strong>单个数出现一次</strong>: 使用异或直接找出。</li>
<li><strong>两个数出现一次</strong>: 使用异或将问题分组后分别找出。</li>
</ol>
<p>这两种方法都充分利用了异或运算的特性，具有线性时间复杂度和常量空间复杂度，适合处理大数据量的场景。</p>
<h4 id="问：BST中任意两个节点差的最小值"><a href="#问：BST中任意两个节点差的最小值" class="headerlink" title="问：BST中任意两个节点差的最小值"></a>问：BST中任意两个节点差的最小值</h4><p>问题分析</p>
<p>在二叉搜索树（BST）中，任意两个节点的差最小值实际上是两个相邻节点的差值最小。因为 BST 的中序遍历是有序的，所以可以通过中序遍历得到所有节点值的有序数组，再计算相邻节点的差值即可。</p>
<p><strong>算法思路</strong></p>
<ol>
<li><strong>中序遍历</strong>: 利用 BST 的性质，通过中序遍历得到有序的节点值。</li>
<li><strong>计算最小差值</strong>: 遍历有序数组，计算每两个相邻节点值的差，记录最小值。</li>
</ol>
<p><strong>时间和空间复杂度</strong></p>
<ul>
<li><strong>时间复杂度</strong>: O(N)，其中 NN 是节点数，因为需要遍历一次树。</li>
<li><strong>空间复杂度</strong>: O(H)，其中 HH 是树的高度，用于递归栈或存储中序遍历的结果。如果递归实现中序遍历，栈空间与树高度成正比。</li>
</ul>
<p>方法 1：中序遍历存储所有节点值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDiffInBST</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Step 1: In-order traversal to get sorted values</span></span><br><span class="line">        inOrder(root, values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2: Find minimum difference between adjacent values</span></span><br><span class="line">        <span class="keyword">int</span> minDiff = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">            minDiff = Math.min(minDiff, values.get(i) - values.get(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node, List&lt;Integer&gt; values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(node.left, values);</span><br><span class="line">        values.add(node.val);</span><br><span class="line">        inOrder(node.right, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Minimum Difference: &quot;</span> + minDiffInBST(root)); <span class="comment">// Output: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 2：中序遍历时即时计算最小差值（无需存储数组）</p>
<p>通过中序遍历的过程中直接比较当前节点与前一个节点的值，更新最小差值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDiffInBSTOptimized</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> minDiff = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        prev = <span class="keyword">null</span>; <span class="comment">// Reset the previous node</span></span><br><span class="line">        minDiff = Integer.MAX_VALUE; <span class="comment">// Reset the minimum difference</span></span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Traverse left subtree</span></span><br><span class="line">        inOrder(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process current node</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minDiff = Math.min(minDiff, node.val - prev);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Traverse right subtree</span></span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Minimum Difference: &quot;</span> + minDiffInBST(root)); <span class="comment">// Output: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>比较两种方法</strong></p>
<ol>
<li><strong>方法 1</strong>:<ul>
<li>中序遍历存储所有节点值。</li>
<li>优点：实现简单，清晰易懂。</li>
<li>缺点：需要额外空间存储节点值。</li>
</ul>
</li>
<li><strong>方法 2</strong>:<ul>
<li>中序遍历时直接计算，节省空间。</li>
<li>优点：空间复杂度低，仅用常量空间存储 <code>prev</code> 和 <code>minDiff</code>。</li>
</ul>
</li>
</ol>
<p>在空间受限的情况下，推荐 <strong>方法 2</strong>。</p>
<h4 id="问：判断二叉树是否中心对称"><a href="#问：判断二叉树是否中心对称" class="headerlink" title="问：判断二叉树是否中心对称"></a>问：判断二叉树是否中心对称</h4><p><strong>问题分析</strong></p>
<p>判断一棵二叉树是否中心对称，即从根节点向左和向右展开的子树在结构和节点值上对称。</p>
<p><strong>算法思路</strong></p>
<ol>
<li><strong>递归方法</strong>:<ul>
<li>如果根节点为空，树是对称的。</li>
<li>如果只有一个子树为空或者两个子树的值不同，树不对称。</li>
<li>递归比较左子树的左子树与右子树的右子树、左子树的右子树与右子树的左子树。</li>
<li>时间复杂度 O(N)O(N)，空间复杂度 O(H)O(H)（递归栈高度）。</li>
</ul>
</li>
<li><strong>迭代方法</strong>:<ul>
<li>使用队列保存成对的节点。</li>
<li>每次从队列取出两两节点比较，若不同则不对称。</li>
<li>时间复杂度 O(N)O(N)，空间复杂度 O(N)O(N)。</li>
</ul>
</li>
</ol>
<p><strong>方法 1：递归实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (t1.val == t2.val) </span><br><span class="line">                &amp;&amp; isMirror(t1.left, t2.right) </span><br><span class="line">                &amp;&amp; isMirror(t1.right, t2.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Is symmetric: &quot;</span> + isSymmetric(root)); <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法 2：迭代实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricTreeIterative</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root.left);</span><br><span class="line">        queue.add(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode t1 = queue.poll();</span><br><span class="line">            TreeNode t2 = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span> || t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            queue.add(t1.left);</span><br><span class="line">            queue.add(t2.right);</span><br><span class="line">            queue.add(t1.right);</span><br><span class="line">            queue.add(t2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Is symmetric: &quot;</span> + isSymmetric(root)); <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><strong>递归方法</strong></p>
<ul>
<li><strong>时间复杂度</strong>: O(N)O(N)，需要访问所有节点。</li>
<li><strong>空间复杂度</strong>: O(H)O(H)，递归栈的高度，最坏情况下 H=NH = N（链式树）。</li>
</ul>
<p><strong>迭代方法</strong></p>
<ul>
<li><strong>时间复杂度</strong>: O(N)O(N)，需要访问所有节点。</li>
<li><strong>空间复杂度</strong>: O(N)O(N)，队列最多保存 N/2N/2 个节点。</li>
</ul>
<p><strong>测试用例</strong></p>
<ol>
<li>空树：<code>root = null</code>，输出 <code>true</code>。</li>
<li>单节点树：<code>root = [1]</code>，输出 <code>true</code>。</li>
<li>对称树：<code>root = [1, 2, 2, 3, 4, 4, 3]</code>，输出 <code>true</code>。</li>
<li>非对称树：<code>root = [1, 2, 2, null, 3, null, 3]</code>，输出 <code>false</code>。</li>
</ol>
<p>两种方法都可以正确判断二叉树是否对称，选择哪种方法视具体需求和限制而定。</p>
<h4 id="问：大数相乘"><a href="#问：大数相乘" class="headerlink" title="问：大数相乘"></a>问：大数相乘</h4><p><strong>问题分析</strong></p>
<p>大数相乘指的是当两个数字非常大（超出语言的原生整数范围）时，需要用字符串或数组来模拟实现乘法运算。</p>
<p><strong>算法思路</strong></p>
<p><strong>基本思路</strong></p>
<ol>
<li><strong>倒序处理</strong>: 将两个数字从低位到高位逐位相乘。</li>
<li><strong>按位累加</strong>: 模拟竖式乘法，将每次的结果累加到对应的位置。</li>
<li><strong>进位处理</strong>: 如果某位的值超过 10，则进位到下一位。</li>
</ol>
<p><strong>步骤</strong></p>
<ol>
<li>将两个大数字符串反转，方便从低位开始逐位相乘。</li>
<li>使用一个数组保存每个位的乘积结果。</li>
<li>遍历两个数字的每一位，计算乘积并存储到结果数组中对应的位置。</li>
<li>对数组进行进位处理。</li>
<li>将结果数组转为字符串并去掉前导零。</li>
</ol>
<p><strong>Java 实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigNumberMultiply</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = num1.length(), m = num2.length();</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + m]; <span class="comment">// 保存乘积结果的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从低位到高位逐位相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> mul = (num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>) * (num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">int</span> sum = mul + result[i + j + <span class="number">1</span>]; <span class="comment">// 当前乘积加上已有值</span></span><br><span class="line"></span><br><span class="line">                result[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>; <span class="comment">// 保存当前位</span></span><br><span class="line">                result[i + j] += sum / <span class="number">10</span>;   <span class="comment">// 处理进位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果数组转为字符串</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : result) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(sb.length() == <span class="number">0</span> &amp;&amp; num == <span class="number">0</span>)) &#123; <span class="comment">// 去掉前导零</span></span><br><span class="line">                sb.append(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String num1 = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">        String num2 = <span class="string">&quot;987654321&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Product: &quot;</span> + multiply(num1, num2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><strong>时间复杂度</strong></p>
<ul>
<li>内层嵌套循环需要遍历 O(N×M)O(N \times M)，其中 NN 和 MM 分别为两个数字的长度。</li>
</ul>
<p><strong>空间复杂度</strong></p>
<ul>
<li>结果数组需要 O(N+M)O(N + M) 的空间来存储中间结果。</li>
</ul>
<p><strong>测试用例</strong></p>
<p>输入</p>
<ol>
<li>num1=”123”,num2=”456”num1 = “123”, num2 = “456”</li>
<li>num1=”0”,num2=”12345”num1 = “0”, num2 = “12345”</li>
<li>num1=”999999”,num2=”999999”num1 = “999999”, num2 = “999999”</li>
</ol>
<p>输出</p>
<ol>
<li>输出：<code>&quot;56088&quot;</code></li>
<li>输出：<code>&quot;0&quot;</code></li>
<li>输出：<code>&quot;999998000001&quot;</code></li>
</ol>
<p><strong>扩展</strong></p>
<p>可以进一步优化：</p>
<ol>
<li><strong>高效字符串处理</strong>: 在字符串拼接时减少不必要的操作。</li>
<li><strong>FFT 优化</strong>: 使用快速傅里叶变换（FFT）处理非常长的大数乘法。</li>
</ol>
<p>这个实现适用于一般大数场景，高效且易读。</p>
<h4 id="问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路"><a href="#问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路" class="headerlink" title="问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路"></a>问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路</h4><p><strong>问题分析</strong></p>
<p><strong>输入</strong></p>
<ol>
<li>一个 M×NM \times N 的矩阵，表示一个九方格或更大的矩阵。</li>
<li>打印顺序从左上角的数字 11 开始，按照 <strong>逆时针方向</strong>。</li>
</ol>
<p><strong>输出</strong></p>
<ul>
<li>打印按逆时针顺序排列的矩阵元素。</li>
</ul>
<p><strong>逆时针遍历的思路</strong></p>
<ol>
<li><p>层级遍历</p>
<p>：</p>
<ul>
<li>矩阵可看作由若干层组成，每层是矩阵的外圈。</li>
<li>每遍历一层，就收缩矩阵的边界。</li>
</ul>
</li>
<li><p>访问顺序</p>
<p>：</p>
<ul>
<li>每一层按逆时针顺序依次访问：<strong>左 -&gt; 下 -&gt; 右 -&gt; 上</strong>。</li>
</ul>
</li>
<li><p>控制边界</p>
<p>：</p>
<ul>
<li>使用四个变量 <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code> 来表示当前未遍历的边界。</li>
<li>每遍历一圈后，更新这些变量。</li>
</ul>
</li>
</ol>
<p><strong>实现步骤</strong></p>
<ol>
<li>初始化边界：<code>top = 0, bottom = M-1, left = 0, right = N-1</code>。</li>
<li>循环遍历：<ul>
<li>从 <code>top</code> 到 <code>bottom</code> 打印左侧边界；</li>
<li>从 <code>left</code> 到 <code>right</code> 打印底部边界；</li>
<li>从 <code>bottom</code> 到 <code>top</code> 打印右侧边界；</li>
<li>从 <code>right</code> 到 <code>left</code> 打印顶部边界。</li>
</ul>
</li>
<li>在每次遍历后，缩小矩阵的边界，直到所有元素被打印。</li>
</ol>
<p><strong>时间复杂度</strong></p>
<ul>
<li>每个元素只访问一次，因此时间复杂度为 O(M×N)O(M \times N)。</li>
</ul>
<p><strong>空间复杂度</strong></p>
<ul>
<li>只需要常量空间存储边界和索引变量，空间复杂度为 O(1)O(1)。</li>
</ul>
<hr>
<p>接下来可以用 Java 来实现这个算法，确保效率与正确性。是否直接提供代码？</p>
<h4 id="问：数组A，2-n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路"><a href="#问：数组A，2-n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路" class="headerlink" title="问：数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路"></a>问：数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路</h4><p><strong>问题分析</strong></p>
<p>输入</p>
<ul>
<li><p>一个数组 </p>
<p>AA</p>
<p>，包含 </p>
<p>2n2n</p>
<p> 个整数，其中：</p>
<ul>
<li>nn 个奇数</li>
<li>nn 个偶数</li>
</ul>
</li>
</ul>
<p>输出</p>
<ul>
<li>数组重新排列后满足：<ul>
<li><strong>奇数下标（0, 2, 4, …）</strong>的位置都放奇数；</li>
<li><strong>偶数下标（1, 3, 5, …）</strong>的位置都放偶数。</li>
</ul>
</li>
</ul>
<p><strong>思路分析</strong></p>
<ol>
<li>数组中奇数和偶数的数量相等，最终必然有奇数放在奇数下标，偶数放在偶数下标。</li>
<li>只需要检查每个位置的元素是否符合规则，不符合则交换即可。</li>
</ol>
<p><strong>详细步骤</strong></p>
<ol>
<li><p>定义两个指针</p>
<p>：</p>
<ul>
<li><code>oddIndex</code>: 指向当前不正确放置奇数的位置（从下标 0 开始）。</li>
<li><code>evenIndex</code>: 指向当前不正确放置偶数的位置（从下标 1 开始）。</li>
</ul>
</li>
<li><p>遍历数组</p>
<p>：</p>
<ul>
<li><p>遍历数组中的所有元素：</p>
<ul>
<li><p>如果 </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">oddIndex</span></span><br></pre></td></tr></table></figure>

<p> 指向的不是奇数：</p>
<ul>
<li>找到最近的偶数索引 <code>evenIndex</code>，并交换两者；</li>
<li>更新 <code>oddIndex</code> 和 <code>evenIndex</code>。</li>
</ul>
</li>
<li><p>如果 </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">evenIndex</span></span><br></pre></td></tr></table></figure>

<p> 指向的不是偶数：</p>
<ul>
<li>找到最近的奇数索引 <code>oddIndex</code>，并交换两者；</li>
<li>更新 <code>evenIndex</code> 和 <code>oddIndex</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>完成遍历</p>
<p>：</p>
<ul>
<li>当所有索引都符合条件时，数组已排列完成。</li>
</ul>
</li>
</ol>
<p><strong>时间复杂度</strong></p>
<ul>
<li><strong>遍历数组</strong>：每个元素访问一次 O(2n)=O(n)O(2n) = O(n)。</li>
<li><strong>交换操作</strong>：交换的次数最多是数组的一半 O(n/2)=O(n)O(n/2) = O(n)。</li>
</ul>
<p>总时间复杂度：O(n)O(n)</p>
<p><strong>空间复杂度</strong></p>
<ul>
<li>只需要常量空间存储两个指针，空间复杂度为 O(1)O(1)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayRearrange</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rearrangeArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length / <span class="number">2</span>; <span class="comment">// 假设数组长度为 2n</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> oddIndex = <span class="number">0</span>;  <span class="comment">// 奇数下标位置</span></span><br><span class="line">        <span class="keyword">int</span> evenIndex = <span class="number">1</span>; <span class="comment">// 偶数下标位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (oddIndex &lt; arr.length &amp;&amp; evenIndex &lt; arr.length) &#123;</span><br><span class="line">            <span class="comment">// 找到一个不符合规则的奇数位置</span></span><br><span class="line">            <span class="keyword">while</span> (oddIndex &lt; arr.length &amp;&amp; arr[oddIndex] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                oddIndex += <span class="number">2</span>; <span class="comment">// 跳过已经放置好的奇数</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 找到一个不符合规则的偶数位置</span></span><br><span class="line">            <span class="keyword">while</span> (evenIndex &lt; arr.length &amp;&amp; arr[evenIndex] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                evenIndex += <span class="number">2</span>; <span class="comment">// 跳过已经放置好的偶数</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果奇数位置的元素是偶数，偶数位置的元素是奇数</span></span><br><span class="line">            <span class="comment">// 则交换两者</span></span><br><span class="line">            <span class="keyword">if</span> (oddIndex &lt; arr.length &amp;&amp; evenIndex &lt; arr.length) &#123;</span><br><span class="line">                <span class="comment">// 交换奇数和偶数</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[oddIndex];</span><br><span class="line">                arr[oddIndex] = arr[evenIndex];</span><br><span class="line">                arr[evenIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Original Array:&quot;</span>);</span><br><span class="line">        printArray(arr);</span><br><span class="line">        </span><br><span class="line">        rearrangeArray(arr);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Rearranged Array:&quot;</span>);</span><br><span class="line">        printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>代码说明</strong></p>
<ol>
<li><strong><code>rearrangeArray(int[] arr)</code></strong>:<ul>
<li>通过两个指针 <code>oddIndex</code> 和 <code>evenIndex</code> 来遍历数组，并确保奇数位放置奇数，偶数位放置偶数。</li>
<li><code>oddIndex</code> 指针用于查找奇数应该放置的位置，<code>evenIndex</code> 指针用于查找偶数应该放置的位置。</li>
<li>如果两个指针指向的位置不符合要求，则交换这两个位置的元素。</li>
</ul>
</li>
<li><strong><code>printArray(int[] arr)</code></strong>:<ul>
<li>打印数组的内容，便于调试和查看输出结果。</li>
</ul>
</li>
<li><strong><code>main</code></strong>:<ul>
<li>初始化了一个数组，并调用 <code>rearrangeArray</code> 方法进行重新排列，最后打印出排列后的数组。</li>
</ul>
</li>
</ol>
<p><strong>示例输入输出</strong></p>
<p>输入：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">javascriptCopy</span> codeOriginal Array:</span><br><span class="line"><span class="attribute">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> </span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">javascriptCopy</span> codeRearranged Array:</span><br><span class="line"><span class="attribute">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong></p>
<ul>
<li><strong>时间复杂度</strong>：O(n)O(n)O(n)，我们只遍历数组一次，对每个元素做交换。</li>
<li><strong>空间复杂度</strong>：O(1)O(1)O(1)，仅用了常量空间。</li>
</ul>
<p>如果有其他问题或需要进一步优化，欢迎随时提问！</p>
<h4 id="问：统计一个字符串的字符出现字数并打印-除了这个还有别的办法吗？"><a href="#问：统计一个字符串的字符出现字数并打印-除了这个还有别的办法吗？" class="headerlink" title="问：统计一个字符串的字符出现字数并打印?除了这个还有别的办法吗？"></a>问：统计一个字符串的字符出现字数并打印?除了这个还有别的办法吗？</h4><p>要统计一个字符串中每个字符出现的次数，并打印出来，最常用的方法是使用哈希表（例如 <code>HashMap</code>）。这种方法可以以 O(n)O(n) 的时间复杂度完成任务，其中 nn 是字符串的长度。</p>
<p>方法 1：使用 <code>HashMap</code> 实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterFrequency</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countCharacterFrequency</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 HashMap 统计每个字符的频率</span></span><br><span class="line">        Map&lt;Character, Integer&gt; frequencyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历字符串，统计每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            frequencyMap.put(c, frequencyMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : frequencyMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;aabccba&quot;</span>;</span><br><span class="line">        countCharacterFrequency(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>: <span class="number">3</span></span><br><span class="line"><span class="attribute">b</span>: <span class="number">2</span></span><br><span class="line"><span class="attribute">c</span>: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)O(n)，其中 nn 是字符串的长度。我们只需要遍历一次字符串。</li>
<li><strong>空间复杂度</strong>：O(k)O(k)，其中 kk 是字符串中不同字符的数量。如果是英文字母，最多为 26 或 256（ASCII 字符集）。</li>
</ul>
<p>另外的实现方式：</p>
<p>方法 2：使用数组计数（适用于固定字符集）</p>
<p>如果我们知道字符串只包含特定字符集（如小写字母或 ASCII 字符），可以使用数组代替 <code>HashMap</code> 来减少空间复杂度。比如，如果字符串只包含小写字母，则可以使用大小为 26 的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterFrequency</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countCharacterFrequency</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设字符串只包含小写字母</span></span><br><span class="line">        <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历字符串，统计每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            frequency[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frequency.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frequency[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) (i + <span class="string">&#x27;a&#x27;</span>) + <span class="string">&quot;: &quot;</span> + frequency[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;aabccba&quot;</span>;</span><br><span class="line">        countCharacterFrequency(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>: <span class="number">3</span></span><br><span class="line"><span class="attribute">b</span>: <span class="number">2</span></span><br><span class="line"><span class="attribute">c</span>: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)O(n)，遍历字符串一次。</li>
<li><strong>空间复杂度</strong>：O(1)O(1)，这里我们使用一个固定大小的数组来统计字符频率（大小为 26，因为只考虑小写字母）。</li>
</ul>
<p>方法 3：排序 + 扫描</p>
<p>如果字符串不大且不要求频繁操作，也可以先将字符串排序，然后扫描字符串并统计相同字符的个数。这种方法的时间复杂度较高，因为排序的时间复杂度是 O(nlog⁡n)O(n \log n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterFrequency</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countCharacterFrequency</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组并排序</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        Arrays.sort(charArray);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 扫描字符数组，统计频率</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charArray[i] == charArray[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(charArray[i - <span class="number">1</span>] + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印最后一个字符的频率</span></span><br><span class="line">        System.out.println(charArray[charArray.length - <span class="number">1</span>] + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;aabccba&quot;</span>;</span><br><span class="line">        countCharacterFrequency(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>: <span class="number">3</span></span><br><span class="line"><span class="attribute">b</span>: <span class="number">2</span></span><br><span class="line"><span class="attribute">c</span>: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(nlog⁡n)O(n \log n)，排序的时间复杂度为 O(nlog⁡n)O(n \log n)，然后扫描字符串的时间复杂度是 O(n)O(n)。</li>
<li><strong>空间复杂度</strong>：O(n)O(n)，需要存储字符数组。</li>
</ul>
<p>总结：</p>
<ol>
<li><strong><code>HashMap</code></strong> 方法是最常见且高效的，适用于通用情况，可以处理任意字符集。</li>
<li><strong>数组计数</strong> 方法适用于已知字符集（例如只包含小写字母），它是最节省空间的方法。</li>
<li><strong>排序 + 扫描</strong> 方法适用于简单场景，但它的时间复杂度较高。</li>
</ol>
<p>选择哪种方法取决于字符串的大小、字符集的限制以及是否需要频繁更新。</p>
<h4 id="问：全排列？"><a href="#问：全排列？" class="headerlink" title="问：全排列？"></a>问：全排列？</h4><p>全排列问题通常是指给定一个数组或字符串，要求输出该数组或字符串的所有可能的排列方式。全排列是经典的回溯问题。</p>
<ol>
<li><strong>全排列的基本思路</strong>：</li>
</ol>
<ul>
<li><strong>回溯算法</strong>：通过交换数组中的元素，生成不同的排列。每次固定一个元素后递归地生成子排列，直到生成所有可能的排列。</li>
<li><strong>去重</strong>：如果输入的数组或字符串中有重复元素，需要避免重复排列的生成。</li>
</ul>
<ol start="2">
<li><strong>问题分析</strong>：</li>
</ol>
<ul>
<li>假设我们有一个数组或字符串 <code>arr</code>，其长度为 <code>n</code>，那么全排列的总数是 <code>n!</code>（n的阶乘）。</li>
<li>通过回溯法可以遍历所有可能的排列，递归地构建每个排列。</li>
</ul>
<ol start="3">
<li><strong>代码实现</strong>（Java）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全排列算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]; <span class="comment">// 标记哪些元素已经使用</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回溯算法</span></span><br><span class="line">        backtrack(nums, used, current, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current.size() == nums.length) &#123;  <span class="comment">// 如果当前排列已经包含所有元素</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(current)); <span class="comment">// 添加到结果中</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>; <span class="comment">// 如果元素已被使用过，跳过</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 标记该元素为已使用</span></span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            current.add(nums[i]); <span class="comment">// 选择该元素</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归构建下一个元素</span></span><br><span class="line">            backtrack(nums, used, current, result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯，撤销选择</span></span><br><span class="line">            current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = permute(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; perm : result) &#123;</span><br><span class="line">            System.out.println(perm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li><strong><code>backtrack</code></strong> 函数：递归地生成所有的排列。每次从未使用过的元素中选择一个，并递归地生成剩下的排列，直到构建出完整的排列。</li>
<li><strong><code>used</code></strong> 数组：用于标记某个元素是否已经出现在当前的排列中，避免重复使用同一个元素。</li>
<li><strong><code>current</code></strong> 列表：用于存储当前的排列。</li>
<li><strong><code>result</code></strong> 列表：用于存储所有的排列。</li>
</ul>
<ol start="4">
<li><strong>时间复杂度</strong>：</li>
</ol>
<ul>
<li><strong>时间复杂度</strong>：O(n!)O(n!)，因为我们需要生成所有可能的排列，其中 <code>n!</code> 是排列的总数。对于每个排列，我们可能会进行 O(n)O(n) 的操作（复制排列）。</li>
<li><strong>空间复杂度</strong>：O(n)O(n)，用于存储当前排列的空间，递归调用栈的空间。</li>
</ul>
<ol start="5">
<li><strong>去重的情况（对于重复元素的全排列）</strong>：</li>
</ol>
<p>如果输入的数组中包含重复的元素，需要去重，避免重复的排列被加入结果。可以在回溯时通过排序数组，并在递归中加上去重条件来避免重复排列。</p>
<p>代码改进：加入去重逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全排列算法（考虑重复元素去重）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]; <span class="comment">// 标记哪些元素已经使用</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排序是为了方便去重</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回溯算法</span></span><br><span class="line">        backtrack(nums, used, current, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯函数（考虑重复元素去重）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current.size() == nums.length) &#123;  <span class="comment">// 如果当前排列已经包含所有元素</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(current)); <span class="comment">// 添加到结果中</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>; <span class="comment">// 如果元素已被使用过，跳过</span></span><br><span class="line">            <span class="comment">// 如果当前元素和前一个元素相同，并且前一个元素未被使用，则跳过（避免重复排列）</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记该元素为已使用</span></span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            current.add(nums[i]); <span class="comment">// 选择该元素</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归构建下一个元素</span></span><br><span class="line">            backtrack(nums, used, current, result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯，撤销选择</span></span><br><span class="line">            current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = permuteUnique(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; perm : result) &#123;</span><br><span class="line">            System.out.println(perm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>（去重）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：仍为 O(n!)O(n!)，但是我们通过去重来减少了重复排列的生成，避免了不必要的递归调用。</li>
<li><strong>空间复杂度</strong>：O(n)O(n)，存储当前排列和递归调用栈。</li>
</ul>
<p>总结：</p>
<ul>
<li>生成全排列的基本思路是利用回溯算法，在每一步选择一个未使用的元素，递归地生成所有可能的排列。</li>
<li>对于有重复元素的数组，需要进行去重处理，可以通过排序和跳过相同的元素来避免重复的排列。</li>
</ul>
<h4 id="问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？"><a href="#问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？" class="headerlink" title="问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？"></a>问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？</h4><p>要快速查询出价格在 1000 到 2000 区间的商品，在设计上需要考虑性能、可扩展性以及高效的查询方式。以下是几个设计思路和解决方案：</p>
<ol>
<li><strong>使用索引（数据库层面）</strong></li>
</ol>
<ul>
<li><p><strong>数据库设计</strong>：首先要保证数据库中商品表的价格字段（比如 <code>price</code>）有索引。这样，当我们进行基于价格范围的查询时，数据库能够快速定位到匹配的记录。</p>
</li>
<li><p><strong>SQL 查询</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="keyword">BETWEEN</span> <span class="number">1000</span> <span class="keyword">AND</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<p>这个查询会利用 <code>price</code> 字段的索引（如果有）来快速检索符合条件的商品。</p>
</li>
<li><p><strong>索引优化</strong>：为了提高查询性能，确保商品表上的 <code>price</code> 字段有合适的索引。如果有多个条件查询（例如，按价格和类目查询），可以考虑复合索引。</p>
</li>
<li><p><strong>注意</strong>：索引可以大大加快查询速度，但在高并发或大量数据情况下，单纯依赖索引还可能会遇到性能瓶颈。这时可以考虑缓存或者分库分表等技术。</p>
</li>
</ul>
<ol start="2">
<li><strong>使用分区（Partitioning）</strong></li>
</ol>
<ul>
<li><p>分区策略</p>
<p>：当数据量非常大时，可以考虑对商品表进行分区，将商品按价格范围划分成多个子表（例如：每 1000 元一个分区），然后查询时直接针对对应的分区查询。</p>
<ul>
<li>分区表示例：<ul>
<li><code>products_price_0_1000</code></li>
<li><code>products_price_1000_2000</code></li>
<li><code>products_price_2000_3000</code></li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>好处</strong>：可以减小查询的范围，从而提高查询性能。</p>
</li>
</ul>
<ol start="3">
<li><strong>使用缓存（Cache）</strong></li>
</ol>
<ul>
<li><strong>Redis / Memcached 缓存</strong>：对于查询频繁的价格范围，可以将结果缓存到内存中，例如使用 Redis 来存储价格区间查询的结果。通过预热缓存，可以避免每次查询都从数据库中获取数据。<ul>
<li>示例：可以将查询的价格区间结果（如 <code>1000-2000</code> 范围内的商品列表）存储在 Redis 中，查询时先从 Redis 获取，如果没有再去数据库查询并更新缓存。</li>
</ul>
</li>
<li><strong>缓存更新策略</strong>：对于商品价格的更新或新增，应该确保缓存与数据库一致。可以使用如 <strong>缓存失效策略</strong> 或 <strong>定期更新缓存</strong> 的方法。</li>
</ul>
<ol start="4">
<li><strong>使用全文检索或搜索引擎（ElasticSearch）</strong></li>
</ol>
<ul>
<li><p><strong>ElasticSearch</strong>：如果查询的维度不仅仅是价格，还包括类目、品牌、评分等多种条件，传统的关系型数据库可能性能不足，特别是对于大规模数据的检索。可以使用搜索引擎（如 <strong>ElasticSearch</strong>）来高效查询商品。</p>
<ul>
<li><p>ElasticSearch 的优点</p>
<p>：</p>
<ul>
<li><strong>分布式</strong>：可以横向扩展，处理超大规模数据。</li>
<li><strong>高效查询</strong>：支持快速的区间查询，并且可以利用 <strong>倒排索引</strong> 提供非常高效的检索能力。</li>
<li><strong>聚合查询</strong>：支持复杂的聚合和筛选操作。</li>
</ul>
</li>
<li><p>ElasticSearch 查询示例</p>
<p>（查询价格区间的商品）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;gte&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="number">2000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>优点</strong>：ElasticSearch 是针对高效搜索和过滤场景设计的，适合做复杂的查询和范围查找。</p>
</li>
</ul>
<ol start="5">
<li><strong>物理设计优化</strong></li>
</ol>
<ul>
<li><strong>合理的表设计</strong>：确保商品表具有合理的字段设计，例如每个商品的价格字段 <code>price</code> 应该使用合适的数据类型（如 <code>DECIMAL</code> 或 <code>FLOAT</code>）。</li>
<li><strong>数据类型选择</strong>：如果价格字段的数据类型不合适（例如 <code>VARCHAR</code>），可能会导致查询时的性能问题，尽量使用数值型的数据类型来存储价格。</li>
</ul>
<ol start="6">
<li><strong>分页查询与优化</strong></li>
</ol>
<ul>
<li><p>如果商品数量较多，需要返回所有符合条件的商品，可以进行分页查询，以减少每次查询的负载。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="keyword">BETWEEN</span> <span class="number">1000</span> <span class="keyword">AND</span> <span class="number">2000</span> LIMIT <span class="number">100</span> <span class="keyword">OFFSET</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>在高并发场景下，使用 <strong>游标分页</strong> 或 <strong>基于时间戳的分页</strong> 会比 <code>LIMIT</code> + <code>OFFSET</code> 更高效，因为后者随着偏移量的增加会有较大的性能开销。</p>
</li>
</ul>
<p>总结：</p>
<p>查询方式：</p>
<ol>
<li><strong>使用数据库索引</strong>：保证商品表的价格字段有索引，利用 <code>BETWEEN</code> 语句快速查询。</li>
<li><strong>分区</strong>：将商品表按价格范围分区，在大数据量下减少查询的范围。</li>
<li><strong>缓存</strong>：使用 Redis 等缓存机制缓存价格区间查询结果，减少对数据库的压力。</li>
<li><strong>搜索引擎</strong>：使用 ElasticSearch 等搜索引擎进行高效的范围查询，特别是当查询条件复杂时。</li>
</ol>
<p>其他考虑：</p>
<ul>
<li><strong>查询频率与更新频率</strong>：高频查询可以通过缓存优化，低频查询则可以直接依赖数据库查询。</li>
<li><strong>数据一致性</strong>：对于缓存方案，要确保缓存和数据库的一致性，避免缓存不更新导致数据不一致。</li>
</ul>
<p>使用这些方法可以在保证查询效率的同时，确保系统能够快速响应并处理大量商品数据。</p>
<h4 id="问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？"><a href="#问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？" class="headerlink" title="问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？"></a>问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？</h4><p>在这个场景中，我们需要保证多个线程同时操作背包时，能避免数据不一致或竞争条件的发生。假设这个背包可以存放物品，每个物品有一定的重量、价值等属性。为了实现线程安全的操作，我们可以使用加锁机制，确保在同一时间只有一个线程能访问背包。</p>
<p>思路</p>
<ol>
<li><strong>使用锁保证互斥性</strong>：使用锁（例如 <code>synchronized</code> 或 <code>ReentrantLock</code>）来确保多个线程在访问背包时，只有一个线程能执行修改背包内容的操作。</li>
<li><strong>锁的粒度</strong>：锁的粒度越大，性能开销也越大，因此应该尽量减小锁的作用范围。理想情况下，我们只需要在修改背包状态时加锁，而在读取背包状态时可以避免加锁（如果可以保证读操作的线程安全）。</li>
</ol>
<p>问题分析：</p>
<ul>
<li>背包的内容应该是线程安全的，多个线程可能同时尝试修改它，因此我们需要加锁来保护对背包的修改操作。</li>
<li>在本例中，加锁应该放在修改背包内容（如放入物品、取走物品等）的关键代码段。</li>
</ul>
<p>Java 代码实现</p>
<p>首先定义一个 <code>Backpack</code> 类，包含一些基本的操作，例如放入物品和移走物品。</p>
<ol>
<li><strong>使用 <code>synchronized</code> 锁</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String name, <span class="keyword">int</span> weight, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Backpack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Backpack</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加物品到背包</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addItem</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getTotalWeight() + item.weight &lt;= capacity) &#123;</span><br><span class="line">            items.add(item);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从背包中移走物品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeItem</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (items.contains(item)) &#123;</span><br><span class="line">            items.remove(item);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取背包中所有物品的总重量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTotalWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">            totalWeight += item.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取背包中物品的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解释：</p>
<ol>
<li><p><strong>加锁位置</strong>：<code>addItem</code> 和 <code>removeItem</code> 方法用 <code>synchronized</code> 关键字加锁，确保每次只有一个线程能执行对背包的修改操作（如添加或移走物品）。</p>
</li>
<li><p><strong>锁的粒度</strong>：<code>synchronized</code> 会在方法执行时加锁，保证一个线程在执行过程中不会被其他线程干扰，直到执行完方法，释放锁。</p>
</li>
<li><p><strong>读取操作</strong>：在本例中，获取背包物品的列表 (<code>getItems</code>) 不加锁，因为读取操作不会修改背包状态。如果对读取操作有其他需求（比如确保在读取时数据一致），可以考虑在读取时加锁，或者使用 <code>ReadWriteLock</code>。</p>
</li>
<li><p><strong>使用 <code>ReentrantLock</code></strong></p>
</li>
</ol>
<p><code>ReentrantLock</code> 提供了更细粒度的控制，并且支持尝试锁（<code>tryLock</code>）等功能。我们可以使用 <code>ReentrantLock</code> 来替代 <code>synchronized</code>，来控制背包的修改操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackpackWithLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BackpackWithLock</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加物品到背包</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addItem</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        lock.lock();  <span class="comment">// 手动加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getTotalWeight() + item.weight &lt;= capacity) &#123;</span><br><span class="line">                items.add(item);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();  <span class="comment">// 确保释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从背包中移走物品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeItem</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (items.contains(item)) &#123;</span><br><span class="line">                items.remove(item);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取背包中所有物品的总重量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTotalWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">            totalWeight += item.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取背包中物品的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解释：</p>
<ol>
<li><p>**使用 <code>ReentrantLock</code>**：与 <code>synchronized</code> 不同，<code>ReentrantLock</code> 允许更灵活的控制，支持手动锁定和解锁。</p>
</li>
<li><p><strong>锁的控制</strong>：通过调用 <code>lock.lock()</code> 来加锁，执行完操作后调用 <code>lock.unlock()</code> 释放锁。确保在发生异常时也能释放锁（通过 <code>finally</code> 块确保）。</p>
</li>
<li><p><strong>优点</strong>：相较于 <code>synchronized</code>，<code>ReentrantLock</code> 可以支持公平锁（<code>ReentrantLock(true)</code>）、尝试锁定（<code>tryLock</code>）等更多的功能。</p>
</li>
<li><p><strong>线程池管理（可选）</strong></p>
</li>
</ol>
<p>如果你希望让多个线程并发地操作背包并且提高性能，可以考虑使用线程池来管理线程。比如在背包的操作中使用线程池来模拟多线程并发操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackpackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Backpack backpack = <span class="keyword">new</span> Backpack(<span class="number">100</span>);</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);  <span class="comment">// 创建一个线程池</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟多线程同时操作背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                Item item = <span class="keyword">new</span> Item(<span class="string">&quot;item&quot;</span> + index, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">                <span class="keyword">if</span> (backpack.addItem(item)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Successfully added &quot;</span> + item.name);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Failed to add &quot;</span> + item.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键点：</p>
<ul>
<li><strong>线程池</strong>：通过使用 <code>ExecutorService</code> 可以模拟多个线程并发执行操作，并且方便地管理线程生命周期。</li>
<li><strong>安全性</strong>：保证背包的操作是线程安全的，通过锁机制（<code>synchronized</code> 或 <code>ReentrantLock</code>）保证多个线程不会同时修改背包数据。</li>
</ul>
<p>总结：</p>
<ul>
<li><strong>加锁的位置</strong>：加锁应该放在对背包内容有修改的关键代码段（如 <code>addItem</code> 和 <code>removeItem</code>）。</li>
<li><strong>锁的粒度</strong>：尽量在小范围内加锁，避免锁住不必要的代码，减少性能开销。</li>
<li><strong>使用线程池</strong>：多线程操作时使用线程池管理，可以有效利用系统资源并避免线程的过度创建销毁。</li>
</ul>
<p>时间复杂度：</p>
<ul>
<li>**<code>addItem</code> 和 <code>removeItem</code>**：每次操作需要遍历背包中的物品（若是顺序查找或移除），时间复杂度为 O(n)，其中 n 是背包中物品的数量。</li>
<li><strong>获取背包物品列表（<code>getItems</code>）</strong>：O(n)。</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li>空间复杂度为 O(n)，其中 n 是背包中物品的数量，存储物品列表的空间需求。</li>
</ul>
<h4 id="问：判断数组里是否有和为指定值的两个数？"><a href="#问：判断数组里是否有和为指定值的两个数？" class="headerlink" title="问：判断数组里是否有和为指定值的两个数？"></a>问：判断数组里是否有和为指定值的两个数？</h4><p>要判断一个数组中是否存在两个数，它们的和为指定值，可以通过以下几种方法来实现。</p>
<p>方法 1: <strong>暴力法</strong></p>
<p>暴力法的基本思路是遍历数组中的每一对元素，检查它们的和是否等于指定值。这种方法时间复杂度为 O(n2)O(n^2)，空间复杂度为 O(1)O(1)。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPairWithSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] + arr[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">10</span>;</span><br><span class="line">        System.out.println(hasPairWithSum(arr, target));  <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>: O(n2)O(n^2)，因为需要检查每一对元素。</li>
<li><strong>空间复杂度</strong>: O(1)O(1)，没有使用额外的空间。</li>
</ul>
<p>方法 2: <strong>哈希表法</strong></p>
<p>哈希表法的基本思路是使用一个哈希集合来存储数组中的元素。对于每一个元素，判断目标值减去该元素的差值是否已经存在于哈希表中。如果存在，说明找到了这两个数，否则将当前元素加入哈希表。这种方法时间复杂度为 O(n)O(n)，空间复杂度为 O(n)O(n)。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPairWithSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.contains(target - num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">10</span>;</span><br><span class="line">        System.out.println(hasPairWithSum(arr, target));  <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>: O(n)O(n)，遍历数组一次，哈希表的插入和查找平均时间复杂度为 O(1)O(1)。</li>
<li><strong>空间复杂度</strong>: O(n)O(n)，需要存储一个哈希集合。</li>
</ul>
<p>方法 3: <strong>排序 + 双指针法</strong></p>
<p>如果数组是无序的，我们可以先对数组进行排序，然后使用双指针的方法：一个指针从数组的开头开始，另一个指针从数组的末尾开始。根据当前两个指针指向的元素之和与目标值的大小关系，调整指针的位置。该方法的时间复杂度为 O(nlog⁡n)O(n \log n)，因为需要对数组进行排序，空间复杂度为 O(1)O(1)。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPairWithSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);  <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = arr[left] + arr[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                left++;  <span class="comment">// 和小于目标，左指针右移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;  <span class="comment">// 和大于目标，右指针左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">10</span>;</span><br><span class="line">        System.out.println(hasPairWithSum(arr, target));  <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>: O(nlog⁡n)O(n \log n)，排序的时间复杂度是 O(nlog⁡n)O(n \log n)，双指针扫描数组的时间复杂度是 O(n)O(n)。</li>
<li><strong>空间复杂度</strong>: O(1)O(1)，排序时使用的空间为常数空间（原地排序）。</li>
</ul>
<p>总结：</p>
<ol>
<li><strong>暴力法</strong>：时间复杂度 O(n2)O(n^2)，空间复杂度 O(1)O(1)，实现简单，但效率较低。</li>
<li><strong>哈希表法</strong>：时间复杂度 O(n)O(n)，空间复杂度 O(n)O(n)，通过哈希表快速查找，提高效率。</li>
<li><strong>排序 + 双指针法</strong>：时间复杂度 O(nlog⁡n)O(n \log n)，空间复杂度 O(1)O(1)，适用于排序后的数组，节省空间。</li>
</ol>
<p>对于该问题，通常推荐使用 <strong>哈希表法</strong>，因为它提供了最好的时间效率。</p>
<h4 id="问：对笔试题进行提问？有没找到更好的解法吗？"><a href="#问：对笔试题进行提问？有没找到更好的解法吗？" class="headerlink" title="问：对笔试题进行提问？有没找到更好的解法吗？"></a>问：对笔试题进行提问？有没找到更好的解法吗？</h4><p>(题目大概是一个数组里除了一个数字出现一次，其它数字都出现了两次，给一个最优解法？我说可以用map，key为数字，value为该数字出现次数？面试官给了一个异或的方法，提示两次异或是本身）</p>
<p>这个问题可以通过 <strong>异或</strong> 操作来高效解决，时间复杂度为 O(n)O(n)，空间复杂度为 O(1)O(1)。具体思路如下：</p>
<p>思路：</p>
<ul>
<li><strong>异或操作</strong>：有一个重要性质：<code>a ^ a = 0</code> 和 <code>a ^ 0 = a</code>。所以，如果我们对所有数组中的元素进行异或操作，两个相同的数字会相互抵消，最后剩下的就是那个只出现一次的数字。</li>
<li><strong>时间复杂度</strong>：由于我们只需要遍历一次数组，时间复杂度为 O(n)O(n)。</li>
<li><strong>空间复杂度</strong>：不需要额外的空间，空间复杂度为 O(1)O(1)。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSingleNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            result ^= num;  <span class="comment">// 对数组中的所有元素进行异或操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 最后返回的就是那个只出现一次的数字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;  <span class="comment">// 1 是唯一只出现一次的数字</span></span><br><span class="line">        System.out.println(findSingleNumber(arr));  <span class="comment">// Output: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<ul>
<li><strong>时间复杂度</strong>：O(n)O(n)，我们只遍历了数组一次，其中 nn 是数组的长度。</li>
</ul>
<p>空间复杂度：</p>
<ul>
<li><strong>空间复杂度</strong>：O(1)O(1)，只用了一个常量大小的 <code>result</code> 变量。</li>
</ul>
<p>为什么这个方法有效？</p>
<ul>
<li>异或操作会抵消重复出现的数字，因此最后剩下的就是那个只出现一次的数字。</li>
<li>即使数组长度非常大，遍历一次数组并进行异或操作是非常高效的。</li>
</ul>
<h2 id="三-算法题"><a href="#三-算法题" class="headerlink" title="三.算法题"></a>三.算法题</h2><p>leetcode面试经典150题</p>
<h3 id="3-1-数组-字符串-Arrays-Strings"><a href="#3-1-数组-字符串-Arrays-Strings" class="headerlink" title="3.1 数组/字符串 Arrays/Strings"></a>3.1 数组/字符串 Arrays/Strings</h3><h4 id="88-合并两个有序数组-lt-easy-gt-双指针"><a href="#88-合并两个有序数组-lt-easy-gt-双指针" class="headerlink" title="88.合并两个有序数组 &lt;easy&gt; 双指针"></a>88.合并两个有序数组 &lt;easy&gt; 双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*    给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span></span><br><span class="line"><span class="comment">    输出：[1,2,2,3,5,6]</span></span><br><span class="line"><span class="comment">    解释：需要合并 [1,2,3] 和 [2,5,6] 。</span></span><br><span class="line"><span class="comment">    合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span></span><br><span class="line"><span class="comment">    示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    输入：nums1 = [1], m = 1, nums2 = [], n = 0</span></span><br><span class="line"><span class="comment">    输出：[1]</span></span><br><span class="line"><span class="comment">    解释：需要合并 [1] 和 [] 。</span></span><br><span class="line"><span class="comment">    合并结果是 [1] 。</span></span><br><span class="line"><span class="comment">    示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span></span><br><span class="line"><span class="comment">    输出：[1]</span></span><br><span class="line"><span class="comment">    解释：需要合并的数组是 [] 和 [1] 。</span></span><br><span class="line"><span class="comment">    合并结果是 [1] 。</span></span><br><span class="line"><span class="comment">    注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    nums1.length == m + n</span></span><br><span class="line"><span class="comment">    nums2.length == n</span></span><br><span class="line"><span class="comment">0 &lt;= m, n &lt;= 200</span></span><br><span class="line"><span class="comment">            1 &lt;= m + n &lt;= 200</span></span><br><span class="line"><span class="comment">            -109 &lt;= nums1[i], nums2[j] &lt;= 109</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTwoSortedArrays88</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//// 1.先合并后排序</span></span><br><span class="line">        <span class="comment">//for (int i = 0; i != n; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//    nums1[m + i] = nums2[i];</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//// 排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n)log(m+n))</span></span><br><span class="line">        <span class="comment">//Arrays.sort(nums1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.逆向双指针，因为数组是有序的，用两个指针分别指向两个数组的首个元素，对比大小</span></span><br><span class="line">        <span class="comment">// 因为数组1后面是空的，所以倒叙遍历可以直接覆盖后面的元素</span></span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环直到两个指针都走完</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对比两个数组，较大的值放入队尾</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若数组1为空则遍历数组2放入数组1</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 时间复杂大为O(m + n)，因为只需要遍历一遍两个数组，进行一次比较和移动操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2_1 = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> m1 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        merge(nums1_1, m1, nums2_1, n1);</span><br><span class="line">        System.out.print(<span class="string">&quot;Test Case 1: &quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(nums1_1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums1_2 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2_2 = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> m2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        merge(nums1_2, m2, nums2_2, n2);</span><br><span class="line">        System.out.print(<span class="string">&quot;Test Case 2: &quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(nums1_2));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums1_3 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2_3 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> m3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        merge(nums1_3, m3, nums2_3, n3);</span><br><span class="line">        System.out.print(<span class="string">&quot;Test Case 3: &quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(nums1_3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="27-移除元素-lt-easy-gt-双指针"><a href="#27-移除元素-lt-easy-gt-双指针" class="headerlink" title="27. 移除元素 &lt;easy&gt; 双指针"></a>27. 移除元素 &lt;easy&gt; 双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        说明:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        为什么返回数值是整数，但输出的答案是数组呢?</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以想象内部操作如下:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="comment">        int len = removeElement(nums, val);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">        print(nums[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [3,2,2,3], val = 3</span></span><br><span class="line"><span class="comment">        输出：2, nums = [2,2]</span></span><br><span class="line"><span class="comment">        解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,1,2,2,3,0,4,2], val = 2</span></span><br><span class="line"><span class="comment">        输出：5, nums = [0,1,3,0,4]</span></span><br><span class="line"><span class="comment">        解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= nums.length &lt;= 100</span></span><br><span class="line"><span class="comment">        0 &lt;= nums[i] &lt;= 50</span></span><br><span class="line"><span class="comment">        0 &lt;= val &lt;= 100*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveElement27</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为不需要考虑数组中超出新长度后面的元素，并且一次遍历完成操作，所以直接覆盖原数组元素即可</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">        <span class="comment">// 时间复杂大为O(n)，因为只需要遍历一遍数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> val1 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = removeElement(nums1, val1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Length: &quot;</span> + len1 + <span class="string">&quot;, nums = &quot;</span>);</span><br><span class="line">        printArray(nums1, len1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> val2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = removeElement(nums2, val2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Length: &quot;</span> + len2 + <span class="string">&quot;, nums = &quot;</span>);</span><br><span class="line">        printArray(nums2, len2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(arr[i] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="26-删除有序数组中的重复项-lt-easy-gt-双指针"><a href="#26-删除有序数组中的重复项-lt-easy-gt-双指针" class="headerlink" title="26. 删除有序数组中的重复项 &lt;easy&gt; 双指针"></a>26. 删除有序数组中的重复项 &lt;easy&gt; 双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。</span></span><br><span class="line"><span class="comment">        返回 k 。</span></span><br><span class="line"><span class="comment">        判题标准:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        系统会用下面的代码来测试你的题解:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int[] nums = [...]; // 输入数组</span></span><br><span class="line"><span class="comment">        int[] expectedNums = [...]; // 长度正确的期望答案</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int k = removeDuplicates(nums); // 调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        assert k == expectedNums.length;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; k; i++) &#123;</span></span><br><span class="line"><span class="comment">        assert nums[i] == expectedNums[i];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        如果所有断言都通过，那么您的题解将被 通过。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1,1,2]</span></span><br><span class="line"><span class="comment">        输出：2, nums = [1,2,_]</span></span><br><span class="line"><span class="comment">        解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,0,1,1,1,2,2,3,3,4]</span></span><br><span class="line"><span class="comment">        输出：5, nums = [0,1,2,3,4]</span></span><br><span class="line"><span class="comment">        解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">        -104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">        nums 已按 非严格递增 排列*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedArray26</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有序数组的去重和合并，都可以考虑用双指针来解决</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 相邻元素相等时由后一位替代，不相等时不动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">            <span class="comment">// 相邻元素相等时i指针不动，直到j指针标到不相等元素时再替换相邻的下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 时间复杂度是 O(n)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(arr[i] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k1 = removeDuplicates(nums1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Length: &quot;</span> + k1 + <span class="string">&quot;, nums = &quot;</span>);</span><br><span class="line">        printArray(nums1, k1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k2 = removeDuplicates(nums2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Length: &quot;</span> + k2 + <span class="string">&quot;, nums = &quot;</span>);</span><br><span class="line">        printArray(nums2, k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="80-删除有序数组中的重复项-II-lt-medium-gt-双指针"><a href="#80-删除有序数组中的重复项-II-lt-medium-gt-双指针" class="headerlink" title="80. 删除有序数组中的重复项 II &lt;medium&gt; 双指针"></a>80. 删除有序数组中的重复项 II &lt;medium&gt; 双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        说明：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        为什么返回数值是整数，但输出的答案是数组呢？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以想象内部操作如下:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="comment">        int len = removeDuplicates(nums);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">        print(nums[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1,1,1,2,2,3]</span></span><br><span class="line"><span class="comment">        输出：5, nums = [1,1,2,2,3]</span></span><br><span class="line"><span class="comment">        解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,0,1,1,1,1,2,3,3]</span></span><br><span class="line"><span class="comment">        输出：7, nums = [0,0,1,1,2,3,3]</span></span><br><span class="line"><span class="comment">        解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">        -104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">        nums 已按升序排列*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedArray80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">2</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="comment">// 跨两位比较，当值不匹配是双指针同速，匹配则慢指针停留，直到下一个不相等时与后面相隔位置交换</span></span><br><span class="line">            <span class="keyword">if</span> (nums[slow - <span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 时间复杂度是 O(n)</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(arr[i] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k1 = removeDuplicates(nums1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Length: &quot;</span> + k1 + <span class="string">&quot;, nums = &quot;</span>);</span><br><span class="line">        printArray(nums1, k1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k2 = removeDuplicates(nums2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Length: &quot;</span> + k2 + <span class="string">&quot;, nums = &quot;</span>);</span><br><span class="line">        printArray(nums2, k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="169-多数元素-lt-easy-gt"><a href="#169-多数元素-lt-easy-gt" class="headerlink" title="169. 多数元素 &lt;easy&gt;"></a>169. 多数元素 &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [3,2,3]</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [2,2,1,1,1,2,2]</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment">        n == nums.length</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 5 * 104</span></span><br><span class="line"><span class="comment">        -109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MajorityElement169</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 命中则+1，否则-1，直到count减为0则换为新的，最终留下的则是多数元素，否则说明没有超过1/2的元素</span></span><br><span class="line">            count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result1 = majorityElement(nums1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Majority Element: &quot;</span> + result1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result2 = majorityElement(nums2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Majority Element: &quot;</span> + result2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result3 = majorityElement(nums3);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 3:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Majority Element: &quot;</span> + result3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="189-轮转数组-lt-medium-gt-数组翻转"><a href="#189-轮转数组-lt-medium-gt-数组翻转" class="headerlink" title="189. 轮转数组 &lt;medium&gt; 数组翻转"></a>189. 轮转数组 &lt;medium&gt; 数组翻转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums = [1,2,3,4,5,6,7], k = 3</span></span><br><span class="line"><span class="comment">        输出: [5,6,7,1,2,3,4]</span></span><br><span class="line"><span class="comment">        解释:</span></span><br><span class="line"><span class="comment">        向右轮转 1 步: [7,1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">        向右轮转 2 步: [6,7,1,2,3,4,5]</span></span><br><span class="line"><span class="comment">        向右轮转 3 步: [5,6,7,1,2,3,4]</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [-1,-100,3,99], k = 2</span></span><br><span class="line"><span class="comment">        输出：[3,99,-1,-100]</span></span><br><span class="line"><span class="comment">        解释:</span></span><br><span class="line"><span class="comment">        向右轮转 1 步: [99,-1,-100,3]</span></span><br><span class="line"><span class="comment">        向右轮转 2 步: [3,99,-1,-100]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">        -231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">        0 &lt;= k &lt;= 105</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。</span></span><br><span class="line"><span class="comment">        你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateArray189</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        k %= n;</span><br><span class="line">        <span class="comment">// 第一次倒转，将整个数组倒转 7，6，5，4，3，2，1</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 第二次倒转，将前k个元素倒转 5，6，7，4，3，2，1</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 第三次倒转，将后面的元素倒转 5，6，7，1，2，3，4</span></span><br><span class="line">        reverse(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k1 = <span class="number">3</span>;</span><br><span class="line">        rotate(nums1, k1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1:&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;-<span class="number">1</span>, -<span class="number">100</span>, <span class="number">3</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k2 = <span class="number">2</span>;</span><br><span class="line">        rotate(nums2, k2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2:&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(nums2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用额外数组 O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateExtraArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 通过取余数来实现循环右移</span></span><br><span class="line">            result[(i + k) % n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(result, <span class="number">0</span>, nums, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力旋转 O(n * k)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateBruteForce</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次循环数组右移1位，直到右移K位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>;j &gt; -<span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    nums[j] = end;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转数组 O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateReverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        k %= n;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首位调转位置</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="121-买卖股票的最佳时机-lt-easy-gt"><a href="#121-买卖股票的最佳时机-lt-easy-gt" class="headerlink" title="121. 买卖股票的最佳时机 &lt;easy&gt;"></a>121. 买卖股票的最佳时机 &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">        输出：5</span></span><br><span class="line"><span class="comment">        解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span></span><br><span class="line"><span class="comment">        注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：prices = [7,6,4,3,1]</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment">        解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= prices.length &lt;= 105</span></span><br><span class="line"><span class="comment">        0 &lt;= prices[i] &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStock121</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int buy;</span></span><br><span class="line">        <span class="comment">//int sale;</span></span><br><span class="line">        <span class="comment">//int result = 0;</span></span><br><span class="line">        <span class="comment">//for (int i = 0;i &lt; prices.length;i++) &#123;</span></span><br><span class="line">        <span class="comment">//    buy = prices[i];</span></span><br><span class="line">        <span class="comment">//    for (int j = i+1;j &lt; prices.length;j++) &#123;</span></span><br><span class="line">        <span class="comment">//        sale = prices[j];</span></span><br><span class="line">        <span class="comment">//        result = Math.max((sale - buy), result);</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//result = Math.max(0, result);</span></span><br><span class="line">        <span class="comment">// O(n^2)</span></span><br><span class="line">        <span class="comment">//return result;</span></span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="comment">// 取当前最小价格</span></span><br><span class="line">            minPrice = Math.min(minPrice, price);</span><br><span class="line">            <span class="comment">// 取当前最大差值</span></span><br><span class="line">            maxProfit = Math.max(maxProfit, price - minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices1 = &#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxProfit1 = maxProfit(prices1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Max Profit: &quot;</span> + maxProfit1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] prices2 = &#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxProfit2 = maxProfit(prices2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Max Profit: &quot;</span> + maxProfit2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] prices3 = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxProfit3 = maxProfit(prices3);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 3:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Max Profit: &quot;</span> + maxProfit3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="122-买卖股票的最佳时机-II-lt-medium-gt"><a href="#122-买卖股票的最佳时机-II-lt-medium-gt" class="headerlink" title="122. 买卖股票的最佳时机 II &lt;medium&gt;"></a>122. 买卖股票的最佳时机 II &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        返回 你能获得的 最大 利润 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：prices = [7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">        输出：7</span></span><br><span class="line"><span class="comment">        解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span></span><br><span class="line"><span class="comment">        随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span></span><br><span class="line"><span class="comment">        总利润为 4 + 3 = 7 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：prices = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span></span><br><span class="line"><span class="comment">        总利润为 4 。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：prices = [7,6,4,3,1]</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment">        解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= prices.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">        0 &lt;= prices[i] &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStock122</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int buy = 0;</span></span><br><span class="line">        <span class="comment">//boolean flag = false;</span></span><br><span class="line">        <span class="comment">//int total = 0;</span></span><br><span class="line">        <span class="comment">//for (int i = 0;i &lt; prices.length;i++) &#123;</span></span><br><span class="line">        <span class="comment">//    // 是否卖出</span></span><br><span class="line">        <span class="comment">//    if (flag &amp;&amp; (i+1 == prices.length || prices[i+1] &lt; prices[i])) &#123;</span></span><br><span class="line">        <span class="comment">//        total += prices[i] - buy;</span></span><br><span class="line">        <span class="comment">//        flag = false;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//    // 是否买入</span></span><br><span class="line">        <span class="comment">//    if (!flag &amp;&amp; i+1 != prices.length &amp;&amp; prices[i+1] &gt; prices[i]) &#123;</span></span><br><span class="line">        <span class="comment">//        buy = prices[i];</span></span><br><span class="line">        <span class="comment">//        // 已持有</span></span><br><span class="line">        <span class="comment">//        flag = true;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//// O(n)</span></span><br><span class="line">        <span class="comment">//return total;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                maxProfit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices1 = &#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxProfit1 = maxProfit(prices1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Max Profit: &quot;</span> + maxProfit1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] prices2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxProfit2 = maxProfit(prices2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Max Profit: &quot;</span> + maxProfit2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] prices3 = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxProfit3 = maxProfit(prices3);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 3:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Max Profit: &quot;</span> + maxProfit3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="55-跳跃游戏-lt-medium-gt-贪心"><a href="#55-跳跃游戏-lt-medium-gt-贪心" class="headerlink" title="55. 跳跃游戏 &lt;medium&gt; 贪心"></a>55. 跳跃游戏 &lt;medium&gt; 贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [2,3,1,1,4]</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [3,2,1,0,4]</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">        0 &lt;= nums[i] &lt;= 105*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGame55</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// //贪心算法</span></span><br><span class="line">        <span class="comment">//int maxLength = 0;</span></span><br><span class="line">        <span class="comment">//for (int i = 0;i &lt; nums.length - 1;i++) &#123;</span></span><br><span class="line">        <span class="comment">//    // 每次更新当前的最远距离</span></span><br><span class="line">        <span class="comment">//    maxLength = Math.max(nums[i], maxLength - 1);</span></span><br><span class="line">        <span class="comment">//    if (maxLength &lt;= 0) &#123;</span></span><br><span class="line">        <span class="comment">//        return false;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return true;</span></span><br><span class="line">        <span class="keyword">int</span> maxJump = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxJump) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxJump = Math.max(maxJump, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (maxJump &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> result1 = canJump(nums1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Can Jump: &quot;</span> + result1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> result2 = canJump(nums2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Can Jump: &quot;</span> + result2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="45-跳跃游戏-II-lt-medium-gt-贪心"><a href="#45-跳跃游戏-II-lt-medium-gt-贪心" class="headerlink" title="45. 跳跃游戏 II &lt;medium&gt; 贪心"></a>45. 跳跃游戏 II &lt;medium&gt; 贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= j &lt;= nums[i]</span></span><br><span class="line"><span class="comment">        i + j &lt; n</span></span><br><span class="line"><span class="comment">返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums = [2,3,1,1,4]</span></span><br><span class="line"><span class="comment">        输出: 2</span></span><br><span class="line"><span class="comment">        解释: 跳到最后一个位置的最小跳跃数是 2。</span></span><br><span class="line"><span class="comment">        从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums = [2,3,0,1,4]</span></span><br><span class="line"><span class="comment">        输出: 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">        0 &lt;= nums[i] &lt;= 1000</span></span><br><span class="line"><span class="comment">        题目保证可以到达 nums[n-1]*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGame45</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 贪心算法</span></span><br><span class="line">        <span class="keyword">int</span> jumps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curFarthest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 取当前能到达的最远距离</span></span><br><span class="line">            curFarthest = Math.max(curFarthest, i + nums[i]);</span><br><span class="line">            <span class="comment">// 到达跳跃处，更新跳跃次数</span></span><br><span class="line">            <span class="keyword">if</span> (i == curEnd) &#123;</span><br><span class="line">                jumps++;</span><br><span class="line">                curEnd = curFarthest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> jumps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> minJumps1 = jump(nums1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Minimum Jumps: &quot;</span> + minJumps1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> minJumps2 = jump(nums2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Minimum Jumps: &quot;</span> + minJumps2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="274-H-指数-lt-medium-gt"><a href="#274-H-指数-lt-medium-gt" class="headerlink" title="274. H 指数 &lt;medium&gt;"></a>274. H 指数 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：citations = [3,0,6,1,5]</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span></span><br><span class="line"><span class="comment">        由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：citations = [1,3,1]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        n == citations.length</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 5000</span></span><br><span class="line"><span class="comment">        0 &lt;= citations[i] &lt;= 1000*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HIndex274</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = citations.length;</span><br><span class="line">        <span class="comment">// 存储每个引用次数对应的论文数量，引用数量超过论文数量的统计到队尾</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> citation : citations) &#123;</span><br><span class="line">            <span class="comment">// count的下标对应引用次数，值则对应论文数量</span></span><br><span class="line">            <span class="keyword">if</span> (citation &gt;= n) &#123;</span><br><span class="line">                count[n]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count[citation]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒叙遍历，累加论文数量，直到满足论文数量 &gt;= 引用次数</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            total += count[i];</span><br><span class="line">            <span class="keyword">if</span> (total &gt;= i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] citations1 = &#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> hIndex1 = hIndex(citations1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;H-Index: &quot;</span> + hIndex1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] citations2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> hIndex2 = hIndex(citations2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;H-Index: &quot;</span> + hIndex2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="380-O-1-时间插入、删除和获取随机元素-lt-medium-gt"><a href="#380-O-1-时间插入、删除和获取随机元素-lt-medium-gt" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素 &lt;medium&gt;"></a>380. O(1) 时间插入、删除和获取随机元素 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现RandomizedSet 类：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        RandomizedSet() 初始化 RandomizedSet 对象</span></span><br><span class="line"><span class="comment">        bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment">        bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment">        int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。</span></span><br><span class="line"><span class="comment">        你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入</span></span><br><span class="line"><span class="comment">        [&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span></span><br><span class="line"><span class="comment">        [[], [1], [2], [2], [], [1], [2], []]</span></span><br><span class="line"><span class="comment">        输出</span></span><br><span class="line"><span class="comment">        [null, true, false, true, 2, true, false, 2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        解释</span></span><br><span class="line"><span class="comment">        RandomizedSet randomizedSet = new RandomizedSet();</span></span><br><span class="line"><span class="comment">        randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span></span><br><span class="line"><span class="comment">        randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。</span></span><br><span class="line"><span class="comment">        randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span></span><br><span class="line"><span class="comment">        randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。</span></span><br><span class="line"><span class="comment">        randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span></span><br><span class="line"><span class="comment">        randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。</span></span><br><span class="line"><span class="comment">        randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        -231 &lt;= val &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">        最多调用 insert、remove 和 getRandom 函数 2 * 105 次</span></span><br><span class="line"><span class="comment">        在调用 getRandom 方法时，数据结构中 至少存在一个 元素。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertDeleteGetrandomO1380</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomizedSet randomizedSet = <span class="keyword">new</span> RandomizedSet();</span><br><span class="line">        System.out.println(randomizedSet.insert(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(randomizedSet.remove(<span class="number">2</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(randomizedSet.insert(<span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(randomizedSet.getRandom()); <span class="comment">// Random, either 1 or 2</span></span><br><span class="line">        System.out.println(randomizedSet.remove(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(randomizedSet.insert(<span class="number">2</span>)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(randomizedSet.getRandom()); <span class="comment">// Always 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; nums;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false </span></span><br><span class="line">        <span class="keyword">if</span> (indexMap.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        nums.add(val);</span><br><span class="line">        <span class="comment">// Map的值存放val对应数组的下标</span></span><br><span class="line">        indexMap.put(val, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。</span></span><br><span class="line">        <span class="keyword">if</span> (!indexMap.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 获取Map中val的值，对应数组中元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = indexMap.get(val);</span><br><span class="line">        <span class="comment">// 获取数组末尾元素</span></span><br><span class="line">        <span class="keyword">int</span> lastNum = nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将末尾元素分别替换val在数组和Map中的位置</span></span><br><span class="line">        nums.set(index, lastNum);</span><br><span class="line">        indexMap.put(lastNum, index);</span><br><span class="line">        <span class="comment">// 分别删除数组和Map的末尾</span></span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        indexMap.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.get(random.nextInt(nums.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="238-除自身以外数组的乘积-lt-medium-gt-额外数组"><a href="#238-除自身以外数组的乘积-lt-medium-gt-额外数组" class="headerlink" title="238. 除自身以外数组的乘积  &lt;medium&gt; 额外数组"></a>238. 除自身以外数组的乘积  &lt;medium&gt; 额外数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums = [1,2,3,4]</span></span><br><span class="line"><span class="comment">        输出: [24,12,8,6]</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums = [-1,1,0,-3,3]</span></span><br><span class="line"><span class="comment">        输出: [0,0,9,0,0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">        -30 &lt;= nums[i] &lt;= 30</span></span><br><span class="line"><span class="comment">        保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 不被视为 额外空间。）*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductOfArrayExceptSelf238</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 1.两层遍历</span></span><br><span class="line">        <span class="comment">//int[] answer = new int[nums.length];</span></span><br><span class="line">        <span class="comment">//for (int i = 0;i &lt; nums.length;i++) &#123;</span></span><br><span class="line">        <span class="comment">//    answer[i] = 0;</span></span><br><span class="line">        <span class="comment">//    boolean ifSet = false;</span></span><br><span class="line">        <span class="comment">//    for (int j = 0;j &lt; nums.length;j++) &#123;</span></span><br><span class="line">        <span class="comment">//        if (i != j) &#123;</span></span><br><span class="line">        <span class="comment">//            if (!ifSet) &#123;</span></span><br><span class="line">        <span class="comment">//                answer[i] =  nums[j];</span></span><br><span class="line">        <span class="comment">//                ifSet = true;</span></span><br><span class="line">        <span class="comment">//            &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//                answer[i] *=  nums[j];</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">// O(n^2)</span></span><br><span class="line">        <span class="comment">//return answer;</span></span><br><span class="line">        <span class="comment">// 2.使用2个额外数组，分别记录元素左侧和右侧的乘机，最后将两侧乘机相乘</span></span><br><span class="line">        <span class="comment">//int n = nums.length;</span></span><br><span class="line">        <span class="comment">//int[] leftProducts = new int[n];</span></span><br><span class="line">        <span class="comment">//int[] rightProducts = new int[n];</span></span><br><span class="line">        <span class="comment">//int[] answer = new int[n];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// 首次遍历，记录每位元素左边元素的乘机</span></span><br><span class="line">        <span class="comment">//leftProducts[0] = 1;</span></span><br><span class="line">        <span class="comment">//for (int i = 1; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//    leftProducts[i] = leftProducts[i - 1] * nums[i - 1];</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// 二次遍历，记录每位元素右边元素的乘机</span></span><br><span class="line">        <span class="comment">//rightProducts[n - 1] = 1;</span></span><br><span class="line">        <span class="comment">//for (int i = n - 2; i &gt;= 0; i--) &#123;</span></span><br><span class="line">        <span class="comment">//    rightProducts[i] = rightProducts[i + 1] * nums[i + 1];</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// 最后一次，将左右边相乘</span></span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//    answer[i] = leftProducts[i] * rightProducts[i];</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//// 时间空间都为 O(n)</span></span><br><span class="line">        <span class="comment">//return answer;</span></span><br><span class="line">        <span class="comment">// 3.将nums和answer分别作为两个数组记录左右乘机，第二次遍历时即算出最终结果</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            answer[i] = answer[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightProduct = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            answer[i] *= rightProduct;</span><br><span class="line">            rightProduct *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间O(n) 空间O(1)</span></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(productExceptSelf(nums1))); <span class="comment">// [24, 12, 8, 6]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(productExceptSelf(nums2))); <span class="comment">// [0, 0, 9, 0, 0]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(productExceptSelf(nums3))); <span class="comment">// [12,16,24,48,24]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="134-加油站-lt-medium-gt"><a href="#134-加油站-lt-medium-gt" class="headerlink" title="134. 加油站  &lt;medium&gt;"></a>134. 加油站  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span></span><br><span class="line"><span class="comment">        输出: 3</span></span><br><span class="line"><span class="comment">        解释:</span></span><br><span class="line"><span class="comment">        从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span></span><br><span class="line"><span class="comment">        开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span></span><br><span class="line"><span class="comment">        开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span></span><br><span class="line"><span class="comment">        开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span></span><br><span class="line"><span class="comment">        开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span></span><br><span class="line"><span class="comment">        开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span></span><br><span class="line"><span class="comment">        因此，3 可为起始索引。</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: gas = [2,3,4], cost = [3,4,3]</span></span><br><span class="line"><span class="comment">        输出: -1</span></span><br><span class="line"><span class="comment">        解释:</span></span><br><span class="line"><span class="comment">        你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span></span><br><span class="line"><span class="comment">        我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span></span><br><span class="line"><span class="comment">        开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span></span><br><span class="line"><span class="comment">        开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span></span><br><span class="line"><span class="comment">        你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span></span><br><span class="line"><span class="comment">        因此，无论怎样，你都不可能绕环路行驶一周。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        gas.length == n</span></span><br><span class="line"><span class="comment">        cost.length == n</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 10^5</span></span><br><span class="line"><span class="comment">        0 &lt;= gas[i], cost[i] &lt;= 10^4*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GasStation134</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 贪心算法</span></span><br><span class="line">        <span class="keyword">int</span> totalGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currentGas = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">            totalGas += gas[i] - cost[i];</span><br><span class="line">            currentGas += gas[i] - cost[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 油不足，跳到下个站点开始</span></span><br><span class="line">            <span class="keyword">if</span> (currentGas &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                currentGas = <span class="number">0</span>;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总油的正负表示是否能完成全程</span></span><br><span class="line">        <span class="comment">// O(n) O(1)</span></span><br><span class="line">        <span class="keyword">return</span> totalGas &lt; <span class="number">0</span> ? -<span class="number">1</span> : start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] gas1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] cost1 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] gas2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] cost2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        testGasStation(gas1, cost1); <span class="comment">// Example 1</span></span><br><span class="line">        testGasStation(gas2, cost2); <span class="comment">// Example 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGasStation</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = canCompleteCircuit(gas, cost);</span><br><span class="line">        System.out.println(<span class="string">&quot;Gas: &quot;</span> + Arrays.toString(gas) + <span class="string">&quot;, Cost: &quot;</span> + Arrays.toString(cost));</span><br><span class="line">        System.out.println(<span class="string">&quot;Output: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="135-分发糖果-lt-hard-gt"><a href="#135-分发糖果-lt-hard-gt" class="headerlink" title="135. 分发糖果  &lt;hard&gt;"></a>135. 分发糖果  &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你需要按照以下要求，给这些孩子分发糖果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        每个孩子至少分配到 1 个糖果。</span></span><br><span class="line"><span class="comment">        相邻两个孩子评分更高的孩子会获得更多的糖果。</span></span><br><span class="line"><span class="comment">        请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：ratings = [1,0,2]</span></span><br><span class="line"><span class="comment">        输出：5</span></span><br><span class="line"><span class="comment">        解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：ratings = [1,2,2]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span></span><br><span class="line"><span class="comment">        第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        n == ratings.length</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 2 * 10^4</span></span><br><span class="line"><span class="comment">        0 &lt;= ratings[i] &lt;= 2 * 10^4*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy135</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ratings.length;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(candies, <span class="number">1</span>); <span class="comment">// 每个孩子初始至少一个糖果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左到右扫描，确保右边评分高的孩子糖果数比左边多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右到左扫描，确保左边评分高的孩子糖果数比右边多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = Math.max(candies[i], candies[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies) &#123;</span><br><span class="line">            sum += candy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n) O(n)</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ratings1 = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;需要准备的最少糖果数目：&quot;</span> + candy(ratings1)); <span class="comment">// 输出：5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ratings2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;需要准备的最少糖果数目：&quot;</span> + candy(ratings2)); <span class="comment">// 输出：4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="42-接雨水-lt-hard-gt-双指针"><a href="#42-接雨水-lt-hard-gt-双指针" class="headerlink" title="42. 接雨水  &lt;hard&gt; 双指针"></a>42. 接雨水  &lt;hard&gt; 双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span></span><br><span class="line"><span class="comment">        输出：6</span></span><br><span class="line"><span class="comment">        解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：height = [4,2,0,3,2,5]</span></span><br><span class="line"><span class="comment">        输出：9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        n == height.length</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 2 * 104</span></span><br><span class="line"><span class="comment">        0 &lt;= height[i] &lt;= 105*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRainWater42</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用栈或双指针的方式来解决</span></span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个指针 left 和 right 分别位于数组的最左端和最右端</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 定义了两个变量 leftMax 和 rightMax 来分别记录左右两侧柱子的最大高度</span></span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> totalWater = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用 while 循环不断更新 left 和 right 指针位置的高度，并计算蓄水量。随着指针移动，最终可以得到能接的雨水总量。</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 哪边低移动哪边指针</span></span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                <span class="comment">// 蓄水量就是左边的最高减去当前高度</span></span><br><span class="line">                totalWater += leftMax - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 蓄水量就是右边的最高减去当前高度</span></span><br><span class="line">                totalWater += rightMax - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该方法的时间复杂度为 O(N)，空间复杂度为 O(1)，只使用了常量级别的额外空间。</span></span><br><span class="line">        <span class="keyword">return</span> totalWater;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] height1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] height2 = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1: &quot;</span> + trap(height1)); <span class="comment">// Output: 6</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2: &quot;</span> + trap(height2)); <span class="comment">// Output: 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-罗马数字转整数-lt-easy-gt"><a href="#13-罗马数字转整数-lt-easy-gt" class="headerlink" title="13. 罗马数字转整数 &lt;easy&gt;"></a>13. 罗马数字转整数 &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        字符          数值</span></span><br><span class="line"><span class="comment">        I             1</span></span><br><span class="line"><span class="comment">        V             5</span></span><br><span class="line"><span class="comment">        X             10</span></span><br><span class="line"><span class="comment">        L             50</span></span><br><span class="line"><span class="comment">        C             100</span></span><br><span class="line"><span class="comment">        D             500</span></span><br><span class="line"><span class="comment">        M             1000</span></span><br><span class="line"><span class="comment">        例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span></span><br><span class="line"><span class="comment">        X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</span></span><br><span class="line"><span class="comment">        C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span></span><br><span class="line"><span class="comment">        给定一个罗马数字，将其转换成整数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;III&quot;</span></span><br><span class="line"><span class="comment">        输出: 3</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;IV&quot;</span></span><br><span class="line"><span class="comment">        输出: 4</span></span><br><span class="line"><span class="comment">        示例 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;IX&quot;</span></span><br><span class="line"><span class="comment">        输出: 9</span></span><br><span class="line"><span class="comment">        示例 4:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;LVIII&quot;</span></span><br><span class="line"><span class="comment">        输出: 58</span></span><br><span class="line"><span class="comment">        解释: L = 50, V= 5, III = 3.</span></span><br><span class="line"><span class="comment">        示例 5:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;MCMXCIV&quot;</span></span><br><span class="line"><span class="comment">        输出: 1994</span></span><br><span class="line"><span class="comment">        解释: M = 1000, CM = 900, XC = 90, IV = 4.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 15</span></span><br><span class="line"><span class="comment">        s 仅含字符 (&#x27;I&#x27;, &#x27;V&#x27;, &#x27;X&#x27;, &#x27;L&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;M&#x27;)</span></span><br><span class="line"><span class="comment">        题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</span></span><br><span class="line"><span class="comment">        题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</span></span><br><span class="line"><span class="comment">        IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</span></span><br><span class="line"><span class="comment">        关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RomanToInteger13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentVal = getValue(s.charAt(i));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextVal = getValue(s.charAt(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (currentVal &lt; nextVal) &#123;</span><br><span class="line">                    <span class="comment">// 表示为特殊情况，需要减去当前的I、X、C</span></span><br><span class="line">                    result -= currentVal;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 普通情况，直接累加</span></span><br><span class="line">                    result += currentVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += currentVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;III&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;IV&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;IX&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;LVIII&quot;</span>;</span><br><span class="line">        String s5 = <span class="string">&quot;MCMXCIV&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1: &quot;</span> + romanToInt(s1)); <span class="comment">// Output: 3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2: &quot;</span> + romanToInt(s2)); <span class="comment">// Output: 4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 3: &quot;</span> + romanToInt(s3)); <span class="comment">// Output: 9</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 4: &quot;</span> + romanToInt(s4)); <span class="comment">// Output: 58</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 5: &quot;</span> + romanToInt(s5)); <span class="comment">// Output: 1994</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-整数转罗马数字-lt-medium-gt-贪心"><a href="#12-整数转罗马数字-lt-medium-gt-贪心" class="headerlink" title="12. 整数转罗马数字  &lt;medium&gt; 贪心"></a>12. 整数转罗马数字  &lt;medium&gt; 贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        字符          数值</span></span><br><span class="line"><span class="comment">        I             1</span></span><br><span class="line"><span class="comment">        V             5</span></span><br><span class="line"><span class="comment">        X             10</span></span><br><span class="line"><span class="comment">        L             50</span></span><br><span class="line"><span class="comment">        C             100</span></span><br><span class="line"><span class="comment">        D             500</span></span><br><span class="line"><span class="comment">        M             1000</span></span><br><span class="line"><span class="comment">        例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span></span><br><span class="line"><span class="comment">        X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</span></span><br><span class="line"><span class="comment">        C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span></span><br><span class="line"><span class="comment">        给你一个整数，将其转为罗马数字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: num = 3</span></span><br><span class="line"><span class="comment">        输出: &quot;III&quot;</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: num = 4</span></span><br><span class="line"><span class="comment">        输出: &quot;IV&quot;</span></span><br><span class="line"><span class="comment">        示例 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: num = 9</span></span><br><span class="line"><span class="comment">        输出: &quot;IX&quot;</span></span><br><span class="line"><span class="comment">        示例 4:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: num = 58</span></span><br><span class="line"><span class="comment">        输出: &quot;LVIII&quot;</span></span><br><span class="line"><span class="comment">        解释: L = 50, V = 5, III = 3.</span></span><br><span class="line"><span class="comment">        示例 5:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: num = 1994</span></span><br><span class="line"><span class="comment">        输出: &quot;MCMXCIV&quot;</span></span><br><span class="line"><span class="comment">        解释: M = 1000, CM = 900, XC = 90, IV = 4.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= num &lt;= 3999*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToRoman12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过一个映射表，将数字和罗马数字对应起来，然后从高位到低位按照规则逐步构造出对应的罗马数字</span></span><br><span class="line">        <span class="comment">//TreeMap&lt;Integer, String&gt; romanMap = new TreeMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//romanMap.put(1, &quot;I&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(4, &quot;IV&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(5, &quot;V&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(9, &quot;IX&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(10, &quot;X&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(40, &quot;XL&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(50, &quot;L&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(90, &quot;XC&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(100, &quot;C&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(400, &quot;CD&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(500, &quot;D&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(900, &quot;CM&quot;);</span></span><br><span class="line">        <span class="comment">//romanMap.put(1000, &quot;M&quot;);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//StringBuilder result = new StringBuilder();</span></span><br><span class="line">        <span class="comment">//for (int value : values) &#123;</span></span><br><span class="line">        <span class="comment">//    while (num &gt;= value) &#123;</span></span><br><span class="line">        <span class="comment">//        result.append(romanMap.get(value));</span></span><br><span class="line">        <span class="comment">//        num -= value;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// O(1)</span></span><br><span class="line">        <span class="comment">//return result.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以采用贪心算法的思路，使用两个数组来存储罗马数字和对应的整数值，然后在循环中不断减去最大的值，将对应的罗马数字拼接起来。</span></span><br><span class="line">        String[] romanSymbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= values[i]) &#123;</span><br><span class="line">                result.append(romanSymbols[i]);</span><br><span class="line">                num -= values[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> num3 = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> num4 = <span class="number">58</span>;</span><br><span class="line">        <span class="keyword">int</span> num5 = <span class="number">1994</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1: &quot;</span> + intToRoman(num1)); <span class="comment">// Output: &quot;III&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2: &quot;</span> + intToRoman(num2)); <span class="comment">// Output: &quot;IV&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 3: &quot;</span> + intToRoman(num3)); <span class="comment">// Output: &quot;IX&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 4: &quot;</span> + intToRoman(num4)); <span class="comment">// Output: &quot;LVIII&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 5: &quot;</span> + intToRoman(num5)); <span class="comment">// Output: &quot;MCMXCIV&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="58-最后一个单词的长度-lt-easy-gt"><a href="#58-最后一个单词的长度-lt-easy-gt" class="headerlink" title="58. 最后一个单词的长度 &lt;easy&gt;"></a>58. 最后一个单词的长度 &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">        输出：5</span></span><br><span class="line"><span class="comment">        解释：最后一个单词是“World”，长度为5。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;   fly me   to   the moon  &quot;</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        解释：最后一个单词是“moon”，长度为4。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;luffy is still joyboy&quot;</span></span><br><span class="line"><span class="comment">        输出：6</span></span><br><span class="line"><span class="comment">        解释：最后一个单词是长度为6的“joyboy”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 104</span></span><br><span class="line"><span class="comment">        s 仅有英文字母和空格 &#x27; &#x27; 组成</span></span><br><span class="line"><span class="comment">        s 中至少存在一个单词*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthOfLastWord58</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>;i &gt; - <span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27; &#x27;</span> != s.charAt(i)) &#123;</span><br><span class="line">                length++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="14-最长公共前缀-lt-easy-gt"><a href="#14-最长公共前缀-lt-easy-gt" class="headerlink" title="14. 最长公共前缀 &lt;easy&gt;"></a>14. 最长公共前缀 &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编写一个函数来查找字符串数组中的最长公共前缀。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果不存在公共前缀，返回空字符串 &quot;&quot;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span></span><br><span class="line"><span class="comment">        输出：&quot;fl&quot;</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span></span><br><span class="line"><span class="comment">        输出：&quot;&quot;</span></span><br><span class="line"><span class="comment">        解释：输入不存在公共前缀。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= strs.length &lt;= 200</span></span><br><span class="line"><span class="comment">        0 &lt;= strs[i].length &lt;= 200</span></span><br><span class="line"><span class="comment">        strs[i] 仅由小写英文字母组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestCommonPrefix14</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以采用横向比较的方法</span></span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个字符串设为最长公共前缀，然后逐个与后面的字符串进行比较</span></span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">                prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prefix.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个算法的时间复杂度是 O(nm)，其中 n 是字符串数组的长度，m 是字符串数组中的字符串的平均长度</span></span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] test1 = &#123;<span class="string">&quot;flower&quot;</span>, <span class="string">&quot;flow&quot;</span>, <span class="string">&quot;flight&quot;</span>&#125;;</span><br><span class="line">        String[] test2 = &#123;<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;racecar&quot;</span>, <span class="string">&quot;car&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1: &quot;</span> + longestCommonPrefix(test1)); <span class="comment">// Output: &quot;fl&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2: &quot;</span> + longestCommonPrefix(test2)); <span class="comment">// Output: &quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="151-反转字符串中的单词-lt-medium-gt"><a href="#151-反转字符串中的单词-lt-medium-gt" class="headerlink" title="151. 反转字符串中的单词  &lt;medium&gt;"></a>151. 反转字符串中的单词  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个字符串 s ，请你反转字符串中 单词 的顺序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;the sky is blue&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;blue is sky the&quot;</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;  hello world  &quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;world hello&quot;</span></span><br><span class="line"><span class="comment">        解释：反转后的字符串中不能存在前导空格和尾随空格。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;a good   example&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;example good a&quot;</span></span><br><span class="line"><span class="comment">        解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 104</span></span><br><span class="line"><span class="comment">        s 包含英文大小写字母、数字和空格 &#x27; &#x27;</span></span><br><span class="line"><span class="comment">        s 中 至少存在一个 单词</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseWordsInAString151</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//// 去除字符串首尾空格，并用空格分割成单词数组</span></span><br><span class="line">        <span class="comment">//String[] words = s.trim().split(&quot;\\s+&quot;);</span></span><br><span class="line">        <span class="comment">//StringBuilder result = new StringBuilder();</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// 从后往前拼接单词</span></span><br><span class="line">        <span class="comment">//for (int i = words.length - 1; i &gt;= 0; i--) &#123;</span></span><br><span class="line">        <span class="comment">//    result.append(words[i]).append(&quot; &quot;);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// 删除最后一个多余的空格</span></span><br><span class="line">        <span class="comment">//return result.toString().trim();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = s.length();</span><br><span class="line"></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以从字符串末尾开始遍历，找到每个单词的起始和结束位置，然后将其拼接到结果字符串上</span></span><br><span class="line">        <span class="keyword">while</span> (start &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[start] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end = start;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == <span class="number">0</span> || str[start - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    result.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                result.append(s, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">            start--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String test1 = <span class="string">&quot;the sky is blue&quot;</span>;</span><br><span class="line">        String test2 = <span class="string">&quot;  hello world  &quot;</span>;</span><br><span class="line">        String test3 = <span class="string">&quot;a good   example&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1: &quot;</span> + reverseWords(test1)); <span class="comment">// Output: &quot;blue is sky the&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2: &quot;</span> + reverseWords(test2)); <span class="comment">// Output: &quot;world hello&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 3: &quot;</span> + reverseWords(test3)); <span class="comment">// Output: &quot;example good a&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-N-字形变换-lt-medium-gt"><a href="#6-N-字形变换-lt-medium-gt" class="headerlink" title="6. N 字形变换  &lt;medium&gt;"></a>6. N 字形变换  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        P   A   H   N</span></span><br><span class="line"><span class="comment">        A P L S I I G</span></span><br><span class="line"><span class="comment">        Y   I   R</span></span><br><span class="line"><span class="comment">        之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请你实现这个将字符串进行指定行数变换的函数：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        string convert(string s, int numRows);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span></span><br><span class="line"><span class="comment">        输出：&quot;PAHNAPLSIIGYIR&quot;</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment">        输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span></span><br><span class="line"><span class="comment">        输出：&quot;PINALSIGYAHRPI&quot;</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        P     I    N</span></span><br><span class="line"><span class="comment">        A   L S  I G</span></span><br><span class="line"><span class="comment">        Y A   H R</span></span><br><span class="line"><span class="comment">        P     I</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;A&quot;, numRows = 1</span></span><br><span class="line"><span class="comment">        输出：&quot;A&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 1000</span></span><br><span class="line"><span class="comment">        s 由英文字母（小写和大写）、&#x27;,&#x27; 和 &#x27;.&#x27; 组成</span></span><br><span class="line"><span class="comment">        1 &lt;= numRows &lt;= 1000*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZigzagConversion6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span> || s.length() &lt;= numRows) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义 numRows 个字符串来存储 Z 字形中的每一行</span></span><br><span class="line">        StringBuilder[] rows = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            rows[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> goingDown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后遍历输入字符串，根据当前字符应该位于 Z 字形的哪一行，将字符添加到对应的行中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 将当前 row 对应字符 c 添加到字符串构建器中</span></span><br><span class="line">            rows[row].append(c);</span><br><span class="line">            <span class="comment">// 判断当前字符是否位于 Z 字形的顶部或底部。若是，则需要改变遍历方向，即从上往下或从下往上</span></span><br><span class="line">            <span class="keyword">if</span> (row == <span class="number">0</span> || row == numRows - <span class="number">1</span>) &#123;</span><br><span class="line">                goingDown = !goingDown;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据 goingDown 的值，确定当前字符在 Z 字形中下一个位置的行数，若 goingDown 为 true，则向下移动一行；否则向上移动一行</span></span><br><span class="line">            row += goingDown ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后按照行的顺序将这些行连接起来，就是最终的结果。</span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder stringBuilder : rows) &#123;</span><br><span class="line">            result.append(stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String test1 = <span class="string">&quot;PAYPALISHIRING&quot;</span>;</span><br><span class="line">        String test2 = <span class="string">&quot;PAYPALISHIRING&quot;</span>;</span><br><span class="line">        String test3 = <span class="string">&quot;A&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 1: &quot;</span> + convert(test1, <span class="number">3</span>)); <span class="comment">// Output: &quot;PAHNAPLSIIGYIR&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 2: &quot;</span> + convert(test2, <span class="number">4</span>)); <span class="comment">// Output: &quot;PINALSIGYAHRPI&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Test Case 3: &quot;</span> + convert(test3, <span class="number">1</span>)); <span class="comment">// Output: &quot;A&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="28-找出字符串中第一个匹配项的下标-lt-easy-gt"><a href="#28-找出字符串中第一个匹配项的下标-lt-easy-gt" class="headerlink" title="28. 找出字符串中第一个匹配项的下标 &lt;easy&gt;"></a>28. 找出字符串中第一个匹配项的下标 &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment">        解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span></span><br><span class="line"><span class="comment">        第一个匹配项的下标是 0 ，所以返回 0 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span></span><br><span class="line"><span class="comment">        输出：-1</span></span><br><span class="line"><span class="comment">        解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= haystack.length, needle.length &lt;= 104</span></span><br><span class="line"><span class="comment">        haystack 和 needle 仅由小写英文字符组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindTheIndexOfTheFirstOccurrenceInAString28</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hayLength = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> needleLength = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (needleLength == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历 haystack 字符串并查找 needle 字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= hayLength - needleLength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; needleLength &amp;&amp; haystack.charAt(i + j) == needle.charAt(j)) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == needleLength) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n⋅m) O(1)</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String haystack1 = <span class="string">&quot;sadbutsad&quot;</span>;</span><br><span class="line">        String needle1 = <span class="string">&quot;sad&quot;</span>;</span><br><span class="line">        System.out.println(strStr(haystack1, needle1)); <span class="comment">// 输出: 0</span></span><br><span class="line"></span><br><span class="line">        String haystack2 = <span class="string">&quot;leetcode&quot;</span>;</span><br><span class="line">        String needle2 = <span class="string">&quot;leeto&quot;</span>;</span><br><span class="line">        System.out.println(strStr(haystack2, needle2)); <span class="comment">// 输出: -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="68-文本左右对齐-lt-hard-gt-贪心"><a href="#68-文本左右对齐-lt-hard-gt-贪心" class="headerlink" title="68. 文本左右对齐  &lt;hard&gt; 贪心"></a>68. 文本左右对齐  &lt;hard&gt; 贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 &#x27; &#x27; 填充，使得每行恰好有 maxWidth 个字符。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        文本的最后一行应为左对齐，且单词之间不插入额外的空格。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        单词是指由非空格字符组成的字符序列。</span></span><br><span class="line"><span class="comment">        每个单词的长度大于 0，小于等于 maxWidth。</span></span><br><span class="line"><span class="comment">        输入单词数组 words 至少包含一个单词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">        &quot;This    is    an&quot;,</span></span><br><span class="line"><span class="comment">        &quot;example  of text&quot;,</span></span><br><span class="line"><span class="comment">        &quot;justification.  &quot;</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入:words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">        &quot;What   must   be&quot;,</span></span><br><span class="line"><span class="comment">        &quot;acknowledgment  &quot;,</span></span><br><span class="line"><span class="comment">        &quot;shall be        &quot;</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">        解释: 注意最后一行的格式应为 &quot;shall be    &quot; 而不是 &quot;shall     be&quot;,</span></span><br><span class="line"><span class="comment">        因为最后一行应为左对齐，而不是左右两端对齐。</span></span><br><span class="line"><span class="comment">        第二行同样为左对齐，这是因为这行只包含一个单词。</span></span><br><span class="line"><span class="comment">        示例 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入:words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]，maxWidth = 20</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">        &quot;Science  is  what we&quot;,</span></span><br><span class="line"><span class="comment">        &quot;understand      well&quot;,</span></span><br><span class="line"><span class="comment">        &quot;enough to explain to&quot;,</span></span><br><span class="line"><span class="comment">        &quot;a  computer.  Art is&quot;,</span></span><br><span class="line"><span class="comment">        &quot;everything  else  we&quot;,</span></span><br><span class="line"><span class="comment">        &quot;do                  &quot;</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= words.length &lt;= 300</span></span><br><span class="line"><span class="comment">        1 &lt;= words[i].length &lt;= 20</span></span><br><span class="line"><span class="comment">        words[i] 由小写英文字母和符号组成</span></span><br><span class="line"><span class="comment">        1 &lt;= maxWidth &lt;= 100</span></span><br><span class="line"><span class="comment">        words[i].length &lt;= maxWidth*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextJustification68</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">fullJustify</span><span class="params">(String[] words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 贪心算法</span></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 单词索引</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历单词列表</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; words.length) &#123;</span><br><span class="line">            <span class="comment">// 当前行长度</span></span><br><span class="line">            <span class="keyword">int</span> lineLength = words[index].length();</span><br><span class="line">            <span class="comment">// 下一个单词索引</span></span><br><span class="line">            <span class="keyword">int</span> lastWordIndex = index + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每行中尽可能多地放置单词，且不超过最大宽度</span></span><br><span class="line">            <span class="keyword">while</span> (lastWordIndex &lt; words.length &amp;&amp; lineLength + <span class="number">1</span> + words[lastWordIndex].length() &lt;= maxWidth) &#123;</span><br><span class="line">                <span class="comment">// 更新当前行长度</span></span><br><span class="line">                lineLength += <span class="number">1</span> + words[lastWordIndex].length();</span><br><span class="line">                <span class="comment">// 移至下一个单词</span></span><br><span class="line">                lastWordIndex++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用StringBuilder构建当前行</span></span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">// 当前行单词间隔数</span></span><br><span class="line">            <span class="keyword">int</span> diff = lastWordIndex - index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lastWordIndex == words.length || diff == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 最后一行或只有一个单词的行，用空格补充</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; lastWordIndex; i++) &#123;</span><br><span class="line">                    builder.append(words[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                builder.deleteCharAt(builder.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (builder.length() &lt; maxWidth) &#123;</span><br><span class="line">                    builder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 平均空格数</span></span><br><span class="line">                <span class="keyword">int</span> spaces = (maxWidth - lineLength) / diff;</span><br><span class="line">                <span class="comment">// 额外的空格</span></span><br><span class="line">                <span class="keyword">int</span> extraSpaces = (maxWidth - lineLength) % diff;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在每个单词之间均匀分配空格</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; lastWordIndex - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                    builder.append(words[i]);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= spaces + (i - index &lt; extraSpaces ? <span class="number">1</span> : <span class="number">0</span>); j++) &#123;</span><br><span class="line">                        builder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 添加最后一个单词</span></span><br><span class="line">                builder.append(words[lastWordIndex - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.add(builder.toString());</span><br><span class="line">            <span class="comment">// 更新单词索引为下一个行的单词索引</span></span><br><span class="line">            index = lastWordIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] words1 = &#123;<span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;example&quot;</span>, <span class="string">&quot;of&quot;</span>, <span class="string">&quot;text&quot;</span>, <span class="string">&quot;justification.&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxWidth1 = <span class="number">16</span>;</span><br><span class="line">        System.out.println(fullJustify(words1, maxWidth1));</span><br><span class="line"></span><br><span class="line">        String[] words2 = &#123;<span class="string">&quot;What&quot;</span>, <span class="string">&quot;must&quot;</span>, <span class="string">&quot;be&quot;</span>, <span class="string">&quot;acknowledgment&quot;</span>, <span class="string">&quot;shall&quot;</span>, <span class="string">&quot;be&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxWidth2 = <span class="number">16</span>;</span><br><span class="line">        System.out.println(fullJustify(words2, maxWidth2));</span><br><span class="line"></span><br><span class="line">        String[] words3 = &#123;<span class="string">&quot;Science&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;what&quot;</span>, <span class="string">&quot;we&quot;</span>, <span class="string">&quot;understand&quot;</span>, <span class="string">&quot;well&quot;</span>, <span class="string">&quot;enough&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;explain&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;computer.&quot;</span>, <span class="string">&quot;Art&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;everything&quot;</span>, <span class="string">&quot;else&quot;</span>, <span class="string">&quot;we&quot;</span>, <span class="string">&quot;do&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxWidth3 = <span class="number">20</span>;</span><br><span class="line">        System.out.println(fullJustify(words3, maxWidth3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-双指针-Two-Pointers"><a href="#3-2-双指针-Two-Pointers" class="headerlink" title="3.2 双指针 Two Pointers"></a>3.2 双指针 Two Pointers</h3><p>使用两个指针在一次遍历中解决问题</p>
<ol>
<li>对撞指针：从数组两端移动指针，寻找满足条件的元素。如找到两数之和、反转链表、回文判断等</li>
<li>快慢指针：用两个不同速度的指针遍历，通常用于检测环形链表、寻找中间节点等</li>
</ol>
<h4 id="125-验证回文串-lt-easy-gt"><a href="#125-验证回文串-lt-easy-gt" class="headerlink" title="125. 验证回文串  &lt;easy&gt;"></a>125. 验证回文串  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        字母和数字都属于字母数字字符。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;A man, a plan, a canal: Panama&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        解释：&quot;amanaplanacanalpanama&quot; 是回文串。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;race a car&quot;</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        解释：&quot;raceacar&quot; 不是回文串。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot; &quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        解释：在移除非字母数字字符之后，s 是一个空字符串 &quot;&quot; 。</span></span><br><span class="line"><span class="comment">        由于空字符串正着反着读都一样，所以是回文串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 2 * 105</span></span><br><span class="line"><span class="comment">        s 仅由可打印的 ASCII 字符组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidPalindrome125</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 非字母和数字，直接跳过</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left))) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right))) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左右指针不相同，直接判定不符</span></span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历全部都相等</span></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>;</span><br><span class="line">        System.out.println(isPalindrome(s1)); <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        String s2 = <span class="string">&quot;race a car&quot;</span>;</span><br><span class="line">        System.out.println(isPalindrome(s2)); <span class="comment">// Output: false</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        System.out.println(isPalindrome(s3)); <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="392-判断子序列-lt-easy-gt"><a href="#392-判断子序列-lt-easy-gt" class="headerlink" title="392. 判断子序列  &lt;easy&gt;"></a>392. 判断子序列  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        致谢：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        特别感谢 @pbrother 添加此问题并且创建所有测试用例。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= s.length &lt;= 100</span></span><br><span class="line"><span class="comment">        0 &lt;= t.length &lt;= 10^4</span></span><br><span class="line"><span class="comment">        两个字符串都只由小写字符组成。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsSubsequence392</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sPointer = <span class="number">0</span>, tPointer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环直到某一个字符串遍历结束</span></span><br><span class="line">        <span class="keyword">while</span> (sPointer &lt; s.length() &amp;&amp; tPointer &lt; t.length()) &#123;</span><br><span class="line">            <span class="comment">// 如果两个字符相等，移动 s 的指针</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(sPointer) == t.charAt(tPointer)) &#123;</span><br><span class="line">                sPointer++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不管相等与否，移动 t 的指针</span></span><br><span class="line">            tPointer++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 s 遍历结束，说明 s 是 t 的子序列</span></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> sPointer == s.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>, t1 = <span class="string">&quot;ahbgdc&quot;</span>;</span><br><span class="line">        System.out.println(isSubsequence(s1, t1)); <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        String s2 = <span class="string">&quot;axc&quot;</span>, t2 = <span class="string">&quot;ahbgdc&quot;</span>;</span><br><span class="line">        System.out.println(isSubsequence(s2, t2)); <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="167-两数之和-II-输入有序数组-lt-medium-gt"><a href="#167-两数之和-II-输入有序数组-lt-medium-gt" class="headerlink" title="167. 两数之和 II - 输入有序数组  &lt;medium&gt;"></a>167. 两数之和 II - 输入有序数组  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你所设计的解决方案必须只使用常量级的额外空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：numbers = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment">        输出：[1,2]</span></span><br><span class="line"><span class="comment">        解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：numbers = [2,3,4], target = 6</span></span><br><span class="line"><span class="comment">        输出：[1,3]</span></span><br><span class="line"><span class="comment">        解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：numbers = [-1,0], target = -1</span></span><br><span class="line"><span class="comment">        输出：[1,2]</span></span><br><span class="line"><span class="comment">        解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2 &lt;= numbers.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">        -1000 &lt;= numbers[i] &lt;= 1000</span></span><br><span class="line"><span class="comment">        numbers 按 非递减顺序 排列</span></span><br><span class="line"><span class="comment">        -1000 &lt;= target &lt;= 1000</span></span><br><span class="line"><span class="comment">        仅存在一个有效答案*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSumIIInputArrayIsSorted167</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="comment">// 题目要求索引从 1 开始，所以加 1 返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 如果和小于目标值，增加左指针以增加和</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果和大于目标值，减少右指针以减少和</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找不到符合条件的数对</span></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers1 = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target1 = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result1 = twoSum(numbers1, target1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result 1: [&quot;</span> + result1[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + result1[<span class="number">1</span>] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] numbers2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target2 = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result2 = twoSum(numbers2, target2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result 2: [&quot;</span> + result2[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + result2[<span class="number">1</span>] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] numbers3 = &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target3 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result3 = twoSum(numbers3, target3);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result 3: [&quot;</span> + result3[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + result3[<span class="number">1</span>] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-盛最多水的容器-lt-medium-gt"><a href="#11-盛最多水的容器-lt-medium-gt" class="headerlink" title="11. 盛最多水的容器  &lt;medium&gt;"></a>11. 盛最多水的容器  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        返回容器可以储存的最大水量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        说明：你不能倾斜容器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：[1,8,6,2,5,4,8,3,7]</span></span><br><span class="line"><span class="comment">        输出：49</span></span><br><span class="line"><span class="comment">        解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：height = [1,1]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        n == height.length</span></span><br><span class="line"><span class="comment">        2 &lt;= n &lt;= 105</span></span><br><span class="line"><span class="comment">        0 &lt;= height[i] &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerWithMostWater11</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentArea = Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">            <span class="comment">// 记录历史最大面积</span></span><br><span class="line">            maxArea = Math.max(maxArea, currentArea);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 哪边低移动哪边</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] heights1 = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Max area for heights1: &quot;</span> + maxArea(heights1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] heights2 = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Max area for heights2: &quot;</span> + maxArea(heights2));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] heights3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Max area for heights3: &quot;</span> + maxArea(heights3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="15-三数之和-lt-medium-gt"><a href="#15-三数之和-lt-medium-gt" class="headerlink" title="15. 三数之和  &lt;medium&gt;"></a>15. 三数之和  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你返回所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [-1,0,1,2,-1,-4]</span></span><br><span class="line"><span class="comment">        输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span></span><br><span class="line"><span class="comment">        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">        不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span></span><br><span class="line"><span class="comment">        注意，输出的顺序和三元组的顺序并不重要。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,1,1]</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment">        解释：唯一可能的三元组和不为 0 。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,0,0]</span></span><br><span class="line"><span class="comment">        输出：[[0,0,0]]</span></span><br><span class="line"><span class="comment">        解释：唯一可能的三元组和为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3 &lt;= nums.length &lt;= 3000</span></span><br><span class="line"><span class="comment">        -105 &lt;= nums[i] &lt;= 105*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSum15</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外层遍历固定一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 里层遍历，用双指针找另外两个数</span></span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 命中</span></span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 跳过重复元素</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 和小于0，则往右移</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n^2)，空间复杂度为 O(log n) 到 O(n)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreeSum15 solution = <span class="keyword">new</span> ThreeSum15();</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(solution.threeSum(nums1)); <span class="comment">// Output: [[-1, -1, 2], [-1, 0, 1]]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(solution.threeSum(nums2)); <span class="comment">// Output: []</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(solution.threeSum(nums3)); <span class="comment">// Output: [[0, 0, 0]]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-滑动窗口-Sliding-Window"><a href="#3-3-滑动窗口-Sliding-Window" class="headerlink" title="3.3 滑动窗口 Sliding Window"></a>3.3 滑动窗口 Sliding Window</h3><p>（双指针变形）使用两个指针定义一个窗口，通过移动右指针扩大窗口，移动左指针缩小窗口</p>
<ol>
<li>找到满足条件的数组（字符串）的最大/最小子数组（子串）</li>
<li>给定数组移动固定大小窗口，查找其中的固定值</li>
</ol>
<h4 id="209-长度最小的子数组-lt-medium-gt"><a href="#209-长度最小的子数组-lt-medium-gt" class="headerlink" title="209. 长度最小的子数组  &lt;medium&gt;"></a>209. 长度最小的子数组  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个含有 n 个正整数的数组和一个正整数 target 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：target = 7, nums = [2,3,1,2,4,3]</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：target = 4, nums = [1,4,4]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= target &lt;= 10^9</span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 10^5</span></span><br><span class="line"><span class="comment">        1 &lt;= nums[i] &lt;= 10^5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumSizeSubarraySum209</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 双指针，left和right分别表示滑动窗口的边界</span></span><br><span class="line">        <span class="comment">//int left = 0;</span></span><br><span class="line">        <span class="comment">//int sum = 0;</span></span><br><span class="line">        <span class="comment">//int minLength = Integer.MAX_VALUE;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//for (int right = 0; right &lt; nums.length; right++) &#123;</span></span><br><span class="line">        <span class="comment">//    // 先连续相加，直到窗口内的总和大于等于目标值</span></span><br><span class="line">        <span class="comment">//    sum += nums[right];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//    // 然后记录窗口的大小，并缩小窗口</span></span><br><span class="line">        <span class="comment">//    while (sum &gt;= target) &#123;</span></span><br><span class="line">        <span class="comment">//        minLength = Math.min(minLength, right - left + 1);</span></span><br><span class="line">        <span class="comment">//        // 减去左边界的元素看看是否仍然符合要求</span></span><br><span class="line">        <span class="comment">//        sum -= nums[left];</span></span><br><span class="line">        <span class="comment">//        left++;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//    // sum减到不再大于目标值时，再继续向右移动右边界</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">////  O(n)</span></span><br><span class="line">        <span class="comment">//return minLength == Integer.MAX_VALUE ? 0 : minLength;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.使用二分查找和前缀和</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护一个前缀和数组</span></span><br><span class="line">        <span class="keyword">int</span>[] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 遍历一次数组，每个元素都是前面元素的和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            prefixSum[i] = prefixSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 遍历前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过二分查找在前面已计算的前缀和中寻找一个位置，使得两个前缀和之差满足条件</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = prefixSum[i] - prefixSum[mid];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                    minLen = Math.min(minLen, i - mid);</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n log(n))</span></span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinimumSizeSubarraySum209 solution = <span class="keyword">new</span> MinimumSizeSubarraySum209();</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target1 = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> target2 = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> target3 = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(solution.minSubArrayLen(target1, nums1)); <span class="comment">// Output: 2</span></span><br><span class="line">        System.out.println(solution.minSubArrayLen(target2, nums2)); <span class="comment">// Output: 1</span></span><br><span class="line">        System.out.println(solution.minSubArrayLen(target3, nums3)); <span class="comment">// Output: 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-无重复字符的最长子串-lt-medium-gt"><a href="#3-无重复字符的最长子串-lt-medium-gt" class="headerlink" title="3. 无重复字符的最长子串  &lt;medium&gt;"></a>3. 无重复字符的最长子串  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="comment">        输出: 3</span></span><br><span class="line"><span class="comment">        解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="comment">        输出: 1</span></span><br><span class="line"><span class="comment">        解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br><span class="line"><span class="comment">        示例 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="comment">        输出: 3</span></span><br><span class="line"><span class="comment">        解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line"><span class="comment">        请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= s.length &lt;= 5 * 104</span></span><br><span class="line"><span class="comment">        s 由英文字母、数字、符号和空格组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringWithoutRepeatingCharacters3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 滑动窗口左右边界</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 通过哈希集合来存放窗口内的元素</span></span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(right))) &#123;</span><br><span class="line">                <span class="comment">// 右指针右移，将元素加入set</span></span><br><span class="line">                set.add(s.charAt(right++));</span><br><span class="line">                <span class="comment">// 更新最大长度</span></span><br><span class="line">                maxLen = Math.max(maxLen, set.size());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右指针指到重复元素，尝试移除左指针元素直到清除干净重复元素</span></span><br><span class="line">                set.remove(s.charAt(left++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abcabcbb&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;bbbbb&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;pwwkew&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Length of longest substring without repeating characters in s1: &quot;</span> + lengthOfLongestSubstring(s1)); <span class="comment">// Output: 3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Length of longest substring without repeating characters in s2: &quot;</span> + lengthOfLongestSubstring(s2)); <span class="comment">// Output: 1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Length of longest substring without repeating characters in s3: &quot;</span> + lengthOfLongestSubstring(s3)); <span class="comment">// Output: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="30-串联所有单词的子串-lt-hard-gt"><a href="#30-串联所有单词的子串-lt-hard-gt" class="headerlink" title="30. 串联所有单词的子串  &lt;hard&gt;"></a>30. 串联所有单词的子串  &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        例如，如果 words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]， 那么 &quot;abcdef&quot;， &quot;abefcd&quot;，&quot;cdabef&quot;， &quot;cdefab&quot;，&quot;efabcd&quot;， 和 &quot;efcdab&quot; 都是串联子串。 &quot;acdbef&quot; 不是串联子串，因为他不是任何 words 排列的连接。</span></span><br><span class="line"><span class="comment">        返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</span></span><br><span class="line"><span class="comment">        输出：[0,9]</span></span><br><span class="line"><span class="comment">        解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。</span></span><br><span class="line"><span class="comment">        子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。</span></span><br><span class="line"><span class="comment">        子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</span></span><br><span class="line"><span class="comment">        输出顺序无关紧要。返回 [9,0] 也是可以的。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment">        解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。</span></span><br><span class="line"><span class="comment">        s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。</span></span><br><span class="line"><span class="comment">        所以我们返回一个空数组。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]</span></span><br><span class="line"><span class="comment">        输出：[6,9,12]</span></span><br><span class="line"><span class="comment">        解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。</span></span><br><span class="line"><span class="comment">        子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。</span></span><br><span class="line"><span class="comment">        子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。</span></span><br><span class="line"><span class="comment">        子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 10^4</span></span><br><span class="line"><span class="comment">        1 &lt;= words.length &lt;= 5000</span></span><br><span class="line"><span class="comment">        1 &lt;= words[i].length &lt;= 30</span></span><br><span class="line"><span class="comment">        words[i] 和 s 由小写英文字母组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubstringWithConcatenationOfAllWords30</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        if (s.isEmpty() || words.length == 0) return result;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int wordLen = words[0].length();</span></span><br><span class="line"><span class="comment">        int wordCount = words.length;</span></span><br><span class="line"><span class="comment">        int totalLen = wordLen * wordCount;</span></span><br><span class="line"><span class="comment">        // 哈希表存储拆分的words每个单词和出现次数，已知word可以重复</span></span><br><span class="line"><span class="comment">        HashMap&lt;String, Integer&gt; wordCountMap = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 初始化哈希表</span></span><br><span class="line"><span class="comment">        for (String word : words) &#123;</span></span><br><span class="line"><span class="comment">            wordCountMap.put(word, wordCountMap.getOrDefault(word, 0) + 1);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 遍历字符串</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt;= s.length() - totalLen; i++) &#123;</span></span><br><span class="line"><span class="comment">            // 存储当前子串中出现的单词和次数</span></span><br><span class="line"><span class="comment">            HashMap&lt;String, Integer&gt; wordSeen = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">            // j指针右移，命中一个单词则记录一个，没命中或者出现次数超出则不符合</span></span><br><span class="line"><span class="comment">            int j = 0;</span></span><br><span class="line"><span class="comment">            while (j &lt; wordCount) &#123;</span></span><br><span class="line"><span class="comment">                // 拆出单词</span></span><br><span class="line"><span class="comment">                String word = s.substring(i + j * wordLen, i + (j + 1) * wordLen);</span></span><br><span class="line"><span class="comment">                if (wordCountMap.containsKey(word)) &#123;</span></span><br><span class="line"><span class="comment">                    // 记录出现次数</span></span><br><span class="line"><span class="comment">                    wordSeen.put(word, wordSeen.getOrDefault(word, 0) + 1);</span></span><br><span class="line"><span class="comment">                    if (wordSeen.get(word) &gt; wordCountMap.getOrDefault(word, 0)) &#123;</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125; else &#123;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                j++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            // 循环结束刚好符合，则记录起始下标</span></span><br><span class="line"><span class="comment">            if (j == wordCount) &#123;</span></span><br><span class="line"><span class="comment">                result.add(i);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // O(n * m) O(m)</span></span><br><span class="line"><span class="comment">        return result;*/</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty() || words.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wordLen = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> wordCount = words.length;</span><br><span class="line">        <span class="comment">// 哈希表存储拆分的words每个单词和出现次数，已知word可以重复</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; wordCountMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            wordCountMap.put(word, wordCountMap.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordLen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i, right = i, count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 存储当前子串中出现的单词和次数</span></span><br><span class="line">            HashMap&lt;String, Integer&gt; wordSeen = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 通过滑动窗口</span></span><br><span class="line">            <span class="keyword">while</span> (right + wordLen &lt;= s.length()) &#123;</span><br><span class="line">                String word = s.substring(right, right + wordLen);</span><br><span class="line">                right += wordLen;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (wordCountMap.containsKey(word)) &#123;</span><br><span class="line">                    wordSeen.put(word, wordSeen.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前单词出现次数已超过，则移动左指针，直到满足条件</span></span><br><span class="line">                    <span class="keyword">while</span> (wordSeen.getOrDefault(word, <span class="number">0</span>) &gt; wordCountMap.getOrDefault(word, <span class="number">0</span>)) &#123;</span><br><span class="line">                        String leftWord = s.substring(left, left + wordLen);</span><br><span class="line">                        count--;</span><br><span class="line">                        wordSeen.put(leftWord, wordSeen.get(leftWord) - <span class="number">1</span>);</span><br><span class="line">                        left += wordLen;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (count == wordCount) &#123;</span><br><span class="line">                        result.add(left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    wordSeen.clear();</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    left = right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n) O(m)</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;barfoothefoobarman&quot;</span>;</span><br><span class="line">        String[] words1 = &#123;<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String s2 = <span class="string">&quot;wordgoodgoodgoodbestword&quot;</span>;</span><br><span class="line">        String[] words2 = &#123;<span class="string">&quot;word&quot;</span>,<span class="string">&quot;good&quot;</span>,<span class="string">&quot;best&quot;</span>,<span class="string">&quot;word&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;barfoofoobarthefoobarman&quot;</span>;</span><br><span class="line">        String[] words3 = &#123;<span class="string">&quot;bar&quot;</span>,<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Substring indices in s1: &quot;</span> + findSubstring(s1, words1)); <span class="comment">// Output: [0, 9]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Substring indices in s2: &quot;</span> + findSubstring(s2, words2)); <span class="comment">// Output: []</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Substring indices in s3: &quot;</span> + findSubstring(s3, words3)); <span class="comment">// Output: [6, 9, 12]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="76-最小覆盖子串-lt-hard-gt"><a href="#76-最小覆盖子串-lt-hard-gt" class="headerlink" title="76. 最小覆盖子串  &lt;hard&gt;"></a>76. 最小覆盖子串  &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</span></span><br><span class="line"><span class="comment">        如果 s 中存在这样的子串，我们保证它是唯一的答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;BANC&quot;</span></span><br><span class="line"><span class="comment">        解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;a&quot;, t = &quot;a&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;a&quot;</span></span><br><span class="line"><span class="comment">        解释：整个字符串 s 是最小覆盖子串。</span></span><br><span class="line"><span class="comment">        示例 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;a&quot;, t = &quot;aa&quot;</span></span><br><span class="line"><span class="comment">        输出: &quot;&quot;</span></span><br><span class="line"><span class="comment">        解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span></span><br><span class="line"><span class="comment">        因此没有符合条件的子字符串，返回空字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == s.length</span></span><br><span class="line"><span class="comment">        n == t.length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 105</span></span><br><span class="line"><span class="comment">        s 和 t 由英文字母组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumWindowSubstring76</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || t.length() == <span class="number">0</span> || s.length() &lt; t.length()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 拆分字符串t</span></span><br><span class="line">        Map&lt;Character, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">////可以优化Map为集合来提高运行速度</span></span><br><span class="line">        <span class="comment">// int[] tCount = new int[128];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : t.toCharArray()) &#123;</span><br><span class="line">            countMap.put(ch, countMap.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> required = countMap.size();</span><br><span class="line">        <span class="keyword">int</span> formed = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; windowMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// int[] windowCount = new int[128];</span></span><br><span class="line">        <span class="comment">// 使用右边界指针遍历字符串s</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(right);</span><br><span class="line">            <span class="comment">// windowCount[ch]++;</span></span><br><span class="line">            windowMap.put(ch, windowMap.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (tCount[ch] &gt; 0 &amp;&amp; windowCount[ch] &lt;= tCount[ch]) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (countMap.containsKey(ch) &amp;&amp; windowMap.get(ch).intValue() == countMap.get(ch).intValue()) &#123;</span><br><span class="line">                <span class="comment">// 当前字符已全部命中</span></span><br><span class="line">                formed++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当字符全部命中后，开始移动左指针尝试删除</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; formed == required) &#123;</span><br><span class="line">                ch = s.charAt(left);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 先更新当前最短字符串长度</span></span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; right - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minLen = right - left + <span class="number">1</span>;</span><br><span class="line">                    minStart = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//windowCount[ch]--;</span></span><br><span class="line">                <span class="comment">//if (tCount[ch] &gt; 0 &amp;&amp; windowCount[ch] &lt; tCount[ch]) &#123;</span></span><br><span class="line">                <span class="comment">// 移除左边界元素</span></span><br><span class="line">                windowMap.put(ch, windowMap.get(ch) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (countMap.containsKey(ch) &amp;&amp; windowMap.get(ch) &lt; countMap.get(ch)) &#123;</span><br><span class="line">                    <span class="comment">// 若删错元素，则formed-1，继续右移右边界</span></span><br><span class="line">                    formed--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 删除成功，继续移动左边界</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n) O(m + n)</span></span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(minStart, minStart + minLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;ADOBECODEBANC&quot;</span>;</span><br><span class="line">        String t1 = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">        System.out.println(minWindow(s1, t1)); <span class="comment">// Output: &quot;BANC&quot;</span></span><br><span class="line"></span><br><span class="line">        String s2 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String t2 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        System.out.println(minWindow(s2, t2)); <span class="comment">// Output: &quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String t3 = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">        System.out.println(minWindow(s3, t3)); <span class="comment">// Output: &quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="3-4-矩阵-Matrix"><a href="#3-4-矩阵-Matrix" class="headerlink" title="3.4 矩阵 Matrix"></a>3.4 矩阵 Matrix</h3><p>多维数组</p>
<h4 id="36-有效的数独-lt-medium-gt"><a href="#36-有效的数独-lt-medium-gt" class="headerlink" title="36. 有效的数独  &lt;medium&gt;"></a>36. 有效的数独  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        数字 1-9 在每一行只能出现一次。</span></span><br><span class="line"><span class="comment">        数字 1-9 在每一列只能出现一次。</span></span><br><span class="line"><span class="comment">        数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        一个有效的数独（部分已被填充）不一定是可解的。</span></span><br><span class="line"><span class="comment">        只需要根据以上规则，验证已经填入的数字是否有效即可。</span></span><br><span class="line"><span class="comment">        空白格用 &#x27;.&#x27; 表示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board =</span></span><br><span class="line"><span class="comment">        [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board =</span></span><br><span class="line"><span class="comment">        [[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span></span><br><span class="line"><span class="comment">        ,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        board.length == 9</span></span><br><span class="line"><span class="comment">        board[i].length == 9</span></span><br><span class="line"><span class="comment">        board[i][j] 是一位数字（1-9）或者 &#x27;.&#x27;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidSudoku36</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length != <span class="number">9</span> || board[<span class="number">0</span>].length != <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 分别用数组记录数字是否出现过</span></span><br><span class="line">            <span class="keyword">boolean</span>[] rowSeen = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line">            <span class="keyword">boolean</span>[] colSeen = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 行检测</span></span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (rowSeen[num]) &#123;</span><br><span class="line">                        <span class="comment">// 有重复元素</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rowSeen[num] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (board[j][i] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 列检测</span></span><br><span class="line">                    <span class="keyword">int</span> num = board[j][i] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (colSeen[num]) &#123;</span><br><span class="line">                        <span class="comment">// 有重复元素</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    colSeen[num] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 3x3 宫，遍历9个子网格并使用一个数组 seen 来记录数字的出现情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> block = <span class="number">0</span>; block &lt; <span class="number">9</span>; block++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span>[] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>];</span><br><span class="line">            <span class="comment">// 行索引和列索引要错位，从而能</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = block / <span class="number">3</span> * <span class="number">3</span>; i &lt; block / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 行循环，除法，000,111,222，最后乘以3</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = block % <span class="number">3</span> * <span class="number">3</span>; j &lt; block % <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// 列循环，求余，012,012,012，最后乘以3</span></span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> num = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span> (seen[num]) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        seen[num] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] board1 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;3&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;5&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;9&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(isValidSudoku(board1)); <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[][] board2 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;3&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;5&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;9&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(isValidSudoku(board2)); <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="54-螺旋矩阵-lt-medium-gt"><a href="#54-螺旋矩阵-lt-medium-gt" class="headerlink" title="54. 螺旋矩阵  &lt;medium&gt;"></a>54. 螺旋矩阵  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">        输出：[1,2,3,6,9,8,7,4,5]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span></span><br><span class="line"><span class="comment">        输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == matrix.length</span></span><br><span class="line"><span class="comment">        n == matrix[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 10</span></span><br><span class="line"><span class="comment">        -100 &lt;= matrix[i][j] &lt;= 100*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiralMatrix54</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义边界指针</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = cols - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="comment">// 右移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                result.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class="line">                result.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左移，除非上下指针相碰</span></span><br><span class="line">            <span class="keyword">if</span> (top &lt; bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">                    result.add(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上移，除非左右指针相碰</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; i--) &#123;</span><br><span class="line">                    result.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移完一圈后，更新指针边界，左上+1，右下-1</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(m*n)</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix1 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix2 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(spiralOrder(matrix1)); <span class="comment">// Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]</span></span><br><span class="line">        System.out.println(spiralOrder(matrix2)); <span class="comment">// Output: [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="48-旋转图像-lt-medium-gt"><a href="#48-旋转图像-lt-medium-gt" class="headerlink" title="48. 旋转图像  &lt;medium&gt;"></a>48. 旋转图像  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">        输出：[[7,4,1],[8,5,2],[9,6,3]]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span></span><br><span class="line"><span class="comment">        输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        n == matrix.length == matrix[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 20</span></span><br><span class="line"><span class="comment">        -1000 &lt;= matrix[i][j] &lt;= 1000*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateImage48</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// i表示层数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// j通过四次交换操作旋转该层的四个边上的元素</span></span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                <span class="comment">// 从上层的左上角开始，将四个边上的元素依次移到下一个位置</span></span><br><span class="line">                <span class="comment">// 如4X4 00-30 30-33 33-03 03-00</span></span><br><span class="line">                <span class="comment">// 01-20 20-32 32-13 13 01</span></span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n^2)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix1 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix2 = &#123;&#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">11</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>&#125;, &#123;<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">15</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">16</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        rotate(matrix1);</span><br><span class="line">        rotate(matrix2);</span><br><span class="line"></span><br><span class="line">        printMatrix(matrix1); <span class="comment">// Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]</span></span><br><span class="line">        printMatrix(matrix2); <span class="comment">// Output: [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : row) &#123;</span><br><span class="line">                System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="73-矩阵置零-lt-medium-gt"><a href="#73-矩阵置零-lt-medium-gt" class="headerlink" title="73. 矩阵置零  &lt;medium&gt;"></a>73. 矩阵置零  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span></span><br><span class="line"><span class="comment">        输出：[[1,0,1],[0,0,0],[1,0,1]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span></span><br><span class="line"><span class="comment">        输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == matrix.length</span></span><br><span class="line"><span class="comment">        n == matrix[0].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 200</span></span><br><span class="line"><span class="comment">        -2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetMatrixZeroes73</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首行和首列先不处理，作为标记行</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span> firstRowHasZero = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> firstColHasZero = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查首行是否需要为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123;</span><br><span class="line">                firstRowHasZero = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查首列是否需要为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                firstColHasZero = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记零的边界点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 从(1, 1)开始寻找0的坐标，找到后将上左两侧标记为0</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果两侧有任意点为0则将对应点也置0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后处理首行和首列</span></span><br><span class="line">        <span class="keyword">if</span> (firstRowHasZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (firstColHasZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix1 = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        setZeroes(matrix1);</span><br><span class="line">        System.out.println(Arrays.deepToString(matrix1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix2 = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line">        setZeroes(matrix2);</span><br><span class="line">        System.out.println(Arrays.deepToString(matrix2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="289-生命游戏-lt-medium-gt"><a href="#289-生命游戏-lt-medium-gt" class="headerlink" title="289. 生命游戏  &lt;medium&gt;"></a>289. 生命游戏  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</span></span><br><span class="line"><span class="comment">        如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</span></span><br><span class="line"><span class="comment">        如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</span></span><br><span class="line"><span class="comment">        如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</span></span><br><span class="line"><span class="comment">        下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]</span></span><br><span class="line"><span class="comment">        输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[1,1],[1,0]]</span></span><br><span class="line"><span class="comment">        输出：[[1,1],[1,1]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == board.length</span></span><br><span class="line"><span class="comment">        n == board[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 25</span></span><br><span class="line"><span class="comment">        board[i][j] 为 0 或 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</span></span><br><span class="line"><span class="comment">        本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameOfLife289</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// directions数组来代表细胞周围的八个方向，使用-1和2分别表示中间状态：活转死，死转活。</span></span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个细胞，计算其周围活细胞的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 统计周围活细胞</span></span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 查看其8个方向的活细胞数量</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : directions) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = i + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> newCol = j + dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 新的行列在矩阵内，并且为活细胞，则统计+1</span></span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;= <span class="number">0</span> &amp;&amp; newCol &lt; n</span><br><span class="line">                            &amp;&amp; (board[newRow][newCol] == <span class="number">1</span> || board[newRow][newCol] == -<span class="number">1</span>)) &#123;</span><br><span class="line">                        liveNeighbors++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2：当前为死亡，且周围活细胞为3，要更新为活</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="number">0</span> &amp;&amp; liveNeighbors == <span class="number">3</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// -1：当前为活，且周围活细胞小于2或大于3，要更新为死</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="number">1</span> &amp;&amp; (liveNeighbors &lt; <span class="number">2</span> || liveNeighbors &gt; <span class="number">3</span>)) &#123;</span><br><span class="line">                    board[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环将状态更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(m * n)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] board1 = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] board2 = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        GameOfLife289 gameOfLife = <span class="keyword">new</span> GameOfLife289();</span><br><span class="line">        gameOfLife.gameOfLife(board1);</span><br><span class="line">        gameOfLife.gameOfLife(board2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result 1:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : board1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cell : row) &#123;</span><br><span class="line">                System.out.print(cell + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result 2:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : board2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cell : row) &#123;</span><br><span class="line">                System.out.print(cell + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-哈希表-Hash-Table"><a href="#3-5-哈希表-Hash-Table" class="headerlink" title="3.5 哈希表 Hash Table"></a>3.5 哈希表 Hash Table</h3><ol>
<li>快速查询和搜索</li>
<li>统计元素出现次数：重复元素、词频统计</li>
<li>映射关联：构建词典、映射关系等</li>
</ol>
<h4 id="383-赎金信-lt-easy-gt"><a href="#383-赎金信-lt-easy-gt" class="headerlink" title="383. 赎金信  &lt;easy&gt;"></a>383. 赎金信  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果可以，返回 true ；否则返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        magazine 中的每个字符只能在 ransomNote 中使用一次。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= ransomNote.length, magazine.length &lt;= 105</span></span><br><span class="line"><span class="comment">        ransomNote 和 magazine 由小写英文字母组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RansomNote383</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*        Map&lt;Character, Integer&gt; charCountMap = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">        int i = 0;</span></span><br><span class="line"><span class="comment">        while (i &lt; ransomNote.length()) &#123;</span></span><br><span class="line"><span class="comment">            Character ch = ransomNote.charAt(i);</span></span><br><span class="line"><span class="comment">            charCountMap.put(ch, charCountMap.getOrDefault(ch, 0) + 1);</span></span><br><span class="line"><span class="comment">            i++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int j = 0;</span></span><br><span class="line"><span class="comment">        while (j &lt; magazine.length()) &#123;</span></span><br><span class="line"><span class="comment">            Character ch = magazine.charAt(j);</span></span><br><span class="line"><span class="comment">            if (charCountMap.containsKey(ch)) &#123;</span></span><br><span class="line"><span class="comment">                int count = charCountMap.get(ch);</span></span><br><span class="line"><span class="comment">                if (count &lt;= 1) &#123;</span></span><br><span class="line"><span class="comment">                    charCountMap.remove(ch);</span></span><br><span class="line"><span class="comment">                &#125; else &#123;</span></span><br><span class="line"><span class="comment">                    charCountMap.put(ch, count-1);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            j++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //  O(n + m)</span></span><br><span class="line"><span class="comment">        return charCountMap.size() == 0;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组代替哈希表可以提高速度</span></span><br><span class="line">        <span class="keyword">int</span>[] charCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : magazine.toCharArray()) &#123;</span><br><span class="line">            charCount[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : ransomNote.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charCount[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            charCount[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  O(n + m)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RansomNote383 note = <span class="keyword">new</span> RansomNote383();</span><br><span class="line"></span><br><span class="line">        System.out.println(note.canConstruct(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(note.canConstruct(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ab&quot;</span>));</span><br><span class="line">        System.out.println(note.canConstruct(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aab&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="205-同构字符串-lt-easy-gt"><a href="#205-同构字符串-lt-easy-gt" class="headerlink" title="205. 同构字符串  &lt;easy&gt;"></a>205. 同构字符串  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定两个字符串 s 和 t ，判断它们是否是同构的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;egg&quot;, t = &quot;add&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;foo&quot;, t = &quot;bar&quot;</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;paper&quot;, t = &quot;title&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 5 * 104</span></span><br><span class="line"><span class="comment">        t.length == s.length</span></span><br><span class="line"><span class="comment">        s 和 t 由任意有效的 ASCII 字符组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsomorphicStrings205</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if (s.length() != t.length()) &#123;</span></span><br><span class="line">        <span class="comment">//    return false;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//Map&lt;Character, Character&gt; sMap = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//Map&lt;Character, Character&gt; tMap = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//int i = 0;</span></span><br><span class="line">        <span class="comment">//while (i &lt; s.length()) &#123;</span></span><br><span class="line">        <span class="comment">//    Character sc = s.charAt(i);</span></span><br><span class="line">        <span class="comment">//    Character tc = t.charAt(i);</span></span><br><span class="line">        <span class="comment">//    if ((sMap.containsKey(sc) || tMap.containsKey(tc)) &amp;&amp; (sMap.get(sc) != tc || tMap.get(tc) != sc)) &#123;</span></span><br><span class="line">        <span class="comment">//        return false;</span></span><br><span class="line">        <span class="comment">//    &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//        sMap.put(sc, tc);</span></span><br><span class="line">        <span class="comment">//        tMap.put(tc, sc);</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//    i++;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">////  O(n)</span></span><br><span class="line">        <span class="comment">//return true;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sToT = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] tToS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> charS = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> charT = t.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sToT[charS] != tToS[charT]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sToT[charS] = i + <span class="number">1</span>;</span><br><span class="line">            tToS[charT] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IsomorphicStrings205 test = <span class="keyword">new</span> IsomorphicStrings205();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.isIsomorphic(<span class="string">&quot;egg&quot;</span>, <span class="string">&quot;add&quot;</span>));</span><br><span class="line">        System.out.println(test.isIsomorphic(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>));</span><br><span class="line">        System.out.println(test.isIsomorphic(<span class="string">&quot;paper&quot;</span>, <span class="string">&quot;title&quot;</span>));</span><br><span class="line">        System.out.println(test.isIsomorphic(<span class="string">&quot;badc&quot;</span>, <span class="string">&quot;baba&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="290-单词规律-lt-easy-gt"><a href="#290-单词规律-lt-easy-gt" class="headerlink" title="290. 单词规律  &lt;easy&gt;"></a>290. 单词规律  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;</span></span><br><span class="line"><span class="comment">        输出: true</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入:pattern = &quot;abba&quot;, s = &quot;dog cat cat fish&quot;</span></span><br><span class="line"><span class="comment">        输出: false</span></span><br><span class="line"><span class="comment">        示例 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: pattern = &quot;aaaa&quot;, s = &quot;dog cat cat dog&quot;</span></span><br><span class="line"><span class="comment">        输出: false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= pattern.length &lt;= 300</span></span><br><span class="line"><span class="comment">        pattern 只包含小写英文字母</span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 3000</span></span><br><span class="line"><span class="comment">        s 只包含小写英文字母和 &#x27; &#x27;</span></span><br><span class="line"><span class="comment">        s 不包含 任何前导或尾随对空格</span></span><br><span class="line"><span class="comment">        s 中每个单词都被 单个空格 分隔*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordPattern290</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Map&lt;Character, String&gt; pMap = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//Map&lt;String, Character&gt; sMap = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//String[] strings = s.split(&quot; &quot;);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//if (pattern.length() != strings.length) &#123;</span></span><br><span class="line">        <span class="comment">//    return false;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//int i = 0;</span></span><br><span class="line">        <span class="comment">//while (i &lt; pattern.length()) &#123;</span></span><br><span class="line">        <span class="comment">//    Character pc = pattern.charAt(i);</span></span><br><span class="line">        <span class="comment">//    String sc = strings[i];</span></span><br><span class="line">        <span class="comment">//    if ((sMap.containsKey(sc) || pMap.containsKey(pc)) &amp;&amp; (sMap.get(sc) != pc || !pMap.get(pc).equals(sc))) &#123;</span></span><br><span class="line">        <span class="comment">//        return false;</span></span><br><span class="line">        <span class="comment">//    &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//        sMap.put(sc, pc);</span></span><br><span class="line">        <span class="comment">//        pMap.put(pc, sc);</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//    i++;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">////  O(n)</span></span><br><span class="line">        <span class="comment">//return true;</span></span><br><span class="line">        Map&lt;Character, String&gt; pMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        String[] strings = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.length() != strings.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> pc = pattern.charAt(i);</span><br><span class="line">            String sc = strings[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pMap.containsKey(pc)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pMap.get(pc).equals(sc)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pMap.containsValue(sc)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pMap.put(pc, sc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  O(n)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WordPattern290 test = <span class="keyword">new</span> WordPattern290();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.wordPattern(<span class="string">&quot;abba&quot;</span>, <span class="string">&quot;dog cat cat dog&quot;</span>));</span><br><span class="line">        System.out.println(test.wordPattern(<span class="string">&quot;abba&quot;</span>, <span class="string">&quot;dog cat cat fish&quot;</span>));</span><br><span class="line">        System.out.println(test.wordPattern(<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;dog cat cat dog&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="49-字母异位词分组-lt-medium-gt"><a href="#49-字母异位词分组-lt-medium-gt" class="headerlink" title="49. 字母异位词分组  &lt;medium&gt;"></a>49. 字母异位词分组  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span></span><br><span class="line"><span class="comment">        输出: true</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;rat&quot;, t = &quot;car&quot;</span></span><br><span class="line"><span class="comment">        输出: false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length, t.length &lt;= 5 * 104</span></span><br><span class="line"><span class="comment">        s 和 t 仅包含小写字母</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidAnagram242</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if (s.length() != t.length()) &#123;</span></span><br><span class="line">        <span class="comment">//    return false;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//int[] sList = new int[26];</span></span><br><span class="line">        <span class="comment">//int[] tList = new int[26];</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; s.length(); i++) &#123;</span></span><br><span class="line">        <span class="comment">//    char charS = s.charAt(i);</span></span><br><span class="line">        <span class="comment">//    char charT = t.charAt(i);</span></span><br><span class="line">        <span class="comment">//    sList[charS- &#x27;a&#x27;]++;</span></span><br><span class="line">        <span class="comment">//    tList[charT- &#x27;a&#x27;]++;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; sList.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//    if (sList[i] != tList[i]) &#123;</span></span><br><span class="line">        <span class="comment">//        return false;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// O(n)</span></span><br><span class="line">        <span class="comment">//return true;</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            count[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ValidAnagram242 test = <span class="keyword">new</span> ValidAnagram242();</span><br><span class="line">        System.out.println(test.isAnagram(<span class="string">&quot;anagram&quot;</span>, <span class="string">&quot;nagaram&quot;</span>));</span><br><span class="line">        System.out.println(test.isAnagram(<span class="string">&quot;abba&quot;</span>, <span class="string">&quot;car&quot;</span>));</span><br><span class="line">        System.out.println(test.isAnagram(<span class="string">&quot;nl&quot;</span>, <span class="string">&quot;cx&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="49-字母异位词分组-lt-medium-gt-1"><a href="#49-字母异位词分组-lt-medium-gt-1" class="headerlink" title="49. 字母异位词分组  &lt;medium&gt;"></a>49. 字母异位词分组  &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span></span><br><span class="line"><span class="comment">        输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: strs = [&quot;&quot;]</span></span><br><span class="line"><span class="comment">        输出: [[&quot;&quot;]]</span></span><br><span class="line"><span class="comment">        示例 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: strs = [&quot;a&quot;]</span></span><br><span class="line"><span class="comment">        输出: [[&quot;a&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= strs.length &lt;= 104</span></span><br><span class="line"><span class="comment">        0 &lt;= strs[i].length &lt;= 100</span></span><br><span class="line"><span class="comment">        strs[i] 仅包含小写字母*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupAnagrams49</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : strs) &#123;</span><br><span class="line">            <span class="comment">// 将字母排序，时间复杂度：O(m*logm) m为字符串最大长度</span></span><br><span class="line">            <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            String sorted = String.valueOf(chars);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 映射表记录，相同sorted的word</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(sorted)) &#123;</span><br><span class="line">                map.put(sorted, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(sorted).add(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n * m * logm)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupAnagrams49 test = <span class="keyword">new</span> GroupAnagrams49(); <span class="comment">// Assuming the class name is Solution</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example test cases</span></span><br><span class="line">        String[] strs1 = &#123;<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;tea&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;nat&quot;</span>, <span class="string">&quot;bat&quot;</span>&#125;;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result1 = test.groupAnagrams(strs1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Anagram Groups for strs1: &quot;</span> + result1);</span><br><span class="line"></span><br><span class="line">        String[] strs2 = &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result2 = test.groupAnagrams(strs2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Anagram Groups for strs2: &quot;</span> + result2);</span><br><span class="line"></span><br><span class="line">        String[] strs3 = &#123;<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result3 = test.groupAnagrams(strs3);</span><br><span class="line">        System.out.println(<span class="string">&quot;Anagram Groups for strs3: &quot;</span> + result3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-两数之和-lt-easy-gt"><a href="#1-两数之和-lt-easy-gt" class="headerlink" title="1. 两数之和  &lt;easy&gt;"></a>1. 两数之和  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以按任意顺序返回答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment">        输出：[0,1]</span></span><br><span class="line"><span class="comment">        解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [3,2,4], target = 6</span></span><br><span class="line"><span class="comment">        输出：[1,2]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [3,3], target = 6</span></span><br><span class="line"><span class="comment">        输出：[0,1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2 &lt;= nums.length &lt;= 10^4</span></span><br><span class="line"><span class="comment">        -10^9 &lt;= nums[i] &lt;= 10^9</span></span><br><span class="line"><span class="comment">        -10^9 &lt;= target &lt;= 10^9</span></span><br><span class="line"><span class="comment">        只会存在一个有效答案</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：你可以想出一个时间复杂度小于 O(n^2) 的算法吗？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//int[] result = new int[2];</span></span><br><span class="line">        <span class="comment">//int i = 0, j = 1;</span></span><br><span class="line">        <span class="comment">//while (i &lt; nums.length)&#123;</span></span><br><span class="line">        <span class="comment">//    if (nums[i] + nums[j] == target) &#123;</span></span><br><span class="line">        <span class="comment">//        result[0] = i;</span></span><br><span class="line">        <span class="comment">//        result[1] = j;</span></span><br><span class="line">        <span class="comment">//        return result;</span></span><br><span class="line">        <span class="comment">//    &#125; else if (j == nums.length - 1) &#123;</span></span><br><span class="line">        <span class="comment">//        i++;</span></span><br><span class="line">        <span class="comment">//        j = i + 1;</span></span><br><span class="line">        <span class="comment">//    &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//        j++;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">////  O(n^2)</span></span><br><span class="line">        <span class="comment">//return result;</span></span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 已遍历的元素存入map</span></span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TwoSum1 test = <span class="keyword">new</span> TwoSum1();</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result1 = test.twoSum(nums1, target);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出： &quot;</span> + Arrays.toString(result1)); <span class="comment">// [0,1]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        target = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result2 = test.twoSum(nums2, target);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出： &quot;</span> + Arrays.toString(result2)); <span class="comment">// [1,2]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        target = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result3 = test.twoSum(nums3, target);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出： &quot;</span> + Arrays.toString(result3)); <span class="comment">// [0,1]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums4 = &#123;-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>,-<span class="number">4</span>,-<span class="number">5</span>&#125;;</span><br><span class="line">        target = -<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result4 = test.twoSum(nums4, target);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出： &quot;</span> + Arrays.toString(result4)); <span class="comment">// [2,4]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="202-快乐数-lt-easy-gt"><a href="#202-快乐数-lt-easy-gt" class="headerlink" title="202. 快乐数  &lt;easy&gt;"></a>202. 快乐数  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编写一个算法来判断一个数 n 是不是快乐数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        「快乐数」 定义为：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</span></span><br><span class="line"><span class="comment">        然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</span></span><br><span class="line"><span class="comment">        如果这个过程 结果为 1，那么这个数就是快乐数。</span></span><br><span class="line"><span class="comment">        如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 19</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        1^2 + 9^2 = 82</span></span><br><span class="line"><span class="comment">        8^2 + 2^2 = 68</span></span><br><span class="line"><span class="comment">        6^2 + 8^2 = 100</span></span><br><span class="line"><span class="comment">        1^2 + 0^2 + 0^2 = 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 2</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 2^31 - 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyNumber202</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="keyword">int</span> slow = n;</span><br><span class="line">        <span class="keyword">int</span> fast = getNext(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当结果为1或者无限循环时退出</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="number">1</span> &amp;&amp; slow != fast) &#123;</span><br><span class="line">            slow = getNext(slow);</span><br><span class="line">            fast = getNext(getNext(fast));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(logn)</span></span><br><span class="line">        <span class="keyword">return</span> fast == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 求n的各位置数字的平方和</span></span><br><span class="line">            <span class="keyword">int</span> digit = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">            totalSum += digit * digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HappyNumber202 test = <span class="keyword">new</span> HappyNumber202();</span><br><span class="line">        System.out.println(test.isHappy(<span class="number">19</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(test.isHappy(<span class="number">2</span>)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="219-存在重复元素-II-lt-easy-gt"><a href="#219-存在重复元素-II-lt-easy-gt" class="headerlink" title="219. 存在重复元素 II  &lt;easy&gt;"></a>219. 存在重复元素 II  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &lt;= k 。如果存在，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1,2,3,1], k = 3</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1,0,1,1], k = 1</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1,2,3,1,2,3], k = 2</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">        -109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">        0 &lt;= k &lt;= 105*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainsDuplicateII219</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i]) &amp;&amp; Math.abs(map.get(nums[i]) - i) &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="128-最长连续序列-lt-medium-gt"><a href="#128-最长连续序列-lt-medium-gt" class="headerlink" title="128. 最长连续序列 &lt;medium&gt;"></a>128. 最长连续序列 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [100,4,200,1,3,2]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,3,7,2,5,8,4,6,0,1]</span></span><br><span class="line"><span class="comment">        输出：9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">        -109 &lt;= nums[i] &lt;= 109*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestConsecutiveSequence128</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数组放入哈希集合</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxSequence = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素-1后不在哈希集合中，则它可能是一个起点</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentSequence = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历获取连续序列</span></span><br><span class="line">                <span class="keyword">while</span> (set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum++;</span><br><span class="line">                    currentSequence++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                maxSequence = Math.max(maxSequence, currentSequence);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> maxSequence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-区间-Interval"><a href="#3-6-区间-Interval" class="headerlink" title="3.6 区间 Interval"></a>3.6 区间 Interval</h3><h4 id="228-汇总区间-lt-easy-gt"><a href="#228-汇总区间-lt-easy-gt" class="headerlink" title="228. 汇总区间  &lt;easy&gt;"></a>228. 汇总区间  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个  无重复元素 的 有序 整数数组 nums 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        列表中的每个区间范围 [a,b] 应该按如下格式输出：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &quot;a-&gt;b&quot; ，如果 a != b</span></span><br><span class="line"><span class="comment">        &quot;a&quot; ，如果 a == b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,1,2,4,5,7]</span></span><br><span class="line"><span class="comment">        输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span></span><br><span class="line"><span class="comment">        解释：区间范围是：</span></span><br><span class="line"><span class="comment">        [0,2] --&gt; &quot;0-&gt;2&quot;</span></span><br><span class="line"><span class="comment">        [4,5] --&gt; &quot;4-&gt;5&quot;</span></span><br><span class="line"><span class="comment">        [7,7] --&gt; &quot;7&quot;</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,2,3,4,6,8,9]</span></span><br><span class="line"><span class="comment">        输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span></span><br><span class="line"><span class="comment">        解释：区间范围是：</span></span><br><span class="line"><span class="comment">        [0,0] --&gt; &quot;0&quot;</span></span><br><span class="line"><span class="comment">        [2,4] --&gt; &quot;2-&gt;4&quot;</span></span><br><span class="line"><span class="comment">        [6,6] --&gt; &quot;6&quot;</span></span><br><span class="line"><span class="comment">        [8,9] --&gt; &quot;8-&gt;9&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= nums.length &lt;= 20</span></span><br><span class="line"><span class="comment">        -231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">        nums 中的所有值都 互不相同</span></span><br><span class="line"><span class="comment">        nums 按升序排列*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SummaryRanges228</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List&lt;String&gt; results = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//if (nums.length == 0) &#123;</span></span><br><span class="line">        <span class="comment">//    return results;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//int j, start = 0;</span></span><br><span class="line">        <span class="comment">//boolean flag = false;</span></span><br><span class="line">        <span class="comment">//for (int i = 0;i &lt; nums.length;i++) &#123;</span></span><br><span class="line">        <span class="comment">//    j = i + 1;</span></span><br><span class="line">        <span class="comment">//    if (j &lt; nums.length &amp;&amp; nums[j] &gt; nums[i] + 1) &#123;</span></span><br><span class="line">        <span class="comment">//        if (flag) &#123;</span></span><br><span class="line">        <span class="comment">//            results.add(start + &quot;-&gt;&quot; + nums[i]);</span></span><br><span class="line">        <span class="comment">//            flag = false;</span></span><br><span class="line">        <span class="comment">//        &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//            results.add(nums[i] + &quot;&quot;);</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//    &#125; else if (j &lt; nums.length &amp;&amp; nums[j] == nums[i] + 1) &#123;</span></span><br><span class="line">        <span class="comment">//        if (!flag) &#123;</span></span><br><span class="line">        <span class="comment">//            start = nums[i];</span></span><br><span class="line">        <span class="comment">//            flag = true;</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//    &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//        if (flag) &#123;</span></span><br><span class="line">        <span class="comment">//            results.add(start + &quot;-&gt;&quot; + nums[i]);</span></span><br><span class="line">        <span class="comment">//            flag = false;</span></span><br><span class="line">        <span class="comment">//        &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//            results.add(nums[i] + &quot;&quot;);</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return results;</span></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = nums[i];</span><br><span class="line">            <span class="comment">// 有连续数字时，循环跳过</span></span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[i + <span class="number">1</span>] == nums[i] + <span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> end = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                result.add(Integer.toString(start));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.add(start + <span class="string">&quot;-&gt;&quot;</span> + end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SummaryRanges228 test = <span class="keyword">new</span> SummaryRanges228();</span><br><span class="line">        <span class="comment">//int[] nums1 = &#123;0,1,2,4,5,7&#125;;</span></span><br><span class="line">        <span class="comment">//System.out.println(test.summaryRanges(nums1)); // [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(test.summaryRanges(nums2)); <span class="comment">// [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="56-合并区间-lt-medium-gt"><a href="#56-合并区间-lt-medium-gt" class="headerlink" title="56. 合并区间 &lt;medium&gt;"></a>56. 合并区间 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span></span><br><span class="line"><span class="comment">        输出：[[1,6],[8,10],[15,18]]</span></span><br><span class="line"><span class="comment">        解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：intervals = [[1,4],[4,5]]</span></span><br><span class="line"><span class="comment">        输出：[[1,5]]</span></span><br><span class="line"><span class="comment">        解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= intervals.length &lt;= 104</span></span><br><span class="line"><span class="comment">        intervals[i].length == 2</span></span><br><span class="line"><span class="comment">        0 &lt;= starti &lt;= endi &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeIntervals56</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">//Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[0]));</span></span><br><span class="line">        <span class="comment">//List&lt;int[]&gt; results = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//for (int[] interval : intervals) &#123;</span></span><br><span class="line">        <span class="comment">//    if (results.isEmpty() || results.get(results.size() - 1)[1] &lt; interval[0]) &#123;</span></span><br><span class="line">        <span class="comment">//        // 若数组为空，或当前区间不覆盖数组已有区间，直接加入数组</span></span><br><span class="line">        <span class="comment">//        results.add(interval);</span></span><br><span class="line">        <span class="comment">//    &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//        // 否则当前区间覆盖数组最后一个区间，通过更新结束边界来更新区间</span></span><br><span class="line">        <span class="comment">//        results.get(results.size() - 1)[1] = Math.max(results.get(results.size() - 1)[1], interval[1]);</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//// O(n log n)</span></span><br><span class="line">        <span class="comment">//return results.toArray(new int[results.size()][]);</span></span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先保证有序</span></span><br><span class="line">        Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">int</span>[] currentInterval = intervals[<span class="number">0</span>];</span><br><span class="line">        result.add(currentInterval);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentEnd = currentInterval[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> nextStart = interval[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nextEnd = interval[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentEnd &gt;= nextStart) &#123;</span><br><span class="line">                currentInterval[<span class="number">1</span>] = Math.max(currentEnd, nextEnd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentInterval = interval;</span><br><span class="line">                result.add(currentInterval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[result.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MergeIntervals56 test = <span class="keyword">new</span> MergeIntervals56();</span><br><span class="line">        <span class="keyword">int</span>[][] intervals1 = &#123;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>&#125;,&#123;<span class="number">8</span>,<span class="number">10</span>&#125;,&#123;<span class="number">15</span>,<span class="number">18</span>&#125;&#125;;</span><br><span class="line">        printArray(test.merge(intervals1)); <span class="comment">// [[1,6],[8,10],[15,18]]</span></span><br><span class="line">        <span class="keyword">int</span>[][] intervals2 = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        printArray(test.merge(intervals2)); <span class="comment">// [[1,5]]</span></span><br><span class="line">        <span class="keyword">int</span>[][] intervals3 = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">0</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">        printArray(test.merge(intervals3)); <span class="comment">// [[0,4]]</span></span><br><span class="line">        <span class="keyword">int</span>[][] intervals4 = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">        printArray(test.merge(intervals4)); <span class="comment">// [[1,4]]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : matrix) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : row) &#123;</span><br><span class="line">                System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="57-插入区间-lt-medium-gt"><a href="#57-插入区间-lt-medium-gt" class="headerlink" title="57. 插入区间 &lt;medium&gt;"></a>57. 插入区间 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：intervals = [[1,3],[6,9]], newInterval = [2,5]</span></span><br><span class="line"><span class="comment">        输出：[[1,5],[6,9]]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span></span><br><span class="line"><span class="comment">        输出：[[1,2],[3,10],[12,16]]</span></span><br><span class="line"><span class="comment">        解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：intervals = [], newInterval = [5,7]</span></span><br><span class="line"><span class="comment">        输出：[[5,7]]</span></span><br><span class="line"><span class="comment">        示例 4：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：intervals = [[1,5]], newInterval = [2,3]</span></span><br><span class="line"><span class="comment">        输出：[[1,5]]</span></span><br><span class="line"><span class="comment">        示例 5：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：intervals = [[1,5]], newInterval = [2,7]</span></span><br><span class="line"><span class="comment">        输出：[[1,7]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= intervals.length &lt;= 104</span></span><br><span class="line"><span class="comment">        intervals[i].length == 2</span></span><br><span class="line"><span class="comment">        0 &lt;= intervals[i][0] &lt;= intervals[i][1] &lt;= 105</span></span><br><span class="line"><span class="comment">        intervals 根据 intervals[i][0] 按 升序 排列</span></span><br><span class="line"><span class="comment">        newInterval.length == 2</span></span><br><span class="line"><span class="comment">        0 &lt;= newInterval[0] &lt;= newInterval[1] &lt;= 105*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertInterval57</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先将原区间集合在新区间之前的插入数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.add(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若新区间在当前区间开始之后</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 将新区间置换，取更小的左边和最大的右边</span></span><br><span class="line">            newInterval[<span class="number">0</span>] = Math.min(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">            newInterval[<span class="number">1</span>] = Math.max(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(newInterval);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余区间加入数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            result.add(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[result.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InsertInterval57 inserter = <span class="keyword">new</span> InsertInterval57();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] intervals1 = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">6</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] newInterval1 = &#123;<span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        print(inserter.insert(intervals1, newInterval1));<span class="comment">//[[1,5],[6,9]]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] intervals2 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">8</span>,<span class="number">10</span>&#125;,&#123;<span class="number">12</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] newInterval2 = &#123;<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        print(inserter.insert(intervals2, newInterval2));<span class="comment">//[[1,2],[3,10],[12,16]]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] intervals3 = &#123;&#123;<span class="number">1</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] newInterval3 = &#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        print(inserter.insert(intervals3, newInterval3));<span class="comment">//[[1,5]]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] intervals4 = &#123;&#123;<span class="number">1</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] newInterval4 = &#123;<span class="number">2</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        print(inserter.insert(intervals4, newInterval4));<span class="comment">//[[1,7]]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] mergedIntervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : mergedIntervals) &#123;</span><br><span class="line">            System.out.print(Arrays.toString(interval));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="452-用最少数量的箭引爆气球-lt-medium-gt"><a href="#452-用最少数量的箭引爆气球-lt-medium-gt" class="headerlink" title="452. 用最少数量的箭引爆气球 &lt;medium&gt;"></a>452. 用最少数量的箭引爆气球 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：points = [[10,16],[2,8],[1,6],[7,12]]</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        解释：气球可以用2支箭来爆破:</span></span><br><span class="line"><span class="comment">        -在x = 6处射出箭，击破气球[2,8]和[1,6]。</span></span><br><span class="line"><span class="comment">        -在x = 11处发射箭，击破气球[10,16]和[7,12]。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：points = [[1,2],[3,4],[5,6],[7,8]]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        解释：每个气球需要射出一支箭，总共需要4支箭。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：points = [[1,2],[2,3],[3,4],[4,5]]</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        解释：气球可以用2支箭来爆破:</span></span><br><span class="line"><span class="comment">        - 在x = 2处发射箭，击破气球[1,2]和[2,3]。</span></span><br><span class="line"><span class="comment">        - 在x = 4处射出箭，击破气球[3,4]和[4,5]。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= points.length &lt;= 105</span></span><br><span class="line"><span class="comment">        points[i].length == 2</span></span><br><span class="line"><span class="comment">        -231 &lt;= xstart &lt; xend &lt;= 231 - 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumNumberOfArrowsToBurstBalloons452</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排序 + 贪心</span></span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过右边界排序</span></span><br><span class="line">        Arrays.sort(points, Comparator.comparingInt(a -&gt; a[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> arrows = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历气球节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 若当前节点与end不重叠，箭数增加，更新新的end</span></span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; end) &#123;</span><br><span class="line">                arrows++;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n log n)</span></span><br><span class="line">        <span class="keyword">return</span> arrows;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinimumNumberOfArrowsToBurstBalloons452 minArrows = <span class="keyword">new</span> MinimumNumberOfArrowsToBurstBalloons452();</span><br><span class="line">        <span class="keyword">int</span>[][] points1 = &#123;&#123;<span class="number">10</span>, <span class="number">16</span>&#125;, &#123;<span class="number">2</span>, <span class="number">8</span>&#125;, &#123;<span class="number">1</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] points2 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] points3 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(minArrows.findMinArrowShots(points1)); <span class="comment">// Output: 2</span></span><br><span class="line">        System.out.println(minArrows.findMinArrowShots(points2)); <span class="comment">// Output: 4</span></span><br><span class="line">        System.out.println(minArrows.findMinArrowShots(points3)); <span class="comment">// Output: 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-7-栈-Stack"><a href="#3-7-栈-Stack" class="headerlink" title="3.7 栈 Stack"></a>3.7 栈 Stack</h3><h4 id="20-有效的括号-lt-easy-gt"><a href="#20-有效的括号-lt-easy-gt" class="headerlink" title="20. 有效的括号  &lt;easy&gt;"></a>20. 有效的括号  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串 s ，判断字符串是否有效。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        有效字符串需满足：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        左括号必须用相同类型的右括号闭合。</span></span><br><span class="line"><span class="comment">        左括号必须以正确的顺序闭合。</span></span><br><span class="line"><span class="comment">        每个右括号都有一个对应的相同类型的左括号。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;()&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;()[]&#123;&#125;&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;(]&quot;</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 104</span></span><br><span class="line"><span class="comment">        s 仅由括号 &#x27;()[]&#123;&#125;&#x27; 组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidParentheses20</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span> || s.length() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历遇到左括号入栈，遇到右括号出栈，判断是否匹配</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (left(ch)) &#123;</span><br><span class="line">                <span class="comment">// 左括号</span></span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!stack.empty()) &#123;</span><br><span class="line">                <span class="comment">// 右括号，并且栈中有左括号</span></span><br><span class="line">                <span class="keyword">char</span> left = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (!match(left, ch)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右括号，栈中没有左括号</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="comment">// 栈中括号是否全部匹配</span></span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> left, <span class="keyword">char</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right == <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right == <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right == <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">left</span><span class="params">(<span class="keyword">char</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="string">&#x27;(&#x27;</span> || left == <span class="string">&#x27;&#123;&#x27;</span> || left == <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ValidParentheses20 test = <span class="keyword">new</span> ValidParentheses20();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.isValid(<span class="string">&quot;()&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(test.isValid(<span class="string">&quot;()[]&#123;&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(test.isValid(<span class="string">&quot;(]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="71-简化路径-lt-medium-gt"><a href="#71-简化路径-lt-medium-gt" class="headerlink" title="71. 简化路径 &lt;medium&gt;"></a>71. 简化路径 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 &#x27;/&#x27; 开头），请你将其转化为更加简洁的规范路径。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，&#x27;//&#x27;）都被视为单个斜杠 &#x27;/&#x27; 。 对于此问题，任何其他格式的点（例如，&#x27;...&#x27;）均被视为文件/目录名称。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请注意，返回的 规范路径 必须遵循下述格式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        始终以斜杠 &#x27;/&#x27; 开头。</span></span><br><span class="line"><span class="comment">        两个目录名之间必须只有一个斜杠 &#x27;/&#x27; 。</span></span><br><span class="line"><span class="comment">        最后一个目录名（如果存在）不能 以 &#x27;/&#x27; 结尾。</span></span><br><span class="line"><span class="comment">        此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 &#x27;.&#x27; 或 &#x27;..&#x27;）。</span></span><br><span class="line"><span class="comment">        返回简化后得到的 规范路径 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：path = &quot;/home/&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;/home&quot;</span></span><br><span class="line"><span class="comment">        解释：注意，最后一个目录名后面没有斜杠。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：path = &quot;/../&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;/&quot;</span></span><br><span class="line"><span class="comment">        解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：path = &quot;/home//foo/&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;/home/foo&quot;</span></span><br><span class="line"><span class="comment">        解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span></span><br><span class="line"><span class="comment">        示例 4：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：path = &quot;/a/./b/../../c/&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;/c&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= path.length &lt;= 3000</span></span><br><span class="line"><span class="comment">        path 由英文字母，数字，&#x27;.&#x27;，&#x27;/&#x27; 或 &#x27;_&#x27; 组成。</span></span><br><span class="line"><span class="comment">        path 是一个有效的 Unix 风格绝对路径。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplifyPath71</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; skip = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据/分割字符串</span></span><br><span class="line">        <span class="keyword">for</span> (String dir : path.split(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dir.equals(<span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// ..表示返回上一级，弹出栈顶元素</span></span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!skip.contains(dir)) &#123;</span><br><span class="line">                <span class="comment">// 有效目录，则存放入栈</span></span><br><span class="line">                stack.push(dir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其余直接跳过</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈中剩余的元素即为简化后的路径</span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            result.insert(<span class="number">0</span>, <span class="string">&quot;/&quot;</span> + stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> result.length() == <span class="number">0</span> ? <span class="string">&quot;/&quot;</span> : result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] testCases = &#123;<span class="string">&quot;/home/&quot;</span>, <span class="string">&quot;/../&quot;</span>, <span class="string">&quot;/home//foo/&quot;</span>, <span class="string">&quot;/a/./b/../../c/&quot;</span>, <span class="string">&quot;/a/./b/../../...c/&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String path : testCases) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Input: &quot;</span> + path);</span><br><span class="line">            System.out.println(<span class="string">&quot;Output: &quot;</span> + simplifyPath(path));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="155-最小栈-lt-medium-gt"><a href="#155-最小栈-lt-medium-gt" class="headerlink" title="155. 最小栈 &lt;medium&gt;"></a>155. 最小栈 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        实现 MinStack 类:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        MinStack() 初始化堆栈对象。</span></span><br><span class="line"><span class="comment">        void push(int val) 将元素val推入堆栈。</span></span><br><span class="line"><span class="comment">        void pop() 删除堆栈顶部的元素。</span></span><br><span class="line"><span class="comment">        int top() 获取堆栈顶部的元素。</span></span><br><span class="line"><span class="comment">        int getMin() 获取堆栈中的最小元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：</span></span><br><span class="line"><span class="comment">        [&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span></span><br><span class="line"><span class="comment">        [[],[-2],[0],[-3],[],[],[],[]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输出：</span></span><br><span class="line"><span class="comment">        [null,null,null,null,-3,null,0,-2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        MinStack minStack = new MinStack();</span></span><br><span class="line"><span class="comment">        minStack.push(-2);</span></span><br><span class="line"><span class="comment">        minStack.push(0);</span></span><br><span class="line"><span class="comment">        minStack.push(-3);</span></span><br><span class="line"><span class="comment">        minStack.getMin();   --&gt; 返回 -3.</span></span><br><span class="line"><span class="comment">        minStack.pop();</span></span><br><span class="line"><span class="comment">        minStack.top();      --&gt; 返回 0.</span></span><br><span class="line"><span class="comment">        minStack.getMin();   --&gt; 返回 -2.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        -231 &lt;= val &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">        pop、top 和 getMin 操作总是在 非空栈 上调用</span></span><br><span class="line"><span class="comment">        push, pop, top, and getMin最多被调用 3 * 104 次*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack155</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="comment">// 存储当前栈中的最小元素</span></span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack155</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="comment">// 新值为当前最小元素，则入栈</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || val &lt;= minStack.peek()) &#123;</span><br><span class="line">            minStack.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果栈顶是最小元素，则两个栈都要出栈</span></span><br><span class="line">        <span class="keyword">if</span> (stack.peek().equals(minStack.peek())) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinStack155 minStack = <span class="keyword">new</span> MinStack155();</span><br><span class="line">        minStack.push(-<span class="number">2</span>);</span><br><span class="line">        minStack.push(<span class="number">0</span>);</span><br><span class="line">        minStack.push(-<span class="number">3</span>);</span><br><span class="line">        System.out.println(minStack.getMin());   <span class="comment">// Output: -3</span></span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.top());      <span class="comment">// Output: 0</span></span><br><span class="line">        System.out.println(minStack.getMin());   <span class="comment">// Output: -2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h4 id="150-逆波兰表达式求值-lt-medium-gt"><a href="#150-逆波兰表达式求值-lt-medium-gt" class="headerlink" title="150. 逆波兰表达式求值 &lt;medium&gt;"></a>150. 逆波兰表达式求值 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请你计算该表达式。返回一个表示表达式值的整数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        有效的算符为 &#x27;+&#x27;、&#x27;-&#x27;、&#x27;*&#x27; 和 &#x27;/&#x27; 。</span></span><br><span class="line"><span class="comment">        每个操作数（运算对象）都可以是一个整数或者另一个表达式。</span></span><br><span class="line"><span class="comment">        两个整数之间的除法总是 向零截断 。</span></span><br><span class="line"><span class="comment">        表达式中不含除零运算。</span></span><br><span class="line"><span class="comment">        输入是一个根据逆波兰表示法表示的算术表达式。</span></span><br><span class="line"><span class="comment">        答案及所有中间计算结果可以用 32 位 整数表示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span></span><br><span class="line"><span class="comment">        输出：9</span></span><br><span class="line"><span class="comment">        解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span></span><br><span class="line"><span class="comment">        输出：6</span></span><br><span class="line"><span class="comment">        解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span></span><br><span class="line"><span class="comment">        输出：22</span></span><br><span class="line"><span class="comment">        解释：该算式转化为常见的中缀算术表达式为：</span></span><br><span class="line"><span class="comment">        ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span></span><br><span class="line"><span class="comment">        = ((10 * (6 / (12 * -11))) + 17) + 5</span></span><br><span class="line"><span class="comment">        = ((10 * (6 / -132)) + 17) + 5</span></span><br><span class="line"><span class="comment">        = ((10 * 0) + 17) + 5</span></span><br><span class="line"><span class="comment">        = (0 + 17) + 5</span></span><br><span class="line"><span class="comment">        = 17 + 5</span></span><br><span class="line"><span class="comment">        = 22</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= tokens.length &lt;= 104</span></span><br><span class="line"><span class="comment">        tokens[i] 是一个算符（&quot;+&quot;、&quot;-&quot;、&quot;*&quot; 或 &quot;/&quot;），或是在范围 [-200, 200] 内的一个整数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        逆波兰表达式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</span></span><br><span class="line"><span class="comment">        该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</span></span><br><span class="line"><span class="comment">        逆波兰表达式主要有以下两个优点：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</span></span><br><span class="line"><span class="comment">        适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvaluateReversePolishNotation150</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDigit(token)) &#123;</span><br><span class="line">                <span class="comment">// 数字</span></span><br><span class="line">                stack.push(token);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 运算符号</span></span><br><span class="line">                <span class="keyword">int</span> b = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> a = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(token)) &#123;</span><br><span class="line">                    result = a + b;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(token)) &#123;</span><br><span class="line">                    result = a - b;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(token)) &#123;</span><br><span class="line">                    result = a * b;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(token)) &#123;</span><br><span class="line">                    result = a / b;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(result + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(<span class="string">&quot;+&quot;</span>.equals(token) || <span class="string">&quot;-&quot;</span>.equals(token) || <span class="string">&quot;*&quot;</span>.equals(token) || <span class="string">&quot;/&quot;</span>.equals(token));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EvaluateReversePolishNotation150 test = <span class="keyword">new</span> EvaluateReversePolishNotation150();</span><br><span class="line">        String[] tokens1 = &#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;*&quot;</span>&#125;;</span><br><span class="line">        System.out.println(test.evalRPN(tokens1)); <span class="comment">// 9</span></span><br><span class="line">        String[] tokens2 = &#123;<span class="string">&quot;4&quot;</span>,<span class="string">&quot;13&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;+&quot;</span>&#125;;</span><br><span class="line">        System.out.println(test.evalRPN(tokens2)); <span class="comment">// 6</span></span><br><span class="line">        String[] tokens3 = &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-11&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;17&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;+&quot;</span>&#125;;</span><br><span class="line">        System.out.println(test.evalRPN(tokens3)); <span class="comment">// 22</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="224-基本计算器-lt-hard-gt"><a href="#224-基本计算器-lt-hard-gt" class="headerlink" title="224. 基本计算器  &lt;hard&gt;"></a>224. 基本计算器  &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;1 + 1&quot;</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot; 2-1 + 2 &quot;</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span></span><br><span class="line"><span class="comment">        输出：23</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 3 * 105</span></span><br><span class="line"><span class="comment">        s 由数字、&#x27;+&#x27;、&#x27;-&#x27;、&#x27;(&#x27;、&#x27;)&#x27;、和 &#x27; &#x27; 组成</span></span><br><span class="line"><span class="comment">        s 表示一个有效的表达式</span></span><br><span class="line"><span class="comment">        &#x27;+&#x27; 不能用作一元运算(例如， &quot;+1&quot; 和 &quot;+(2 + 3)&quot; 无效)</span></span><br><span class="line"><span class="comment">        &#x27;-&#x27; 可以用作一元运算(即 &quot;-1&quot; 和 &quot;-(2 + 3)&quot; 是有效的)</span></span><br><span class="line"><span class="comment">        输入中不存在两个连续的操作符</span></span><br><span class="line"><span class="comment">        每个数字和运行的计算将适合于一个有符号的 32位 整数*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicCalculator224</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//维护两个栈，一个用于存储数字，一个用于存储运算符号</span></span><br><span class="line">        Deque&lt;Integer&gt; numStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; signStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">// 当前数字的值</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前数字的符号</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前的计算结果</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(ch)) &#123;</span><br><span class="line">                <span class="comment">// 数字，若之前已有字符为数字，则需要进位</span></span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// +或-，更新结果 result，然后重置 num 和 sign</span></span><br><span class="line">                result += sign * num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 减号作为下一数字的负符号</span></span><br><span class="line">                sign = (ch == <span class="string">&#x27;+&#x27;</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将当前结果 result 和当前符号 sign 入栈，重置 result 和 sign</span></span><br><span class="line">                numStack.push(result);</span><br><span class="line">                signStack.push(sign);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 右括号，则弹出栈顶元素存放的之前的结果进行计算，并更新 result 和 sign</span></span><br><span class="line">                <span class="comment">// 当前括号结果</span></span><br><span class="line">                result += sign * num;</span><br><span class="line">                result *= signStack.pop();</span><br><span class="line">                <span class="comment">// 加上之前的结果</span></span><br><span class="line">                result += numStack.pop();</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result += sign * num;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String expr1 = <span class="string">&quot;1 + 1&quot;</span>;</span><br><span class="line">        String expr2 = <span class="string">&quot; 2-1 + 2 &quot;</span>;</span><br><span class="line">        String expr3 = <span class="string">&quot;(1+(4+5+2)-3)+(6+8)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Expr 1 result: &quot;</span> + calculate(expr1)); <span class="comment">// Output: 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Expr 2 result: &quot;</span> + calculate(expr2)); <span class="comment">// Output: 3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Expr 3 result: &quot;</span> + calculate(expr3)); <span class="comment">// Output: 23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-8-链表-Linked-List"><a href="#3-8-链表-Linked-List" class="headerlink" title="3.8 链表 Linked List"></a>3.8 链表 Linked List</h3><h4 id="141-环形链表-lt-easy-gt-快慢指针"><a href="#141-环形链表-lt-easy-gt-快慢指针" class="headerlink" title="141. 环形链表  &lt;easy&gt; 快慢指针"></a>141. 环形链表  &lt;easy&gt; 快慢指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个链表的头节点 head ，判断链表中是否有环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果链表中存在环 ，则返回 true 。 否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [3,2,0,-4], pos = 1</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        解释：链表中有一个环，其尾部连接到第二个节点。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,2], pos = 0</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        解释：链表中有一个环，其尾部连接到第一个节点。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1], pos = -1</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        解释：链表中没有环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        链表中节点的数目范围是 [0, 104]</span></span><br><span class="line"><span class="comment">        -105 &lt;= Node.val &lt;= 105</span></span><br><span class="line"><span class="comment">        pos 为 -1 或者链表中的一个 有效索引 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：你能用 O(1)（即，常量）内存解决此问题吗？*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListCycle141</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用快慢指针解决。通过两个指针在链表上移动来判断是否有环。</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义两个指针，一个慢指针 slow，一次移动一个节点；一个快指针 fast，一次移动两个节点。如果链表中有环，那么快指针终究会追上慢指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次移动后，判断 slow 和 fast 是否指向相同的节点</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="comment">// 如果是，则链表中有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 慢指针 slow 移动一步</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 快指针 fast 移动两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(N) O(1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head1 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        head1.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        head1.next.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head1.next.next.next = <span class="keyword">new</span> ListNode(-<span class="number">4</span>);</span><br><span class="line">        head1.next.next.next.next = head1.next; <span class="comment">// Creating a cycle</span></span><br><span class="line"></span><br><span class="line">        ListNode head2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        head2.next.next = head2; <span class="comment">// Creating a cycle</span></span><br><span class="line"></span><br><span class="line">        ListNode head3 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Has cycle in head1: &quot;</span> + hasCycle(head1)); <span class="comment">// Output: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Has cycle in head2: &quot;</span> + hasCycle(head2)); <span class="comment">// Output: true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Has cycle in head3: &quot;</span> + hasCycle(head3)); <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-两数相加-lt-medium-gt-遍历同时逐位相加"><a href="#2-两数相加-lt-medium-gt-遍历同时逐位相加" class="headerlink" title="2. 两数相加 &lt;medium&gt; 遍历同时逐位相加"></a>2. 两数相加 &lt;medium&gt; 遍历同时逐位相加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请你将两个数相加，并以相同形式返回一个表示和的链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：l1 = [2,4,3], l2 = [5,6,4]</span></span><br><span class="line"><span class="comment">        输出：[7,0,8]</span></span><br><span class="line"><span class="comment">        解释：342 + 465 = 807.</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：l1 = [0], l2 = [0]</span></span><br><span class="line"><span class="comment">        输出：[0]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span></span><br><span class="line"><span class="comment">        输出：[8,9,9,9,0,0,0,1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        每个链表中的节点数在范围 [1, 100] 内</span></span><br><span class="line"><span class="comment">        0 &lt;= Node.val &lt;= 9</span></span><br><span class="line"><span class="comment">        题目数据保证列表表示的数字不含前导零*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTwoNumbers2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 普通解法：通过将链表转换为整数进行相加，然后再将结果转换回链表</span></span><br><span class="line">        <span class="comment">// 因为每个链表中的节点数在范围 [1, 100] 内，所以int和long的长度都不足</span></span><br><span class="line">        <span class="comment">//BigDecimal a = BigDecimal.ZERO;</span></span><br><span class="line">        <span class="comment">//BigDecimal x = BigDecimal.ONE;</span></span><br><span class="line">        <span class="comment">//while (l1 != null) &#123;</span></span><br><span class="line">        <span class="comment">//    a = a.add(x.multiply(BigDecimal.valueOf(l1.val)));</span></span><br><span class="line">        <span class="comment">//    x = x.multiply(BigDecimal.TEN);</span></span><br><span class="line">        <span class="comment">//    l1 = l1.next;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//BigDecimal b = BigDecimal.ZERO;</span></span><br><span class="line">        <span class="comment">//x = BigDecimal.ONE;</span></span><br><span class="line">        <span class="comment">//while (l2 != null) &#123;</span></span><br><span class="line">        <span class="comment">//    b = b.add(x.multiply(BigDecimal.valueOf(l2.val)));</span></span><br><span class="line">        <span class="comment">//    x = x.multiply(BigDecimal.TEN);</span></span><br><span class="line">        <span class="comment">//    l2 = l2.next;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//BigDecimal c = a.add(b);</span></span><br><span class="line">        <span class="comment">//String string = c + &quot;&quot;;</span></span><br><span class="line">        <span class="comment">//ListNode result = new ListNode(Character.getNumericValue(string.charAt(string.length() - 1)));</span></span><br><span class="line">        <span class="comment">//ListNode first = result;</span></span><br><span class="line">        <span class="comment">//for (int i = string.length() - 2;i &gt;= 0;i--) &#123;</span></span><br><span class="line">        <span class="comment">//    ListNode temp = new ListNode(Character.getNumericValue(string.charAt(i)));</span></span><br><span class="line">        <span class="comment">//    result.next = temp;</span></span><br><span class="line">        <span class="comment">//    result = temp;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//return first;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化：在遍历链表的同时，逐位相加并构建新链表作为结果。</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode current = dummyHead;</span><br><span class="line">        <span class="comment">// 处理每个节点相加后的进位。当两个节点相加的和大于等于 10 时，需要将进位值传递到下一个节点的计算中。</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时遍历两个链表</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (l1 != <span class="keyword">null</span>) ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (l2 != <span class="keyword">null</span>) ? l2.val : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算当前位的和，并更新进位</span></span><br><span class="line">            <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将加后的节点构建新的链表节点</span></span><br><span class="line">            current.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            current.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AddTwoNumbers2.ListNode l1 = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">2</span>);</span><br><span class="line">        l1.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">4</span>);</span><br><span class="line">        l1.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">3</span>);</span><br><span class="line">        AddTwoNumbers2.ListNode l2 = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">5</span>);</span><br><span class="line">        l2.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">6</span>);</span><br><span class="line">        l2.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        AddTwoNumbers2.ListNode l3 = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        AddTwoNumbers2.ListNode l4 = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        AddTwoNumbers2.ListNode l5 = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l5.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l5.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l5.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l5.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l5.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l5.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        AddTwoNumbers2.ListNode l6 = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l6.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l6.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l6.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数字长度10，int不够用</span></span><br><span class="line">        AddTwoNumbers2.ListNode l7 = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        AddTwoNumbers2.ListNode l8 = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">1</span>);</span><br><span class="line">        l8.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l8.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l8.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l8.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l8.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l8.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l8.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l8.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line">        l8.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数字长度超过19，long不够用</span></span><br><span class="line">        AddTwoNumbers2.ListNode l9 = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">1</span>);</span><br><span class="line">        l9.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next= <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">0</span>);</span><br><span class="line">        l9.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        AddTwoNumbers2.ListNode l10 = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">5</span>);</span><br><span class="line">        l10.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">6</span>);</span><br><span class="line">        l10.next.next = <span class="keyword">new</span> AddTwoNumbers2.ListNode(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        printLinkedList(addTwoNumbers(l1, l2));<span class="comment">// Output: [7,0,8]</span></span><br><span class="line">        printLinkedList(addTwoNumbers(l3, l4)); <span class="comment">// Output: [0]</span></span><br><span class="line">        printLinkedList(addTwoNumbers(l5, l6)); <span class="comment">// Output: [8,9,9,9,0,0,0,1]</span></span><br><span class="line">        printLinkedList(addTwoNumbers(l7, l8)); <span class="comment">// Output: [0,0,0,0,0,0,0,0,0,0,1]</span></span><br><span class="line">        printLinkedList(addTwoNumbers(l9, l10)); <span class="comment">// [6,6,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="21-合并两个有序链表-lt-easy-gt"><a href="#21-合并两个有序链表-lt-easy-gt" class="headerlink" title="21. 合并两个有序链表  &lt;easy&gt;"></a>21. 合并两个有序链表  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：l1 = [1,2,4], l2 = [1,3,4]</span></span><br><span class="line"><span class="comment">        输出：[1,1,2,3,4,4]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：l1 = [], l2 = []</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：l1 = [], l2 = [0]</span></span><br><span class="line"><span class="comment">        输出：[0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        两个链表的节点数目范围是 [0, 50]</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">        l1 和 l2 均按 非递减顺序 排列*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTwoSortedLists21</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先构建一个假节点作为起点</span></span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// current指向当前节点</span></span><br><span class="line">        ListNode current = result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 两个链表都不为空时</span></span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">                <span class="comment">// 指向小的节点</span></span><br><span class="line">                current.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若还有链表不为空，则指向该链表</span></span><br><span class="line">        current.next = (list1 != <span class="keyword">null</span>) ? list1 : list2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(m + n)</span></span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helper method to print the linked list</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MergeTwoSortedLists21 merger = <span class="keyword">new</span> MergeTwoSortedLists21();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 1</span></span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>)));</span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>)));</span><br><span class="line">        ListNode result1 = merger.mergeTwoLists(l1, l2);</span><br><span class="line">        merger.printList(result1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 2</span></span><br><span class="line">        ListNode l3 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode l4 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode result2 = merger.mergeTwoLists(l3, l4);</span><br><span class="line">        merger.printList(result2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 3</span></span><br><span class="line">        ListNode l5 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode l6 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode result3 = merger.mergeTwoLists(l5, l6);</span><br><span class="line">        merger.printList(result3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        MergeTwoSortedLists21.ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, MergeTwoSortedLists21.ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="138-随机链表的复制-lt-medium-gt-Map提前生成复制节点"><a href="#138-随机链表的复制-lt-medium-gt-Map提前生成复制节点" class="headerlink" title="138. 随机链表的复制 &lt;medium&gt; Map提前生成复制节点"></a>138. 随机链表的复制 &lt;medium&gt; Map提前生成复制节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        返回复制链表的头节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        val：一个表示 Node.val 的整数。</span></span><br><span class="line"><span class="comment">        random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</span></span><br><span class="line"><span class="comment">        你的代码 只 接受原链表的头节点 head 作为传入参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span></span><br><span class="line"><span class="comment">        输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [[1,1],[2,1]]</span></span><br><span class="line"><span class="comment">        输出：[[1,1],[2,1]]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [[3,null],[3,0],[3,null]]</span></span><br><span class="line"><span class="comment">        输出：[[3,null],[3,0],[3,null]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= n &lt;= 1000</span></span><br><span class="line"><span class="comment">        -104 &lt;= Node.val &lt;= 104</span></span><br><span class="line"><span class="comment">        Node.random 为 null 或指向链表中的节点。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyListWithRandomPointer138</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过一个map来记录原链表节点和复制链表的映射关系</span></span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表，将复制节点存入map</span></span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(current, <span class="keyword">new</span> Node(current.val));</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次遍历链表，</span></span><br><span class="line">        current = head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 连接复制节点的next和random，都从map中找到对应原节点的复制节点</span></span><br><span class="line">            map.get(current).next = map.get(current.next);</span><br><span class="line">            map.get(current).random = map.get(current.random);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;[&quot;</span> + current.val + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (current.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(current.random.val + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;null]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CopyListWithRandomPointer138 copier = <span class="keyword">new</span> CopyListWithRandomPointer138();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 1</span></span><br><span class="line">        CopyListWithRandomPointer138.Node node1 = copier.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">        CopyListWithRandomPointer138.Node node2 = copier.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">13</span>)</span></span>;</span><br><span class="line">        CopyListWithRandomPointer138.Node node3 = copier.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">        CopyListWithRandomPointer138.Node node4 = copier.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        CopyListWithRandomPointer138.Node node5 = copier.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        node1.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        node3.next = node4;</span><br><span class="line">        node4.next = node5;</span><br><span class="line"></span><br><span class="line">        node1.random = <span class="keyword">null</span>;</span><br><span class="line">        node2.random = node1;</span><br><span class="line">        node3.random = node5;</span><br><span class="line">        node4.random = node3;</span><br><span class="line">        node5.random = node1;</span><br><span class="line"></span><br><span class="line">        CopyListWithRandomPointer138.Node result1 = copier.copyRandomList(node1);</span><br><span class="line">        copier.printRandomList(result1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 2</span></span><br><span class="line">        CopyListWithRandomPointer138.Node node6 = copier.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        CopyListWithRandomPointer138.Node node7 = copier.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        node6.next = node7;</span><br><span class="line">        node6.random = node7;</span><br><span class="line">        node7.random = node7;</span><br><span class="line"></span><br><span class="line">        CopyListWithRandomPointer138.Node result2 = copier.copyRandomList(node6);</span><br><span class="line">        copier.printRandomList(result2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 3</span></span><br><span class="line">        CopyListWithRandomPointer138.Node node8 = copier.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        CopyListWithRandomPointer138.Node node9 = copier.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        CopyListWithRandomPointer138.Node node10 = copier.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        node8.next = node9;</span><br><span class="line">        node9.next = node10;</span><br><span class="line">        node9.random = node8;</span><br><span class="line"></span><br><span class="line">        CopyListWithRandomPointer138.Node result3 = copier.copyRandomList(node8);</span><br><span class="line">        copier.printRandomList(result3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node next;</span><br><span class="line">        Node random;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.random = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="92-反转链表-II-lt-medium-gt"><a href="#92-反转链表-II-lt-medium-gt" class="headerlink" title="92. 反转链表 II &lt;medium&gt;"></a>92. 反转链表 II &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,2,3,4,5], left = 2, right = 4</span></span><br><span class="line"><span class="comment">        输出：[1,4,3,2,5]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [5], left = 1, right = 1</span></span><br><span class="line"><span class="comment">        输出：[5]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        链表中节点数目为 n</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 500</span></span><br><span class="line"><span class="comment">        -500 &lt;= Node.val &lt;= 500</span></span><br><span class="line"><span class="comment">        1 &lt;= left &lt;= right &lt;= n*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseLinkedListII92</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="comment">// left前一个节点</span></span><br><span class="line">        ListNode last = head;</span><br><span class="line">        <span class="comment">// right后一个节点</span></span><br><span class="line">        ListNode end = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; left) &#123;</span><br><span class="line">                <span class="comment">// i指向left前最后一个节点</span></span><br><span class="line">                last = current;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= left &amp;&amp; i &lt; right) &#123;</span><br><span class="line">                <span class="comment">// 将i在区域内的节点入栈</span></span><br><span class="line">                stack.push(current);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == right) &#123;</span><br><span class="line">                <span class="comment">// 到达右节点</span></span><br><span class="line">                stack.push(current);</span><br><span class="line">                end = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从head开始反转时，要更新head</span></span><br><span class="line">            head = stack.pop();</span><br><span class="line">            last = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            last.next = stack.pop();</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end != head) &#123;</span><br><span class="line">            last.next = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ReverseLinkedListII92.ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseLinkedListII92 test = <span class="keyword">new</span> ReverseLinkedListII92();</span><br><span class="line"></span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>)))));</span><br><span class="line">        test.printList(test.reverseBetween(l1, <span class="number">2</span>, <span class="number">4</span>)); <span class="comment">// [1,4,3,2,5]</span></span><br><span class="line"></span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        test.printList(test.reverseBetween(l2, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// [5]</span></span><br><span class="line"></span><br><span class="line">        ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>));</span><br><span class="line">        test.printList(test.reverseBetween(l3, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// [5,3]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ReverseLinkedListII92.ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ReverseLinkedListII92.ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接反转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || left == right) <span class="keyword">return</span> head; <span class="comment">// 边界情况，直接返回</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        ListNode last = <span class="keyword">null</span>, start = <span class="keyword">null</span>, end = <span class="keyword">null</span>, prev = <span class="keyword">null</span>, current = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表，找到要反转的部分</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span> &amp;&amp; index &lt;= right) &#123;</span><br><span class="line">            ListNode next = current.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index &lt; left) &#123;</span><br><span class="line">                last = current; <span class="comment">// 记录left前一个节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == left) &#123;</span><br><span class="line">                start = current; <span class="comment">// 记录left开始的节点</span></span><br><span class="line">                prev = <span class="keyword">null</span>; <span class="comment">// 开始反转</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反转 [left, right] 范围内的节点</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= left &amp;&amp; index &lt;= right) &#123;</span><br><span class="line">                current.next = prev;</span><br><span class="line">                prev = current;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index == right) &#123;</span><br><span class="line">                end = next; <span class="comment">// 记录right后一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current = next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接反转后的链表部分</span></span><br><span class="line">        <span class="keyword">if</span> (last != <span class="keyword">null</span>) &#123;</span><br><span class="line">            last.next = prev; <span class="comment">// 连接反转后的头</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = prev; <span class="comment">// 如果 `left == 1`，反转部分变成新的头</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start != <span class="keyword">null</span>) &#123;</span><br><span class="line">            start.next = end; <span class="comment">// 连接反转部分的尾部到end</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个单链表 L 的头节点 head ，单链表 L 表示为：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        L0 → L1 → … → Ln - 1 → Ln</span></span><br><span class="line"><span class="comment">        请将其重新排列后变为：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span></span><br><span class="line"><span class="comment">        不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,2,3,4]</span></span><br><span class="line"><span class="comment">        输出：[1,4,2,3]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">        输出：[1,5,2,4,3]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        链表的长度范围为 [1, 5 * 104]</span></span><br><span class="line"><span class="comment">        1 &lt;= node.val &lt;= 1000*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReorderList143</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    public void reorderList(ListNode head) &#123;</span></span><br><span class="line"><span class="comment">        if (head.next == null) &#123;</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();</span></span><br><span class="line"><span class="comment">        ListNode listNode = head;</span></span><br><span class="line"><span class="comment">        while (listNode != null) &#123;</span></span><br><span class="line"><span class="comment">            stack.push(listNode);</span></span><br><span class="line"><span class="comment">            listNode = listNode.next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ListNode tail = stack.pop();</span></span><br><span class="line"><span class="comment">        while (tail != null) &#123;</span></span><br><span class="line"><span class="comment">            ListNode temp = head.next;</span></span><br><span class="line"><span class="comment">            // 尾节点已经是当前头节点或头节点下个节点</span></span><br><span class="line"><span class="comment">            if (head.equals(tail)) &#123;</span></span><br><span class="line"><span class="comment">                head.next = null;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125; else if (temp.equals(tail)) &#123;</span></span><br><span class="line"><span class="comment">                temp.next = null;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            head.next = tail;</span></span><br><span class="line"><span class="comment">            tail.next = temp;</span></span><br><span class="line"><span class="comment">            tail = stack.pop();</span></span><br><span class="line"><span class="comment">            head = temp;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用双指针（快慢指针）慢指针指向中部</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转后半段链表</span></span><br><span class="line">        ListNode reverse = reverse(slow.next);</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并两个链表</span></span><br><span class="line">        merge(head, reverse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>, curr = node;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(ListNode node1, ListNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next1 = node1.next;</span><br><span class="line">            node1.next = node2;</span><br><span class="line">            ListNode next2 = node2.next;</span><br><span class="line">            <span class="keyword">if</span> (next1 == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            node2.next = next1;</span><br><span class="line">            node1 = next1;</span><br><span class="line">            node2 = next2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReorderList143 test = <span class="keyword">new</span> ReorderList143();</span><br><span class="line">        ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode node4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode node5 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        node3.next = node4;</span><br><span class="line">        node4.next = node5;</span><br><span class="line">        test.reorderList(node1);</span><br><span class="line">        <span class="comment">// 输出：[1,4,2,3]</span></span><br><span class="line">        printNode(node1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="25-K-个一组翻转链表-lt-hard-gt"><a href="#25-K-个一组翻转链表-lt-hard-gt" class="headerlink" title="25. K 个一组翻转链表  &lt;hard&gt;"></a>25. K 个一组翻转链表  &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,2,3,4,5], k = 2</span></span><br><span class="line"><span class="comment">        输出：[2,1,4,3,5]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,2,3,4,5], k = 3</span></span><br><span class="line"><span class="comment">        输出：[3,2,1,4,5]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment">        链表中的节点数目为 n</span></span><br><span class="line"><span class="comment">        1 &lt;= k &lt;= n &lt;= 5000</span></span><br><span class="line"><span class="comment">        0 &lt;= Node.val &lt;= 1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseNodesInKGroup25</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假节点作为首节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode tail = prev;</span><br><span class="line">            <span class="comment">// 检测是否有k个可以反转的节点，tail会指向k后的节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不足k</span></span><br><span class="line">                    <span class="keyword">return</span> dummy.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode nextGroup = tail.next;</span><br><span class="line">            <span class="comment">// 反转当前组head到tail之间的k个节点</span></span><br><span class="line">            ListNode[] reversed = reverse(head, tail);</span><br><span class="line">            head = reversed[<span class="number">0</span>];</span><br><span class="line">            tail = reversed[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将反转组和链表剩余的节点连接</span></span><br><span class="line">            prev.next = head;</span><br><span class="line">            tail.next = nextGroup;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指向后面的节点</span></span><br><span class="line">            prev = tail;</span><br><span class="line">            head = nextGroup;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n) O(1)</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode[] reverse(ListNode head, ListNode tail) &#123;</span><br><span class="line">        <span class="comment">// 反转head到tail之间的节点，并返回两个节点</span></span><br><span class="line">        <span class="comment">// A B C D E  head = A tail = D</span></span><br><span class="line">        ListNode prev = tail.next; <span class="comment">// E</span></span><br><span class="line">        ListNode curr = head; <span class="comment">// A</span></span><br><span class="line">        <span class="keyword">while</span> (prev != tail) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next; <span class="comment">// B</span></span><br><span class="line">            <span class="comment">// A 指向 E</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            <span class="comment">// A作为新的尾节点</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            <span class="comment">// B作为新的头节点</span></span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListNode[] &#123; tail, head &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseNodesInKGroup25 solution = <span class="keyword">new</span> ReverseNodesInKGroup25();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        ListNode head1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>)))));</span><br><span class="line">        <span class="keyword">int</span> k1 = <span class="number">2</span>;</span><br><span class="line">        ListNode result1 = solution.reverseKGroup(head1, k1);</span><br><span class="line">        printList(result1); <span class="comment">// Output: 2 1 4 3 5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        ListNode head2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>)))));</span><br><span class="line">        <span class="keyword">int</span> k2 = <span class="number">3</span>;</span><br><span class="line">        ListNode result2 = solution.reverseKGroup(head2, k2);</span><br><span class="line">        printList(result2); <span class="comment">// Output: 3 2 1 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="19-删除链表的倒数第-N-个结点-lt-medium-gt"><a href="#19-删除链表的倒数第-N-个结点-lt-medium-gt" class="headerlink" title="19. 删除链表的倒数第 N 个结点 &lt;medium&gt;"></a>19. 删除链表的倒数第 N 个结点 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,2,3,4,5], n = 2</span></span><br><span class="line"><span class="comment">        输出：[1,2,3,5]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1], n = 1</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,2], n = 1</span></span><br><span class="line"><span class="comment">        输出：[1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        链表中结点的数目为 sz</span></span><br><span class="line"><span class="comment">        1 &lt;= sz &lt;= 30</span></span><br><span class="line"><span class="comment">        0 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= sz*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveNthNodeFromEndOfList19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//// 假节点作为首节点</span></span><br><span class="line">        <span class="comment">//ListNode dummy = new ListNode(0);</span></span><br><span class="line">        <span class="comment">//dummy.next = head;</span></span><br><span class="line">        <span class="comment">//ListNode curr = head;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// 将节点都入栈</span></span><br><span class="line">        <span class="comment">//Deque&lt;ListNode&gt; stack = new ArrayDeque&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//while (curr != null) &#123;</span></span><br><span class="line">        <span class="comment">//    stack.push(curr);</span></span><br><span class="line">        <span class="comment">//    curr = curr.next;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//int i = 1;</span></span><br><span class="line">        <span class="comment">//ListNode prev = curr;</span></span><br><span class="line">        <span class="comment">//while (i &lt;= n &amp;&amp; !stack.isEmpty()) &#123;</span></span><br><span class="line">        <span class="comment">//    curr = stack.pop();</span></span><br><span class="line">        <span class="comment">//    if (i == n) &#123;</span></span><br><span class="line">        <span class="comment">//        // 到达删除节点</span></span><br><span class="line">        <span class="comment">//        if (stack.isEmpty()) &#123;</span></span><br><span class="line">        <span class="comment">//            // head为要删除节点</span></span><br><span class="line">        <span class="comment">//            return curr.next;</span></span><br><span class="line">        <span class="comment">//        &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//            // 中间节点为删除节点</span></span><br><span class="line">        <span class="comment">//            ListNode next = stack.pop();</span></span><br><span class="line">        <span class="comment">//            next.next = prev;</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//    prev = curr;</span></span><br><span class="line">        <span class="comment">//    i++;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// O(n)</span></span><br><span class="line">        <span class="comment">//return dummy.next;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用快慢指针遍历链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode slow = dummy;</span><br><span class="line">        ListNode fast = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快指针先移动n个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一起移动两个指针，直到快指针到达终点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 慢指针指向的下个节点即为要删除的节点</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RemoveNthNodeFromEndOfList19 solution = <span class="keyword">new</span> RemoveNthNodeFromEndOfList19();</span><br><span class="line"></span><br><span class="line">        ListNode head1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>)))));</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">2</span>;</span><br><span class="line">        ListNode result1 = solution.removeNthFromEnd(head1, n1);</span><br><span class="line">        printList(result1); <span class="comment">// Output: [1,2,3,5]</span></span><br><span class="line"></span><br><span class="line">        ListNode head2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">1</span>;</span><br><span class="line">        ListNode result2 = solution.removeNthFromEnd(head2, n2);</span><br><span class="line">        printList(result2); <span class="comment">// Output: []</span></span><br><span class="line"></span><br><span class="line">        ListNode head3 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">int</span> n3 = <span class="number">1</span>;</span><br><span class="line">        ListNode result3 = solution.removeNthFromEnd(head3, n3);</span><br><span class="line">        printList(result3); <span class="comment">// Output: [1]</span></span><br><span class="line"></span><br><span class="line">        ListNode head4 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">int</span> n4 = <span class="number">2</span>;</span><br><span class="line">        ListNode result4 = solution.removeNthFromEnd(head4, n4);</span><br><span class="line">        printList(result4); <span class="comment">// Output: [2]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="82-删除排序链表中的重复元素-II-lt-medium-gt"><a href="#82-删除排序链表中的重复元素-II-lt-medium-gt" class="headerlink" title="82. 删除排序链表中的重复元素 II &lt;medium&gt;"></a>82. 删除排序链表中的重复元素 II &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,2,3,3,4,4,5]</span></span><br><span class="line"><span class="comment">        输出：[1,2,5]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,1,1,2,3]</span></span><br><span class="line"><span class="comment">        输出：[2,3]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        链表中节点数目在范围 [0, 300] 内</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">        题目数据保证链表已经按升序 排列*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedListII82</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用快慢指针遍历链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">// 指向重复节点前的节点</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        <span class="comment">// 指向重复节点的首节点</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="comment">// 指向重复节点的尾节点</span></span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.val == slow.val) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 有重复节点，删除重复节点，prev不变</span></span><br><span class="line">                prev.next = fast;</span><br><span class="line">                slow = fast;</span><br><span class="line">                <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 无重复节点</span></span><br><span class="line">                prev = prev.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RemoveDuplicatesFromSortedListII82 solution = <span class="keyword">new</span> RemoveDuplicatesFromSortedListII82();</span><br><span class="line"></span><br><span class="line">        ListNode head1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>)))))));</span><br><span class="line">        ListNode result1 = solution.deleteDuplicates(head1);</span><br><span class="line">        printList(result1); <span class="comment">// Output: [1,2,5]</span></span><br><span class="line"></span><br><span class="line">        ListNode head2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">new</span> ListNode(<span class="number">3</span>)))));</span><br><span class="line">        ListNode result2 = solution.deleteDuplicates(head2);</span><br><span class="line">        printList(result2); <span class="comment">// Output: [2,3]</span></span><br><span class="line"></span><br><span class="line">        ListNode head3 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">1</span>));</span><br><span class="line">        ListNode result3 = solution.deleteDuplicates(head3);</span><br><span class="line">        printList(result3); <span class="comment">// Output: []</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="61-旋转链表-lt-medium-gt"><a href="#61-旋转链表-lt-medium-gt" class="headerlink" title="61. 旋转链表 &lt;medium&gt;"></a>61. 旋转链表 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,2,3,4,5], k = 2</span></span><br><span class="line"><span class="comment">        输出：[4,5,1,2,3]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [0,1,2], k = 4</span></span><br><span class="line"><span class="comment">        输出：[2,0,1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        链表中节点的数目在范围 [0, 500] 内</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">        0 &lt;= k &lt;= 2 * 109*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateList61</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || k == <span class="number">0</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        ListNode tail = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算链表长度，并找到尾节点</span></span><br><span class="line">        <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新k</span></span><br><span class="line">        k %= length;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到新头节点的距离</span></span><br><span class="line">        <span class="keyword">int</span> stepsToNewHead = length - k;</span><br><span class="line">        ListNode newTail = head;</span><br><span class="line">        <span class="comment">// 循环获取新的头节点和尾节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stepsToNewHead; i++) &#123;</span><br><span class="line">            newTail = newTail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到后更新头节点，新尾节点，旧尾节点</span></span><br><span class="line">        ListNode newHead = newTail.next;</span><br><span class="line">        newTail.next = <span class="keyword">null</span>;</span><br><span class="line">        tail.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RotateList61 solution = <span class="keyword">new</span> RotateList61();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test cases</span></span><br><span class="line">        ListNode head1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>)))));</span><br><span class="line">        <span class="keyword">int</span> k1 = <span class="number">2</span>;</span><br><span class="line">        ListNode rotated1 = solution.rotateRight(head1, k1);</span><br><span class="line">        printList(rotated1); <span class="comment">// Output: [4,5,1,2,3]</span></span><br><span class="line"></span><br><span class="line">        ListNode head2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>, <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">int</span> k2 = <span class="number">4</span>;</span><br><span class="line">        ListNode rotated2 = solution.rotateRight(head2, k2);</span><br><span class="line">        printList(rotated2); <span class="comment">// Output: [2,0,1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="86-分隔链表-lt-medium-gt"><a href="#86-分隔链表-lt-medium-gt" class="headerlink" title="86. 分隔链表 &lt;medium&gt;"></a>86. 分隔链表 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你应当 保留 两个分区中每个节点的初始相对位置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [1,4,3,2,5,2], x = 3</span></span><br><span class="line"><span class="comment">        输出：[1,2,2,4,3,5]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [2,1], x = 2</span></span><br><span class="line"><span class="comment">        输出：[1,2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        链表中节点的数目在范围 [0, 200] 内</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">        -200 &lt;= x &lt;= 200*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionList86</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储小于x的节点</span></span><br><span class="line">        ListNode beforeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 存储大于x的节点</span></span><br><span class="line">        ListNode afterHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode before = beforeHead;</span><br><span class="line">        ListNode after = afterHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x) &#123;</span><br><span class="line">                <span class="comment">// 小于x放入before链表</span></span><br><span class="line">                before.next = head;</span><br><span class="line">                before = before.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 大于x放入after链表</span></span><br><span class="line">                after.next = head;</span><br><span class="line">                after = after.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将after链表连接到before链表</span></span><br><span class="line">        after.next = <span class="keyword">null</span>;</span><br><span class="line">        before.next = afterHead.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> beforeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PartitionList86 solution = <span class="keyword">new</span> PartitionList86();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test cases</span></span><br><span class="line">        ListNode head1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>, <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>))))));</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">3</span>;</span><br><span class="line">        ListNode partitioned1 = solution.partition(head1, x1);</span><br><span class="line">        printList(partitioned1); <span class="comment">// Output: [1,2,2,4,3,5]</span></span><br><span class="line"></span><br><span class="line">        ListNode head2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>, <span class="keyword">new</span> ListNode(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> x2 = <span class="number">2</span>;</span><br><span class="line">        ListNode partitioned2 = solution.partition(head2, x2);</span><br><span class="line">        printList(partitioned2); <span class="comment">// Output: [1,2]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="146-LRU-缓存-lt-medium-gt"><a href="#146-LRU-缓存-lt-medium-gt" class="headerlink" title="146. LRU 缓存 &lt;medium&gt;"></a>146. LRU 缓存 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。</span></span><br><span class="line"><span class="comment">        实现 LRUCache 类：</span></span><br><span class="line"><span class="comment">        LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</span></span><br><span class="line"><span class="comment">        int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span></span><br><span class="line"><span class="comment">        void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</span></span><br><span class="line"><span class="comment">        函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入</span></span><br><span class="line"><span class="comment">        [&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span></span><br><span class="line"><span class="comment">        [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span></span><br><span class="line"><span class="comment">        输出</span></span><br><span class="line"><span class="comment">        [null, null, null, 1, null, -1, null, -1, 3, 4]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        解释</span></span><br><span class="line"><span class="comment">        LRUCache lRUCache = new LRUCache(2);</span></span><br><span class="line"><span class="comment">        lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span></span><br><span class="line"><span class="comment">        lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span></span><br><span class="line"><span class="comment">        lRUCache.get(1);    // 返回 1</span></span><br><span class="line"><span class="comment">        lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></span><br><span class="line"><span class="comment">        lRUCache.get(2);    // 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment">        lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></span><br><span class="line"><span class="comment">        lRUCache.get(1);    // 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment">        lRUCache.get(3);    // 返回 3</span></span><br><span class="line"><span class="comment">        lRUCache.get(4);    // 返回 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= capacity &lt;= 3000</span></span><br><span class="line"><span class="comment">        0 &lt;= key &lt;= 10000</span></span><br><span class="line"><span class="comment">        0 &lt;= value &lt;= 105</span></span><br><span class="line"><span class="comment">        最多调用 2 * 105 次 get 和 put*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache146</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 存储键值对</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">// 使用双向链表维护节点的顺序，头节点 head 代表最近使用的节点，尾节点 tail 是最久未使用的节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruCache146</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 key 不存在于哈希表中，返回 -1。</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 key 存在于哈希表中，获取节点，将其移动到链表头部（表示最近使用过）并返回值。</span></span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToFront(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">//如果 key 存在于哈希表中，则更新节点值，将其移动到链表头部。</span></span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            addToFront(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果 key 不存在于哈希表中：</span></span><br><span class="line">            <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">                <span class="comment">//如果当前缓存已满，则删除链表尾部节点（表示最久未使用），从哈希表中删除对应项。</span></span><br><span class="line">                Node lastNode = tail.prev;</span><br><span class="line">                removeNode(lastNode);</span><br><span class="line">                map.remove(lastNode.key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建新节点并添加到链表头部，并在哈希表中添加对应项。</span></span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            addToFront(newNode);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        Node prevNode = node.prev;</span><br><span class="line">        Node nextNode = node.next;</span><br><span class="line">        prevNode.next = nextNode;</span><br><span class="line">        nextNode.prev = prevNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToFront</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将节点加到头部</span></span><br><span class="line">        Node nextNode = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = nextNode;</span><br><span class="line">        nextNode.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h4 id="460-LFU缓存-lt-hard-gt"><a href="#460-LFU缓存-lt-hard-gt" class="headerlink" title="460. LFU缓存 &lt;hard&gt;"></a>460. LFU缓存 &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LFUCache460</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LFU删除最不经常使用的元素，所以要维护一个计数器，统计每个元素的使用次数。</span></span><br><span class="line">    <span class="comment">// 当存在平局时，应该去除 最久未使用 的键。即LRU。</span></span><br><span class="line">    <span class="comment">// minFreq 记录当前最小访问次数，用于快速删除 LFU 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity, minFreq;</span><br><span class="line">    <span class="comment">// 存储键值对，快速访问 LFU 缓存中的 Node</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; keyToNode;</span><br><span class="line">    <span class="comment">// 存储访问次数对应的 双向链表，按 LRU 规则排序，用于管理相同访问次数的节点</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DoublyLinkedList&gt; freqToList;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key, value, freq;</span><br><span class="line">        Node prev, next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.freq = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> </span>&#123;</span><br><span class="line">        Node head, tail;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoublyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>); <span class="comment">// 哨兵头</span></span><br><span class="line">            tail = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>); <span class="comment">// 哨兵尾</span></span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.prev = head;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span> </span>&#123; <span class="comment">// 插入到头部（最新）</span></span><br><span class="line">            node.next = head.next;</span><br><span class="line">            node.prev = head;</span><br><span class="line">            head.next.prev = node;</span><br><span class="line">            head.next = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123; <span class="comment">// 从链表移除</span></span><br><span class="line">            node.prev.next = node.next;</span><br><span class="line">            node.next.prev = node.prev;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node <span class="title">removeLast</span><span class="params">()</span> </span>&#123; <span class="comment">// 移除尾部节点（最久未使用）</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node node = tail.prev;</span><br><span class="line">                removeNode(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache460</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.keyToNode = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.freqToList = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(1) 哈希表查找 + 更新频率</span></span><br><span class="line">        <span class="keyword">if</span> (!keyToNode.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node node = keyToNode.get(key);</span><br><span class="line">        updateFreq(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(1) 哈希表插入 + 可能移除 LFU</span></span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keyToNode.containsKey(key)) &#123;</span><br><span class="line">            Node node = keyToNode.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            updateFreq(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存已满，移除 LFU 节点</span></span><br><span class="line">        <span class="keyword">if</span> (keyToNode.size() &gt;= capacity) &#123;</span><br><span class="line">            removeLFUNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入新节点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        keyToNode.put(key, newNode);</span><br><span class="line">        freqToList.computeIfAbsent(<span class="number">1</span>, k -&gt; <span class="keyword">new</span> DoublyLinkedList()).addNode(newNode);</span><br><span class="line">        minFreq = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateFreq</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次操作要更新频率</span></span><br><span class="line">        <span class="comment">// 首先从freqToList中移除旧的节点</span></span><br><span class="line">        <span class="keyword">int</span> freq = node.freq;</span><br><span class="line">        freqToList.get(freq).removeNode(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若当前节点是唯一最少使用节点，则要更新 minFreq，并移除freqToList的整个频率</span></span><br><span class="line">        <span class="keyword">if</span> (freq == minFreq &amp;&amp; freqToList.get(freq).size == <span class="number">0</span>) &#123;</span><br><span class="line">            minFreq++;</span><br><span class="line">            freqToList.remove(freq);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加频率，并将新的频率关系放入freqToList，若不存在则新建双向链表</span></span><br><span class="line">        node.freq++;</span><br><span class="line">        freqToList.computeIfAbsent(node.freq, k -&gt; <span class="keyword">new</span> DoublyLinkedList()).addNode(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLFUNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LFU已满，则移除最小使用频率中的最久未使用节点，即minFreq对应双向链表的尾节点</span></span><br><span class="line">        DoublyLinkedList minFreqList = freqToList.get(minFreq);</span><br><span class="line">        Node lfuNode = minFreqList.removeLast();</span><br><span class="line">        keyToNode.remove(lfuNode.key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若minFreq是唯一节点，则移除整个freq</span></span><br><span class="line">        <span class="keyword">if</span> (minFreqList.size == <span class="number">0</span>) &#123;</span><br><span class="line">            freqToList.remove(minFreq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LFUCache460 cache = <span class="keyword">new</span> LFUCache460(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>)); <span class="comment">// 返回 1</span></span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// 2 被移除（因为 2 和 1 频率相同，但 1 更久未使用）</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">2</span>)); <span class="comment">// 返回 -1（已被移除）</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">3</span>)); <span class="comment">// 返回 3</span></span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>); <span class="comment">// 1 被移除</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>)); <span class="comment">// 返回 -1（已被移除）</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">3</span>)); <span class="comment">// 返回 3</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">4</span>)); <span class="comment">// 返回 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-9-二叉树-Binary-Tree"><a href="#3-9-二叉树-Binary-Tree" class="headerlink" title="3.9 二叉树 Binary Tree"></a>3.9 二叉树 Binary Tree</h3><ol>
<li>递归算法</li>
<li>几种遍历二叉树的方式<ul>
<li>前序、中序、后序：非递归使用栈</li>
<li>层级遍历：非递归使用链表</li>
</ul>
</li>
<li></li>
</ol>
<h4 id="104-二叉树的最大深度-lt-easy-gt"><a href="#104-二叉树的最大深度-lt-easy-gt" class="headerlink" title="104. 二叉树的最大深度  &lt;easy&gt;"></a>104. 二叉树的最大深度  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个二叉树 root ，返回其最大深度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,null,2]</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点的数量在 [0, 104] 区间内。</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumDepthOfBinaryTree104</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.递归实现</span></span><br><span class="line">        <span class="comment">//if (root == null) &#123;</span></span><br><span class="line">        <span class="comment">//    return 0; // 如果根节点为空，深度为0</span></span><br><span class="line">        <span class="comment">//&#125; else &#123;</span></span><br><span class="line">        <span class="comment">//    // 计算左子树和右子树的深度</span></span><br><span class="line">        <span class="comment">//    int leftDepth = maxDepth(root.left);</span></span><br><span class="line">        <span class="comment">//    int rightDepth = maxDepth(root.right);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//    // 返回较大的深度再加上根节点的高度（即 1）</span></span><br><span class="line">        <span class="comment">//    return Math.max(leftDepth, rightDepth) + 1;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">// 2.非递归实现</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果根节点为空，深度为0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">// 当前层的节点数</span></span><br><span class="line">            depth++; <span class="comment">// 每遍历一层深度加一</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前层的所有节点，并将下一层节点加入队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaximumDepthOfBinaryTree104 solution = <span class="keyword">new</span> MaximumDepthOfBinaryTree104();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建示例二叉树</span></span><br><span class="line">        MaximumDepthOfBinaryTree104.TreeNode root = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        root.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">        root.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">        root.right.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">        root.right.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最大深度并打印结果</span></span><br><span class="line">        <span class="keyword">int</span> depth = solution.maxDepth(root);</span><br><span class="line">        System.out.println(<span class="string">&quot;Maximum Depth of Binary Tree: &quot;</span> + depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="100-相同的树-lt-easy-gt"><a href="#100-相同的树-lt-easy-gt" class="headerlink" title="100. 相同的树  &lt;easy&gt;"></a>100. 相同的树  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：p = [1,2,3], q = [1,2,3]</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：p = [1,2], q = [1,null,2]</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：p = [1,2,1], q = [1,1,2]</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        两棵树上的节点数目都在范围 [0, 100] 内</span></span><br><span class="line"><span class="comment">        -104 &lt;= Node.val &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameTree100</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> p == q;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack1.push(p);</span><br><span class="line">        stack2.push(q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历二叉树p，对比同结构q</span></span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">            TreeNode node1 = stack1.pop();</span><br><span class="line">            TreeNode node2 = stack2.pop();</span><br><span class="line">            <span class="keyword">if</span> (node1.val != node2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node1.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node2.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack1.push(node1.right);</span><br><span class="line">                    stack2.push(node2.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node2.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack2.push(node2.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node1.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node2.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack1.push(node1.left);</span><br><span class="line">                    stack2.push(node2.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node2.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack2.push(node2.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历完后如果q还有节点，则不一致</span></span><br><span class="line">        <span class="keyword">return</span> stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SameTree100 solution = <span class="keyword">new</span> SameTree100();</span><br><span class="line"></span><br><span class="line">        SameTree100.TreeNode p1 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        p1.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        p1.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        SameTree100.TreeNode q1 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        q1.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        q1.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(solution.isSameTree(p1, q1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        SameTree100.TreeNode p2 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        p2.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        SameTree100.TreeNode q2 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        q2.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(solution.isSameTree(p2, q2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        SameTree100.TreeNode p3 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        p3.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        p3.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        SameTree100.TreeNode q3 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        p3.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        q3.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(solution.isSameTree(p3, q3)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        SameTree100.TreeNode p4 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        SameTree100.TreeNode q4 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        q4.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(solution.isSameTree(p4, q4)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="226-翻转二叉树-lt-easy-gt"><a href="#226-翻转二叉树-lt-easy-gt" class="headerlink" title="226. 翻转二叉树  &lt;easy&gt;"></a>226. 翻转二叉树  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [4,2,7,1,3,6,9]</span></span><br><span class="line"><span class="comment">        输出：[4,7,2,9,6,3,1]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [2,1,3]</span></span><br><span class="line"><span class="comment">        输出：[2,3,1]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = []</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点数目范围在 [0, 100] 内</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvertBinaryTree226</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历二叉树，将左右子节点互换</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            TreeNode temp = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvertBinaryTree226 solution = <span class="keyword">new</span> InvertBinaryTree226();</span><br><span class="line"></span><br><span class="line">        TreeNode p1 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">        p1.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        p1.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">        p1.left.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        p1.left.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        p1.right.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">        p1.right.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        printTree(solution.invertTree(p1)); <span class="comment">// [4,7,2,9,6,3,1]</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        TreeNode p2 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        p2.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        p2.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        printTree(solution.invertTree(p2)); <span class="comment">// [2,3,1]</span></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        TreeNode p3 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        printTree(solution.invertTree(p3)); <span class="comment">// []</span></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        printTree(root.left);</span><br><span class="line">        printTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="101-对称二叉树-lt-easy-gt"><a href="#101-对称二叉树-lt-easy-gt" class="headerlink" title="101. 对称二叉树  &lt;easy&gt;"></a>101. 对称二叉树  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个二叉树的根节点 root ， 检查它是否轴对称。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,2,2,3,4,4,3]</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,2,2,null,3,null,3]</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点数目在范围 [1, 1000] 内</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：你可以运用递归和迭代两种方法解决这个问题吗？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricTree101</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归实现</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n)，空间复杂度是 O(logN) 到 O(N)</span></span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left.val == right.val) &amp;&amp;</span><br><span class="line">                isMirror(left.left, right.right) &amp;&amp;</span><br><span class="line">                isMirror(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SymmetricTree101 solution = <span class="keyword">new</span> SymmetricTree101();</span><br><span class="line"></span><br><span class="line">        TreeNode p1 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        p1.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        p1.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        p1.left.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        p1.left.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">        p1.right.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">        p1.right.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        System.out.println(solution.isSymmetric(p1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        TreeNode p2 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        p2.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        p2.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        p2.left.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        p2.right.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        System.out.println(solution.isSymmetric(p2)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="105-从前序与中序遍历序列构造二叉树-lt-medium-gt"><a href="#105-从前序与中序遍历序列构造二叉树-lt-medium-gt" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树 &lt;medium&gt;"></a>105. 从前序与中序遍历序列构造二叉树 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span></span><br><span class="line"><span class="comment">        输出: [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: preorder = [-1], inorder = [-1]</span></span><br><span class="line"><span class="comment">        输出: [-1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= preorder.length &lt;= 3000</span></span><br><span class="line"><span class="comment">        inorder.length == preorder.length</span></span><br><span class="line"><span class="comment">        -3000 &lt;= preorder[i], inorder[i] &lt;= 3000</span></span><br><span class="line"><span class="comment">        preorder 和 inorder 均 无重复 元素</span></span><br><span class="line"><span class="comment">        inorder 均出现在 preorder</span></span><br><span class="line"><span class="comment">        preorder 保证 为二叉树的前序遍历序列</span></span><br><span class="line"><span class="comment">        inorder 保证 为二叉树的中序遍历序列*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructBinaryTreeFromPreorderAndInorderTraversal105</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归实现</span></span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前根节点</span></span><br><span class="line">        <span class="keyword">int</span> rootValue = preorder[preStart];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历中序数组，获取当前根节点下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootValue) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树的大小 = 根节点下标 - 起始下标</span></span><br><span class="line">        <span class="keyword">int</span> leftTreeSize = rootIndex - inStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树 前序数组前leftTreeSize截取到，中序数组更新结束下标为根节点前</span></span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftTreeSize,</span><br><span class="line">                inorder, inStart, rootIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 右子树 前序数组leftTreeSize后，中序数组更新开始下标为根节点后</span></span><br><span class="line">        root.right = build(preorder, preStart + leftTreeSize + <span class="number">1</span>, preEnd,</span><br><span class="line">                inorder, rootIndex + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConstructBinaryTreeFromPreorderAndInorderTraversal105 solution = <span class="keyword">new</span> ConstructBinaryTreeFromPreorderAndInorderTraversal105();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] preorder1 = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] inorder1 = &#123;<span class="number">9</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        TreeNode result1 = solution.buildTree(preorder1, inorder1);</span><br><span class="line">        solution.printTree(result1); <span class="comment">// Output: [3,9,20,null,null,15,7]</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">int</span>[] preorder2 = &#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] inorder2 = &#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        TreeNode result2 = solution.buildTree(preorder2, inorder2);</span><br><span class="line">        solution.printTree(result2); <span class="comment">// Output: [-1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;null &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        printTree(root.left);</span><br><span class="line">        printTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="106-从中序与后序遍历序列构造二叉树-lt-medium-gt"><a href="#106-从中序与后序遍历序列构造二叉树-lt-medium-gt" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树 &lt;medium&gt;"></a>106. 从中序与后序遍历序列构造二叉树 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span></span><br><span class="line"><span class="comment">        输出：[3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：inorder = [-1], postorder = [-1]</span></span><br><span class="line"><span class="comment">        输出：[-1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= inorder.length &lt;= 3000</span></span><br><span class="line"><span class="comment">        postorder.length == inorder.length</span></span><br><span class="line"><span class="comment">        -3000 &lt;= inorder[i], postorder[i] &lt;= 3000</span></span><br><span class="line"><span class="comment">        inorder 和 postorder 都由 不同 的值组成</span></span><br><span class="line"><span class="comment">        postorder 中每一个值都在 inorder 中</span></span><br><span class="line"><span class="comment">        inorder 保证是树的中序遍历</span></span><br><span class="line"><span class="comment">        postorder 保证是树的后序遍历*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructBinaryTreeFromInorderAndPostorderTraversal106</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.length != postorder.length || inorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历中序数组，存储根节点与下标的对应关系</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归实现</span></span><br><span class="line">        <span class="keyword">return</span> build(inorder, postorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, <span class="number">0</span>, postorder.length - <span class="number">1</span>, indexMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd, Map&lt;Integer, Integer&gt; indexMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历的最后一个元素是树的根节点，通过这个根节点可以将中序遍历数组分成左右子树的部分</span></span><br><span class="line">        <span class="keyword">int</span> rootValue = postorder[postEnd];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树的大小 = 根节点下标 - 起始下标</span></span><br><span class="line">        <span class="keyword">int</span> rootIndex = indexMap.get(rootValue);</span><br><span class="line">        <span class="keyword">int</span> leftSubtreeSize = rootIndex - inStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树 后序数组前leftTreeSize截取到，中序数组更新结束下标为根节点前</span></span><br><span class="line">        root.left = build(inorder, postorder, inStart, rootIndex - <span class="number">1</span>, postStart, postStart + leftSubtreeSize - <span class="number">1</span>, indexMap);</span><br><span class="line">        <span class="comment">// 右子树 后序数组leftTreeSize后，中序数组更新开始下标为根节点后</span></span><br><span class="line">        root.right = build(inorder, postorder, rootIndex + <span class="number">1</span>, inEnd, postStart + leftSubtreeSize, postEnd - <span class="number">1</span>, indexMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConstructBinaryTreeFromInorderAndPostorderTraversal106 solution = <span class="keyword">new</span> ConstructBinaryTreeFromInorderAndPostorderTraversal106();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] preorder1 = &#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] inorder1 = &#123;<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        TreeNode result1 = solution.buildTree(preorder1, inorder1);</span><br><span class="line">        solution.printTree(result1); <span class="comment">// Output: [3,9,20,null,null,15,7]</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">int</span>[] preorder2 = &#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] inorder2 = &#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        TreeNode result2 = solution.buildTree(preorder2, inorder2);</span><br><span class="line">        solution.printTree(result2); <span class="comment">// Output: [-1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;null &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        printTree(root.left);</span><br><span class="line">        printTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="117-填充每个节点的下一个右侧节点指针-II-lt-medium-gt"><a href="#117-填充每个节点的下一个右侧节点指针-II-lt-medium-gt" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II &lt;medium&gt;"></a>117. 填充每个节点的下一个右侧节点指针 II &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个二叉树：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        struct Node &#123;</span></span><br><span class="line"><span class="comment">        int val;</span></span><br><span class="line"><span class="comment">        Node *left;</span></span><br><span class="line"><span class="comment">        Node *right;</span></span><br><span class="line"><span class="comment">        Node *next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        初始状态下，所有 next 指针都被设置为 NULL 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,2,3,4,5,null,7]</span></span><br><span class="line"><span class="comment">        输出：[1,#,2,3,#,4,5,7,#]</span></span><br><span class="line"><span class="comment">        解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#x27;#&#x27; 表示每层的末尾。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = []</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中的节点数在范围 [0, 6000] 内</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100</span></span><br><span class="line"><span class="comment">        进阶：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你只能使用常量级额外空间。</span></span><br><span class="line"><span class="comment">        使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PopulatingNextRightPointersInEachNodeII117</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.非递归，空间O(n)</span></span><br><span class="line">        <span class="comment">//if (root == null) &#123;</span></span><br><span class="line">        <span class="comment">//    return null;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// 存放同层节点</span></span><br><span class="line">        <span class="comment">//Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//queue.offer(root);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//while (!queue.isEmpty()) &#123;</span></span><br><span class="line">        <span class="comment">//    // 本层节点数</span></span><br><span class="line">        <span class="comment">//    int levelSize = queue.size();</span></span><br><span class="line">        <span class="comment">//    for (int i = 0; i &lt; levelSize; i++) &#123;</span></span><br><span class="line">        <span class="comment">//        Node node = queue.poll();</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//        // 有右边节点，则更新next节点</span></span><br><span class="line">        <span class="comment">//        if (i &lt; levelSize - 1) &#123;</span></span><br><span class="line">        <span class="comment">//            node.next = queue.peek();</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//        // 先左后右将下层节点分别放入链表</span></span><br><span class="line">        <span class="comment">//        if (node.left != null) &#123;</span></span><br><span class="line">        <span class="comment">//            queue.offer(node.left);</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//        if (node.right != null) &#123;</span></span><br><span class="line">        <span class="comment">//            queue.offer(node.right);</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// O(n) O(n)</span></span><br><span class="line">        <span class="comment">//return root;</span></span><br><span class="line">        <span class="comment">// 2.非递归</span></span><br><span class="line">        <span class="comment">// 指针指向同层开始节点</span></span><br><span class="line">        Node levelStart = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (levelStart != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node current = levelStart;</span><br><span class="line">            <span class="comment">// 虚拟节点，作为下一层节点的前一个节点，串联起同层的所有节点</span></span><br><span class="line">            Node dummy = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">            Node prev = dummy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 沿着current的子节点，横向连接</span></span><br><span class="line">                <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 有左节点，则prev更新为left</span></span><br><span class="line">                    prev.next = current.left;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 有右节点，连接后更新为右节点</span></span><br><span class="line">                    prev.next = current.right;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// current也更新为同层后一个节点</span></span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前层遍历结束后，将levelStart指针指向下一层最左侧节点</span></span><br><span class="line">            levelStart = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n) O(1)</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Testing the solution</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PopulatingNextRightPointersInEachNodeII117 solution = <span class="keyword">new</span> PopulatingNextRightPointersInEachNodeII117();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 1</span></span><br><span class="line">        Node root1 = solution.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        root1.left = solution.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        root1.right = solution.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        root1.left.left = solution.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">        root1.left.right = solution.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">        root1.right.right = solution.n<span class="function">ew <span class="title">Node</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        Node result1 = solution.connect(root1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Example 1:&quot;</span>);</span><br><span class="line">        solution.printNextPointers(result1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 2</span></span><br><span class="line">        Node root2 = <span class="keyword">null</span>;</span><br><span class="line">        Node result2 = solution.connect(root2);</span><br><span class="line">        System.out.println(<span class="string">&quot;\nExample 2:&quot;</span>);</span><br><span class="line">        solution.printNextPointers(result2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printNextPointers</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node current = root;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(current.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;# &quot;</span>); <span class="comment">// Denotes the end of a level</span></span><br><span class="line">            root = root.left; <span class="comment">// Move to the next level</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">            val = _val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, Node _left, Node _right, Node _next)</span> </span>&#123;</span><br><span class="line">            val = _val;</span><br><span class="line">            left = _left;</span><br><span class="line">            right = _right;</span><br><span class="line">            next = _next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="114-二叉树展开为链表-lt-medium-gt"><a href="#114-二叉树展开为链表-lt-medium-gt" class="headerlink" title="114. 二叉树展开为链表 &lt;medium&gt;"></a>114. 二叉树展开为链表 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你二叉树的根结点 root ，请你将它展开为一个单链表：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</span></span><br><span class="line"><span class="comment">        展开后的单链表应该与二叉树 先序遍历 顺序相同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,2,5,3,4,null,6]</span></span><br><span class="line"><span class="comment">        输出：[1,null,2,null,3,null,4,null,5,null,6]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = []</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [0]</span></span><br><span class="line"><span class="comment">        输出：[0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中结点数在范围 [0, 2000] 内</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlattenBinaryTreeToLinkedList114</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存右子树</span></span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line">        <span class="comment">// 右指针指向左子树</span></span><br><span class="line">        root.right = root.left;</span><br><span class="line">        <span class="comment">// 左子树设为空</span></span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到已展开的右子树的最右边节点</span></span><br><span class="line">        TreeNode current = root;</span><br><span class="line">        <span class="keyword">while</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将保存的右子树连接到已展开的左子树的最右边节点的右边</span></span><br><span class="line">        current.right = right; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test the implementation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlattenBinaryTreeToLinkedList114 solution = <span class="keyword">new</span> FlattenBinaryTreeToLinkedList114();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 1</span></span><br><span class="line">        TreeNode root1 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        root1.left = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">2</span>, solution.new TreeNode(<span class="number">3</span>)</span>, solution.new <span class="title">TreeNode</span><span class="params">(<span class="number">4</span>)</span>)</span>;</span><br><span class="line">        root1.right = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">5</span>, <span class="keyword">null</span>, solution.new TreeNode(<span class="number">6</span>)</span>)</span>;</span><br><span class="line">        solution.flatten(root1);</span><br><span class="line">        printLinkedList(root1); <span class="comment">// Output: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 2</span></span><br><span class="line">        TreeNode root2 = <span class="keyword">null</span>;</span><br><span class="line">        solution.flatten(root2); <span class="comment">// Output: null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 3</span></span><br><span class="line">        TreeNode root3 = solution.n<span class="function">ew <span class="title">TreeNode</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        solution.flatten(root3);</span><br><span class="line">        printLinkedList(root3); <span class="comment">// Output: 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helper function to print the linked list</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(root.val + <span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="112-路径总和-lt-easy-gt"><a href="#112-路径总和-lt-easy-gt" class="headerlink" title="112. 路径总和  &lt;easy&gt;"></a>112. 路径总和  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        叶子节点 是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        解释：等于目标和的根节点到叶节点路径如上图所示。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,2,3], targetSum = 5</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        解释：树中存在两条根节点到叶子节点的路径：</span></span><br><span class="line"><span class="comment">        (1 --&gt; 2): 和为 3</span></span><br><span class="line"><span class="comment">        (1 --&gt; 3): 和为 4</span></span><br><span class="line"><span class="comment">        不存在 sum = 5 的根节点到叶子节点的路径。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [], targetSum = 0</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点的数目在范围 [0, 5000] 内</span></span><br><span class="line"><span class="comment">        -1000 &lt;= Node.val &lt;= 1000</span></span><br><span class="line"><span class="comment">        -1000 &lt;= targetSum &lt;= 1000*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum112</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代判断二叉树是否满足条件</span></span><br><span class="line">        <span class="keyword">boolean</span> left = hasPathSum(root.left, targetSum - root.val);</span><br><span class="line">        <span class="keyword">boolean</span> right = hasPathSum(root.right, targetSum - root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任一满足即可</span></span><br><span class="line">        <span class="keyword">return</span> left || right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PathSum112 solution = <span class="keyword">new</span> PathSum112();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test cases</span></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root1.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>, <span class="keyword">new</span> TreeNode(<span class="number">11</span>, <span class="keyword">new</span> TreeNode(<span class="number">7</span>), <span class="keyword">new</span> TreeNode(<span class="number">2</span>)), <span class="keyword">null</span>);</span><br><span class="line">        root1.right = <span class="keyword">new</span> TreeNode(<span class="number">8</span>, <span class="keyword">new</span> TreeNode(<span class="number">13</span>), <span class="keyword">new</span> TreeNode(<span class="number">4</span>, <span class="keyword">null</span>, <span class="keyword">new</span> TreeNode(<span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">int</span> targetSum1 = <span class="number">22</span>;</span><br><span class="line">        System.out.println(solution.hasPathSum(root1, targetSum1)); <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        TreeNode root2 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>, <span class="keyword">new</span> TreeNode(<span class="number">2</span>), <span class="keyword">new</span> TreeNode(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">int</span> targetSum2 = <span class="number">5</span>;</span><br><span class="line">        System.out.println(solution.hasPathSum(root2, targetSum2)); <span class="comment">// Output: false</span></span><br><span class="line"></span><br><span class="line">        TreeNode root3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> targetSum3 = <span class="number">0</span>;</span><br><span class="line">        System.out.println(solution.hasPathSum(root3, targetSum3)); <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="129-求根节点到叶节点数字之和-lt-medium-gt"><a href="#129-求根节点到叶节点数字之和-lt-medium-gt" class="headerlink" title="129. 求根节点到叶节点数字之和 &lt;medium&gt;"></a>129. 求根节点到叶节点数字之和 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。</span></span><br><span class="line"><span class="comment">        每条从根节点到叶节点的路径都代表一个数字：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。</span></span><br><span class="line"><span class="comment">        计算从根节点到叶节点生成的 所有数字之和 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        叶节点 是指没有子节点的节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,2,3]</span></span><br><span class="line"><span class="comment">        输出：25</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        从根到叶子节点路径 1-&gt;2 代表数字 12</span></span><br><span class="line"><span class="comment">        从根到叶子节点路径 1-&gt;3 代表数字 13</span></span><br><span class="line"><span class="comment">        因此，数字总和 = 12 + 13 = 25</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [4,9,0,5,1]</span></span><br><span class="line"><span class="comment">        输出：1026</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495</span></span><br><span class="line"><span class="comment">        从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491</span></span><br><span class="line"><span class="comment">        从根到叶子节点路径 4-&gt;0 代表数字 40</span></span><br><span class="line"><span class="comment">        因此，数字总和 = 495 + 491 + 40 = 1026</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点的数目在范围 [1, 1000] 内</span></span><br><span class="line"><span class="comment">        0 &lt;= Node.val &lt;= 9</span></span><br><span class="line"><span class="comment">        树的深度不超过 10*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumRootToLeafNumbers129</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> currSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接当前节点数字</span></span><br><span class="line">        currSum = currSum * <span class="number">10</span> + node.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 叶子节点就返回结果数字</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> currSum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非叶子节点则递归子树</span></span><br><span class="line">        <span class="keyword">int</span> leftSum = dfs(node.left, currSum);</span><br><span class="line">        <span class="keyword">int</span> rightSum = dfs(node.right, currSum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SumRootToLeafNumbers129 solution = <span class="keyword">new</span> SumRootToLeafNumbers129();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test cases</span></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>, <span class="keyword">new</span> TreeNode(<span class="number">2</span>), <span class="keyword">new</span> TreeNode(<span class="number">3</span>));</span><br><span class="line">        System.out.println(solution.sumNumbers(root1)); <span class="comment">// Output: 25</span></span><br><span class="line"></span><br><span class="line">        TreeNode root2 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>, <span class="keyword">new</span> TreeNode(<span class="number">9</span>, <span class="keyword">new</span> TreeNode(<span class="number">5</span>), <span class="keyword">new</span> TreeNode(<span class="number">1</span>)), <span class="keyword">new</span> TreeNode(<span class="number">0</span>));</span><br><span class="line">        System.out.println(solution.sumNumbers(root2)); <span class="comment">// Output: 1026</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="124-二叉树中的最大路径和-lt-hard-gt"><a href="#124-二叉树中的最大路径和-lt-hard-gt" class="headerlink" title="124. 二叉树中的最大路径和  &lt;hard&gt;"></a>124. 二叉树中的最大路径和  &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        路径和 是路径中各节点值的总和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给你一个二叉树的根节点 root ，返回其 最大路径和 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,2,3]</span></span><br><span class="line"><span class="comment">        输出：6</span></span><br><span class="line"><span class="comment">        解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [-10,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">        输出：42</span></span><br><span class="line"><span class="comment">        解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点数目范围是 [1, 3 * 104]</span></span><br><span class="line"><span class="comment">        -1000 &lt;= Node.val &lt;= 1000*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeMaximumPathSum124</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归获取最大路径和</span></span><br><span class="line">        maxPathSumHelper(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathSumHelper</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别获取左子树和右子树的最大和</span></span><br><span class="line">        <span class="keyword">int</span> leftSum = Math.max(maxPathSumHelper(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightSum = Math.max(maxPathSumHelper(node.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前节点的最大和</span></span><br><span class="line">        maxSum = Math.max(maxSum, node.val + leftSum + rightSum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回从当前节点开始的最大路径和</span></span><br><span class="line">        <span class="keyword">return</span> node.val + Math.max(leftSum, rightSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTreeMaximumPathSum124 solution = <span class="keyword">new</span> BinaryTreeMaximumPathSum124();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test cases</span></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>, <span class="keyword">new</span> TreeNode(<span class="number">2</span>), <span class="keyword">new</span> TreeNode(<span class="number">3</span>));</span><br><span class="line">        System.out.println(solution.maxPathSum(root1)); <span class="comment">// Output: 6</span></span><br><span class="line"></span><br><span class="line">        TreeNode root2 = <span class="keyword">new</span> TreeNode(-<span class="number">10</span>, <span class="keyword">new</span> TreeNode(<span class="number">9</span>), <span class="keyword">new</span> TreeNode(<span class="number">20</span>, <span class="keyword">new</span> TreeNode(<span class="number">15</span>), <span class="keyword">new</span> TreeNode(<span class="number">7</span>)));</span><br><span class="line">        System.out.println(solution.maxPathSum(root2)); <span class="comment">// Output: 42</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="173-二叉搜索树迭代器-lt-medium-gt"><a href="#173-二叉搜索树迭代器-lt-medium-gt" class="headerlink" title="173. 二叉搜索树迭代器 &lt;medium&gt;"></a>173. 二叉搜索树迭代器 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</span></span><br><span class="line"><span class="comment">        BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</span></span><br><span class="line"><span class="comment">        boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。</span></span><br><span class="line"><span class="comment">        int next()将指针向右移动，然后返回指针处的数字。</span></span><br><span class="line"><span class="comment">        注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入</span></span><br><span class="line"><span class="comment">        [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span></span><br><span class="line"><span class="comment">        [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]</span></span><br><span class="line"><span class="comment">        输出</span></span><br><span class="line"><span class="comment">        [null, 3, 7, true, 9, true, 15, true, 20, false]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        解释</span></span><br><span class="line"><span class="comment">        BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);</span></span><br><span class="line"><span class="comment">        bSTIterator.next();    // 返回 3</span></span><br><span class="line"><span class="comment">        bSTIterator.next();    // 返回 7</span></span><br><span class="line"><span class="comment">        bSTIterator.hasNext(); // 返回 True</span></span><br><span class="line"><span class="comment">        bSTIterator.next();    // 返回 9</span></span><br><span class="line"><span class="comment">        bSTIterator.hasNext(); // 返回 True</span></span><br><span class="line"><span class="comment">        bSTIterator.next();    // 返回 15</span></span><br><span class="line"><span class="comment">        bSTIterator.hasNext(); // 返回 True</span></span><br><span class="line"><span class="comment">        bSTIterator.next();    // 返回 20</span></span><br><span class="line"><span class="comment">        bSTIterator.hasNext(); // 返回 False</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点的数目在范围 [1, 105] 内</span></span><br><span class="line"><span class="comment">        0 &lt;= Node.val &lt;= 106</span></span><br><span class="line"><span class="comment">        最多调用 105 次 hasNext 和 next 操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeIterator173</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTreeIterator173</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</span></span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        leftmostInorder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftmostInorder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历节点将左子树入栈，直到叶子节点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将指针向右移动，然后返回指针处的数字。</span></span><br><span class="line">        TreeNode topNode = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (topNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            leftmostInorder(topNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false</span></span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">15</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> TreeNode(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        BinarySearchTreeIterator173 iterator = <span class="keyword">new</span> BinarySearchTreeIterator173(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(iterator.next());    <span class="comment">// Output: 3</span></span><br><span class="line">        System.out.println(iterator.next());    <span class="comment">// Output: 7</span></span><br><span class="line">        System.out.println(iterator.hasNext()); <span class="comment">// Output: true</span></span><br><span class="line">        System.out.println(iterator.next());    <span class="comment">// Output: 9</span></span><br><span class="line">        System.out.println(iterator.hasNext()); <span class="comment">// Output: true</span></span><br><span class="line">        System.out.println(iterator.next());    <span class="comment">// Output: 15</span></span><br><span class="line">        System.out.println(iterator.hasNext()); <span class="comment">// Output: true</span></span><br><span class="line">        System.out.println(iterator.next());    <span class="comment">// Output: 20</span></span><br><span class="line">        System.out.println(iterator.hasNext()); <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="222-完全二叉树的节点个数-lt-easy-gt"><a href="#222-完全二叉树的节点个数-lt-easy-gt" class="headerlink" title="222. 完全二叉树的节点个数  &lt;easy&gt;"></a>222. 完全二叉树的节点个数  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">        输出：6</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = []</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点的数目范围是[0, 5 * 104]</span></span><br><span class="line"><span class="comment">        0 &lt;= Node.val &lt;= 5 * 104</span></span><br><span class="line"><span class="comment">        题目数据保证输入的树是 完全二叉树</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountCompleteTreeNodes222</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左右子树的高度</span></span><br><span class="line">        <span class="keyword">int</span> leftHeight = getLeftHeight(root);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = getRightHeight(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右子树高度相同，二叉树完全对仗，直接返回节点数为2的leftHeight次方-1</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight == rightHeight) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftHeight) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若非完全对仗，则迭代分别获取左右子节点的节点数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLeftHeight</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            height++;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRightHeight</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            height++;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountCompleteTreeNodes222 solution = <span class="keyword">new</span> CountCompleteTreeNodes222();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test cases</span></span><br><span class="line">        <span class="comment">// Example 1</span></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root1.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root1.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root1.left.left = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root1.left.right = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root1.right.left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(solution.countNodes(root1)); <span class="comment">// Output: 6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 2</span></span><br><span class="line">        TreeNode root2 = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(solution.countNodes(root2)); <span class="comment">// Output: 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 3</span></span><br><span class="line">        TreeNode root3 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        System.out.println(solution.countNodes(root3)); <span class="comment">// Output: 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="236-二叉树的最近公共祖先-lt-medium-gt"><a href="#236-二叉树的最近公共祖先-lt-medium-gt" class="headerlink" title="236. 二叉树的最近公共祖先 &lt;medium&gt;"></a>236. 二叉树的最近公共祖先 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span></span><br><span class="line"><span class="comment">        输出：5</span></span><br><span class="line"><span class="comment">        解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,2], p = 1, q = 2</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点数目在范围 [2, 105] 内。</span></span><br><span class="line"><span class="comment">        -109 &lt;= Node.val &lt;= 109</span></span><br><span class="line"><span class="comment">        所有 Node.val 互不相同 。</span></span><br><span class="line"><span class="comment">        p != q</span></span><br><span class="line"><span class="comment">        p 和 q 均存在于给定的二叉树中。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowestCommonAncestorOfABinaryTree236</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DFS递归解法 O(n) O(h)</span></span><br><span class="line">        <span class="comment">// 如果当前节点为空，或者等于其中一个目标节点，直接返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在左右子树中寻找目标节点</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左右子树分别包含目标节点，返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果只有左子树或右子树包含目标节点，则返回找到的节点</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LowestCommonAncestorOfABinaryTree236 solution = <span class="keyword">new</span> LowestCommonAncestorOfABinaryTree236();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建测试用例</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.left = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root.right = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root.left.left = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        root.left.right = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root.right.left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        root.right.right = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">        root.left.right.left = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        root.left.right.right = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode p = root.left;</span><br><span class="line">        TreeNode q = root.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到最近公共祖先</span></span><br><span class="line">        TreeNode ancestor = solution.lowestCommonAncestor(root, p, q);</span><br><span class="line">        System.out.println(<span class="string">&quot;Lowest Common Ancestor: &quot;</span> + ancestor.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-10-二叉树层次遍历-Binary-Tree-Level-Order-Traversal"><a href="#3-10-二叉树层次遍历-Binary-Tree-Level-Order-Traversal" class="headerlink" title="3.10 二叉树层次遍历 Binary Tree Level Order Traversal"></a>3.10 二叉树层次遍历 Binary Tree Level Order Traversal</h3><h4 id="199-二叉树的右视图-lt-medium-gt"><a href="#199-二叉树的右视图-lt-medium-gt" class="headerlink" title="199. 二叉树的右视图 &lt;medium&gt;"></a>199. 二叉树的右视图 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: [1,2,3,null,5,null,4]</span></span><br><span class="line"><span class="comment">        输出: [1,3,4]</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: [1,null,3]</span></span><br><span class="line"><span class="comment">        输出: [1,3]</span></span><br><span class="line"><span class="comment">        示例 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: []</span></span><br><span class="line"><span class="comment">        输出: []</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        二叉树的节点个数的范围是 [0,100]</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeRightSideView199</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过链表进行层级遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 添加最右侧节点的值</span></span><br><span class="line">                    result.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将下层子节点加入链表</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTreeRightSideView199 solution = <span class="keyword">new</span> BinaryTreeRightSideView199();</span><br><span class="line"></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root1.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>, <span class="keyword">null</span>, <span class="keyword">new</span> TreeNode(<span class="number">5</span>));</span><br><span class="line">        root1.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>, <span class="keyword">null</span>, <span class="keyword">new</span> TreeNode(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">// 获取右视图节点值列表</span></span><br><span class="line">        List&lt;Integer&gt; rightView = solution.rightSideView(root1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Right Side View: &quot;</span> + rightView); <span class="comment">// [1,3,4]</span></span><br><span class="line">        </span><br><span class="line">        TreeNode root2 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root2.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Right Side View: &quot;</span> + solution.rightSideView(root2)); <span class="comment">// [1,3]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="637-二叉树的层平均值-lt-easy-gt"><a href="#637-二叉树的层平均值-lt-easy-gt" class="headerlink" title="637. 二叉树的层平均值  &lt;easy&gt;"></a>637. 二叉树的层平均值  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">        输出：[3.00000,14.50000,11.00000]</span></span><br><span class="line"><span class="comment">        解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。</span></span><br><span class="line"><span class="comment">        因此返回 [3, 14.5, 11] 。</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [3,9,20,15,7]</span></span><br><span class="line"><span class="comment">        输出：[3.00000,14.50000,11.00000]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点数量在 [1, 104] 范围内</span></span><br><span class="line"><span class="comment">        -231 &lt;= Node.val &lt;= 231 - 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AverageOfLevelsInBinaryTree637</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">double</span> average = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                sum += node.val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">                    average = sum / size;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(average);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AverageOfLevelsInBinaryTree637 solution = <span class="keyword">new</span> AverageOfLevelsInBinaryTree637();</span><br><span class="line"></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root1.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        root1.right = <span class="keyword">new</span> TreeNode(<span class="number">20</span>, <span class="keyword">new</span> TreeNode(<span class="number">15</span>), <span class="keyword">new</span> TreeNode(<span class="number">7</span>));</span><br><span class="line">        List&lt;Double&gt; rightView = solution.averageOfLevels(root1);</span><br><span class="line">        System.out.println(<span class="string">&quot;averageOfLevels: &quot;</span> + rightView); <span class="comment">// [3.00000,14.50000,11.00000]</span></span><br><span class="line"></span><br><span class="line">        TreeNode root2 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root2.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>, <span class="keyword">new</span> TreeNode(<span class="number">15</span>), <span class="keyword">new</span> TreeNode(<span class="number">7</span>));</span><br><span class="line">        root2.right = <span class="keyword">new</span> TreeNode(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;averageOfLevels: &quot;</span> + solution.averageOfLevels(root2)); <span class="comment">// [3.00000,14.50000,11.00000]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="102-二叉树的层序遍历-lt-medium-gt"><a href="#102-二叉树的层序遍历-lt-medium-gt" class="headerlink" title="102. 二叉树的层序遍历 &lt;medium&gt;"></a>102. 二叉树的层序遍历 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">        输出：[[3],[9,20],[15,7]]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1]</span></span><br><span class="line"><span class="comment">        输出：[[1]]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = []</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点数目在范围 [0, 2000] 内</span></span><br><span class="line"><span class="comment">        -1000 &lt;= Node.val &lt;= 1000*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversal102</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTreeLevelOrderTraversal102 solution = <span class="keyword">new</span> BinaryTreeLevelOrderTraversal102();</span><br><span class="line"></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root1.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        root1.right = <span class="keyword">new</span> TreeNode(<span class="number">20</span>, <span class="keyword">new</span> TreeNode(<span class="number">15</span>), <span class="keyword">new</span> TreeNode(<span class="number">7</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;levelOrder: &quot;</span> + solution.levelOrder(root1)); <span class="comment">// [[3],[9,20],[15,7]]</span></span><br><span class="line"></span><br><span class="line">        TreeNode root2 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;levelOrder: &quot;</span> + solution.levelOrder(root2)); <span class="comment">// [[1]]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;levelOrder: &quot;</span> + solution.levelOrder(<span class="keyword">null</span>)); <span class="comment">// []</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="103-二叉树的锯齿形层序遍历-lt-medium-gt"><a href="#103-二叉树的锯齿形层序遍历-lt-medium-gt" class="headerlink" title="103. 二叉树的锯齿形层序遍历 &lt;medium&gt;"></a>103. 二叉树的锯齿形层序遍历 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">        输出：[[3],[20,9],[15,7]]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1]</span></span><br><span class="line"><span class="comment">        输出：[[1]]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = []</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点数目在范围 [0, 2000] 内</span></span><br><span class="line"><span class="comment">        -100 &lt;= Node.val &lt;= 100*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeZigzagLevelOrderTraversal103</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> direction = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (direction &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 正向</span></span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 逆向</span></span><br><span class="line">                    list.add(<span class="number">0</span>, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">            direction = -direction;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTreeZigzagLevelOrderTraversal103 solution = <span class="keyword">new</span> BinaryTreeZigzagLevelOrderTraversal103();</span><br><span class="line"></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root1.left = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">        root1.right = <span class="keyword">new</span> TreeNode(<span class="number">20</span>, <span class="keyword">new</span> TreeNode(<span class="number">15</span>), <span class="keyword">new</span> TreeNode(<span class="number">7</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;zigzagLevelOrder: &quot;</span> + solution.zigzagLevelOrder(root1)); <span class="comment">// [[3],[20,9],[15,7]]</span></span><br><span class="line"></span><br><span class="line">        TreeNode root2 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;zigzagLevelOrder: &quot;</span> + solution.zigzagLevelOrder(root2)); <span class="comment">// [[1]]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;zigzagLevelOrder: &quot;</span> + solution.zigzagLevelOrder(<span class="keyword">null</span>)); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">        TreeNode root4 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root4.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>, <span class="keyword">new</span> TreeNode(<span class="number">4</span>), <span class="keyword">null</span>);</span><br><span class="line">        root4.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>, <span class="keyword">null</span>, <span class="keyword">new</span> TreeNode(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;zigzagLevelOrder: &quot;</span> + solution.zigzagLevelOrder(root4)); <span class="comment">// [[1],[3,2],[4,5]]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-11-二叉搜索树-Binary-Search-Tree"><a href="#3-11-二叉搜索树-Binary-Search-Tree" class="headerlink" title="3.11 二叉搜索树 Binary Search Tree"></a>3.11 二叉搜索树 Binary Search Tree</h3><p>二叉搜索树节点按中序遍历升序排列，即左子树永远小于根节点，右子树永远大于根节点。</p>
<h4 id="530-二叉搜索树的最小绝对差-lt-easy-gt"><a href="#530-二叉搜索树的最小绝对差-lt-easy-gt" class="headerlink" title="530. 二叉搜索树的最小绝对差  &lt;easy&gt;"></a>530. 二叉搜索树的最小绝对差  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        差值是一个正数，其数值等于两值之差的绝对值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [4,2,6,1,3]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [1,0,48,null,null,12,49]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点的数目范围是 [2, 104]</span></span><br><span class="line"><span class="comment">        0 &lt;= Node.val &lt;= 105*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumAbsoluteDifferenceInBst530</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历二叉搜索树来解决</span></span><br><span class="line">    <span class="comment">// 遍历的节点值是按升序排列的，相邻节点值之间的最小差值必然在相邻节点值之间产生。</span></span><br><span class="line">    <span class="keyword">int</span> minDiff = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用一个变量 prev 来记录中序遍历中的前一个节点值</span></span><br><span class="line">    Integer prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrderTraversal(root);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中序遍历先搜索左子树</span></span><br><span class="line">        inOrderTraversal(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算当前节点值和 prev 的差值，并更新最小差值。</span></span><br><span class="line">            minDiff = Math.min(minDiff, root.val - prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 prev 为当前节点值</span></span><br><span class="line">        prev = root.val;</span><br><span class="line"></span><br><span class="line">        inOrderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinimumAbsoluteDifferenceInBst530 solution = <span class="keyword">new</span> MinimumAbsoluteDifferenceInBst530();</span><br><span class="line"></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root1.left = <span class="keyword">new</span> TreeNode(<span class="number">2</span>, <span class="keyword">new</span> TreeNode(<span class="number">1</span>), <span class="keyword">new</span> TreeNode(<span class="number">3</span>));</span><br><span class="line">        root1.right = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;getMinimumDifference: &quot;</span> + solution.getMinimumDifference(root1)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        solution.minDiff = Integer.MAX_VALUE;</span><br><span class="line">        solution. prev = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root2 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root2.left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        root2.right = <span class="keyword">new</span> TreeNode(<span class="number">48</span>, <span class="keyword">new</span> TreeNode(<span class="number">12</span>), <span class="keyword">new</span> TreeNode(<span class="number">49</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;getMinimumDifference: &quot;</span> + solution.getMinimumDifference(root2)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="230-二叉搜索树中第K小的元素-lt-medium-gt"><a href="#230-二叉搜索树中第K小的元素-lt-medium-gt" class="headerlink" title="230. 二叉搜索树中第K小的元素 &lt;medium&gt;"></a>230. 二叉搜索树中第K小的元素 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [3,1,4,null,2], k = 1</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [5,3,6,2,4,null,null,1], k = 3</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中的节点数为 n 。</span></span><br><span class="line"><span class="comment">        1 &lt;= k &lt;= n &lt;= 104</span></span><br><span class="line"><span class="comment">        0 &lt;= Node.val &lt;= 104</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthSmallestElementInABst230</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中序遍历二叉搜索树</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> startFlag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 循环遍历至最左子节点</span></span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">                startFlag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (startFlag) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                startFlag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> curr.val;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        KthSmallestElementInABst230 solution = <span class="keyword">new</span> KthSmallestElementInABst230();</span><br><span class="line"></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root1.left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">new</span> TreeNode(<span class="number">2</span>));</span><br><span class="line">        root1.right = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;kthSmallest: &quot;</span> + solution.kthSmallest(root1, <span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        TreeNode root2 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root2.left = <span class="keyword">new</span> TreeNode(<span class="number">3</span>, <span class="keyword">new</span> TreeNode(<span class="number">2</span>, <span class="keyword">new</span> TreeNode(<span class="number">1</span>), <span class="keyword">null</span>), <span class="keyword">new</span> TreeNode(<span class="number">4</span>));</span><br><span class="line">        root2.right = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;kthSmallest: &quot;</span> + solution.kthSmallest(root2, <span class="number">3</span>)); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="98-验证二叉搜索树-lt-medium-gt"><a href="#98-验证二叉搜索树-lt-medium-gt" class="headerlink" title="98. 验证二叉搜索树 &lt;medium&gt;"></a>98. 验证二叉搜索树 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        有效 二叉搜索树定义如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        节点的左子树只包含 小于 当前节点的数。</span></span><br><span class="line"><span class="comment">        节点的右子树只包含 大于 当前节点的数。</span></span><br><span class="line"><span class="comment">        所有左子树和右子树自身必须也是二叉搜索树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [2,1,3]</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：root = [5,1,4,null,null,3,6]</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        解释：根节点的值是 5 ，但是右子节点的值是 4 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        树中节点数目范围在[1, 104] 内</span></span><br><span class="line"><span class="comment">        -231 &lt;= Node.val &lt;= 231 - 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateBinarySearchTree98</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前节点、左边界和右边界，递归实现</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, Integer min, Integer max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前节点值是否在指定边界内</span></span><br><span class="line">        <span class="keyword">if</span> ((min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min) || (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归地检查左右子节点，并更新边界</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ValidateBinarySearchTree98 solution = <span class="keyword">new</span> ValidateBinarySearchTree98();</span><br><span class="line"></span><br><span class="line">        TreeNode root1 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        root1.left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root1.right = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;isValidBST: &quot;</span> + solution.isValidBST(root1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        TreeNode root2 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root2.left = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        root2.right = <span class="keyword">new</span> TreeNode(<span class="number">4</span>, <span class="keyword">new</span> TreeNode(<span class="number">3</span>), <span class="keyword">new</span> TreeNode(<span class="number">6</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;isValidBST: &quot;</span> + solution.isValidBST(root2)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-12-图-Graph"><a href="#3-12-图-Graph" class="headerlink" title="3.12 图 Graph"></a>3.12 图 Graph</h3><h4 id="200-岛屿数量-lt-medium-gt"><a href="#200-岛屿数量-lt-medium-gt" class="headerlink" title="200. 岛屿数量 &lt;medium&gt;"></a>200. 岛屿数量 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个由 &#x27;1&#x27;（陆地）和 &#x27;0&#x27;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        此外，你可以假设该网格的四条边均被水包围。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：grid = [</span></span><br><span class="line"><span class="comment">        [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">        [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">        [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">        [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：grid = [</span></span><br><span class="line"><span class="comment">        [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">        [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">        [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">        [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == grid.length</span></span><br><span class="line"><span class="comment">        n == grid[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 300</span></span><br><span class="line"><span class="comment">        grid[i][j] 的值为 &#x27;0&#x27; 或 &#x27;1&#x27;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfIslands200</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过深度优先搜索（DFS）或广度优先搜索（BFS）来解决</span></span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历整个二维网格，在遇到岛屿的起始点时进行 DFS 或 BFS，并将所有连接的岛屿标记为已访问，计数岛屿的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当遇到未访问过的岛屿起始点（即值为 &#x27;1&#x27; 的位置）时，进行 DFS 或 BFS，将所有连接的岛屿标记为已访问，岛屿数量加一</span></span><br><span class="line">                    count++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在 DFS 或 BFS 中，将当前位置标记为已访问，并探索相邻的位置，如果相邻位置为未访问的岛屿，则递归或加入队列进行下一步探索</span></span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= rows || col &gt;= cols || grid[row][col] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记为已访问</span></span><br><span class="line">        grid[row][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 探索相邻的位置</span></span><br><span class="line">        dfs(grid, row - <span class="number">1</span>, col);</span><br><span class="line">        dfs(grid, row + <span class="number">1</span>, col);</span><br><span class="line">        dfs(grid, row, col - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, row, col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NumberOfIslands200 solution = <span class="keyword">new</span> NumberOfIslands200();</span><br><span class="line">        <span class="comment">// 计算岛屿数量</span></span><br><span class="line">        <span class="keyword">char</span>[][] grid = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> islandsCount = solution.numIslands(grid);</span><br><span class="line">        System.out.println(<span class="string">&quot;Number of Islands: &quot;</span> + islandsCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="130-被围绕的区域-lt-medium-gt"><a href="#130-被围绕的区域-lt-medium-gt" class="headerlink" title="130. 被围绕的区域 &lt;medium&gt;"></a>130. 被围绕的区域 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个 m x n 的矩阵 board ，由若干字符 &#x27;X&#x27; 和 &#x27;O&#x27; ，找到所有被 &#x27;X&#x27; 围绕的区域，并将这些区域里所有的 &#x27;O&#x27; 用 &#x27;X&#x27; 填充。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></span><br><span class="line"><span class="comment">        输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></span><br><span class="line"><span class="comment">        解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#x27;O&#x27; 都不会被填充为 &#x27;X&#x27;。 任何不在边界上，或不与边界上的 &#x27;O&#x27; 相连的 &#x27;O&#x27; 最终都会被填充为 &#x27;X&#x27;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[&quot;X&quot;]]</span></span><br><span class="line"><span class="comment">        输出：[[&quot;X&quot;]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == board.length</span></span><br><span class="line"><span class="comment">        n == board[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 200</span></span><br><span class="line"><span class="comment">        board[i][j] 为 &#x27;X&#x27; 或 &#x27;O&#x27;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurroundedRegions130</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>] == <span class="keyword">null</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先纵向遍历两条边，</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">// 遇到O时深度遍历周围的O，并将其替换为A，标识其为边界</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                dfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                dfs(board, <span class="number">0</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                dfs(board, m - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终遍历矩阵，将O替换为X，将A替换回O</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遇到非O顶点时返回</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换为A</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历四个方向</span></span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SurroundedRegions130 solution = <span class="keyword">new</span> SurroundedRegions130();</span><br><span class="line">        <span class="keyword">char</span>[][] board1 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;X&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;X&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        solution.solve(board1);</span><br><span class="line">        printBoard(board1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[][] board2 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;X&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        solution.solve(board2);</span><br><span class="line">        printBoard(board2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBoard</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] row : board) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> cell : row) &#123;</span><br><span class="line">                System.out.print(cell + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="133-克隆图-lt-medium-gt"><a href="#133-克隆图-lt-medium-gt" class="headerlink" title="133. 克隆图 &lt;medium&gt;"></a>133. 克隆图 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; neighbors;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">测试用例格式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span></span><br><span class="line"><span class="comment">        输出：[[2,4],[1,3],[2,4],[1,3]]</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        图中有 4 个节点。</span></span><br><span class="line"><span class="comment">        节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span></span><br><span class="line"><span class="comment">        节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span></span><br><span class="line"><span class="comment">        节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span></span><br><span class="line"><span class="comment">        节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：adjList = [[]]</span></span><br><span class="line"><span class="comment">        输出：[[]]</span></span><br><span class="line"><span class="comment">        解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：adjList = []</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment">        解释：这个图是空的，它不含任何节点。</span></span><br><span class="line"><span class="comment">        示例 4：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：adjList = [[2],[1]]</span></span><br><span class="line"><span class="comment">        输出：[[2],[1]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        节点数不超过 100 。</span></span><br><span class="line"><span class="comment">        每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。</span></span><br><span class="line"><span class="comment">        无向图是一个简单图，这意味着图中没有重复的边，也没有自环。</span></span><br><span class="line"><span class="comment">        由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。</span></span><br><span class="line"><span class="comment">        图是连通图，你可以从给定节点访问到所有节点。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneGraph133</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录节点是否已遍历</span></span><br><span class="line">        Map&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> cloneNode(node, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">cloneNode</span><span class="params">(Node node, Map&lt;Node, Node&gt; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.containsKey(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span> visited.get(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制当前节点，并记录</span></span><br><span class="line">        Node clone = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        visited.put(node, clone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历邻接表，并复制到当前节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : node.neighbors) &#123;</span><br><span class="line">            <span class="comment">// 遍历的同时，也深度复制对应节点</span></span><br><span class="line">            clone.neighbors.add(cloneNode(neighbor, visited));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CloneGraph133 solution = <span class="keyword">new</span> CloneGraph133();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 1</span></span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        node1.neighbors.addAll(Arrays.asList(node2, node4));</span><br><span class="line">        node2.neighbors.addAll(Arrays.asList(node1, node3));</span><br><span class="line">        node3.neighbors.addAll(Arrays.asList(node2, node4));</span><br><span class="line">        node4.neighbors.addAll(Arrays.asList(node1, node3));</span><br><span class="line"></span><br><span class="line">        Node clonedGraph1 = solution.cloneGraph(node1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test case 1:&quot;</span>);</span><br><span class="line">        printGraph(clonedGraph1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 2</span></span><br><span class="line">        Node node2_1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node2_2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        node2_1.neighbors.add(node2_2);</span><br><span class="line">        node2_2.neighbors.add(node2_1);</span><br><span class="line"></span><br><span class="line">        Node clonedGraph2 = solution.cloneGraph(node2_1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Test case 2:&quot;</span>);</span><br><span class="line">        printGraph(clonedGraph2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Map&lt;Node, Boolean&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(node);</span><br><span class="line">        visited.put(node, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node current = queue.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;Node: &quot;</span> + current.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node neighbor : current.neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.containsKey(neighbor)) &#123;</span><br><span class="line">                    visited.put(neighbor, <span class="keyword">true</span>);</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">            neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">            val = _val;</span><br><span class="line">            neighbors = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, ArrayList&lt;Node&gt; _neighbors)</span> </span>&#123;</span><br><span class="line">            val = _val;</span><br><span class="line">            neighbors = _neighbors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="399-除法求值-lt-medium-gt-lt-hard-gt"><a href="#399-除法求值-lt-medium-gt-lt-hard-gt" class="headerlink" title="399. 除法求值 &lt;medium&gt; ~  &lt;hard&gt;"></a>399. 除法求值 &lt;medium&gt; ~  &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span></span><br><span class="line"><span class="comment">        输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        条件：a / b = 2.0, b / c = 3.0</span></span><br><span class="line"><span class="comment">        问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</span></span><br><span class="line"><span class="comment">        结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</span></span><br><span class="line"><span class="comment">        注意：x 是未定义的 =&gt; -1.0</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]</span></span><br><span class="line"><span class="comment">        输出：[3.75000,0.40000,5.00000,0.20000]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]</span></span><br><span class="line"><span class="comment">        输出：[0.50000,2.00000,-1.00000,-1.00000]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= equations.length &lt;= 20</span></span><br><span class="line"><span class="comment">        equations[i].length == 2</span></span><br><span class="line"><span class="comment">        1 &lt;= Ai.length, Bi.length &lt;= 5</span></span><br><span class="line"><span class="comment">        values.length == equations.length</span></span><br><span class="line"><span class="comment">        0.0 &lt; values[i] &lt;= 20.0</span></span><br><span class="line"><span class="comment">        1 &lt;= queries.length &lt;= 20</span></span><br><span class="line"><span class="comment">        queries[i].length == 2</span></span><br><span class="line"><span class="comment">        1 &lt;= Cj.length, Dj.length &lt;= 5</span></span><br><span class="line"><span class="comment">        Ai, Bi, Cj, Dj 由小写英文字母与数字组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvaluateDivision399</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="comment">// 使用带权重的Union-Find数据结构，称为并查集（Disjoint Set）。</span></span><br><span class="line">        <span class="comment">// 时间复杂度为O(Q + E * α(V))，其中Q是查询的数量，E是图中的边的数量，α(V)是Ackermann函数的反函数，通常视为一个很小的常数。</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Node&gt; nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个节点表示为一个带权重的集合，遍历变量对，构建节点链表，以及映射关系，其中key为变量名</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前变量对</span></span><br><span class="line">            List&lt;String&gt; equation = equations.get(i);</span><br><span class="line">            String sourceStr = equation.get(<span class="number">0</span>);</span><br><span class="line">            String destinationStr = equation.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">double</span> value = values[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找并构建节点</span></span><br><span class="line">            Node source = getOrCreateNode(nodes, sourceStr);</span><br><span class="line">            Node destination = getOrCreateNode(nodes, destinationStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用union操作将两个集合合并，并更新权重。</span></span><br><span class="line">            union(source, destination, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] results = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历问题集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">            List&lt;String&gt; query = queries.get(i);</span><br><span class="line">            String sourceStr = query.get(<span class="number">0</span>);</span><br><span class="line">            String destinationStr = query.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分别获取问题的两个节点，通过节点获取结果</span></span><br><span class="line">            Node source = nodes.get(sourceStr);</span><br><span class="line">            Node destination = nodes.get(destinationStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过find将集合状态更新一致，获得相同的root，否则表示元素不存在</span></span><br><span class="line">            <span class="keyword">if</span> (source == <span class="keyword">null</span> || destination == <span class="keyword">null</span> || !find(source).equals(find(destination))) &#123;</span><br><span class="line">                results[i] = -<span class="number">1.0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                results[i] = source.value / destination.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getOrCreateNode</span><span class="params">(Map&lt;String, Node&gt; nodes, String label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nodes.containsKey(label)) &#123;</span><br><span class="line">            nodes.put(label, <span class="keyword">new</span> Node(label, <span class="number">1.0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(label);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">find</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find操作找到集合的根节点，如果出现超过2层的集合就会将其恢复为2层，节点的值为除以根节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.parent != node) &#123;</span><br><span class="line">            Node root = find(node.parent);</span><br><span class="line">            <span class="comment">// 更新权重</span></span><br><span class="line">            node.value *= node.parent.value;</span><br><span class="line">            <span class="comment">// 更新根节点</span></span><br><span class="line">            node.parent = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果A和B没有相同根节点，则把B的root作为新的根节点关联起来</span></span><br><span class="line">        Node rootA = find(a);</span><br><span class="line">        Node rootB = find(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootA != rootB) &#123;</span><br><span class="line">            rootA.parent = rootB;</span><br><span class="line">            rootA.value = value * b.value / a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        String label;</span><br><span class="line">        Node parent;</span><br><span class="line">        <span class="keyword">double</span> value;</span><br><span class="line"></span><br><span class="line">        Node(String label, <span class="keyword">double</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.label = label;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span></span><br><span class="line">    <span class="comment">//    // 将变量对和结果映射关系存入map，包括A/B和B/A</span></span><br><span class="line">    <span class="comment">//    Map&lt;String, Map&lt;String, Double&gt;&gt; graph = buildGraph(equations, values);</span></span><br><span class="line">    <span class="comment">//    double[] results = new double[queries.size()];</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    // DFS遍历所有问题，获得所有结果</span></span><br><span class="line">    <span class="comment">//    for (int i = 0; i &lt; queries.size(); i++) &#123;</span></span><br><span class="line">    <span class="comment">//        results[i] = dfs(graph, queries.get(i).get(0), queries.get(i).get(1), new HashSet&lt;&gt;());</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    return results;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//private Map&lt;String, Map&lt;String, Double&gt;&gt; buildGraph(List&lt;List&lt;String&gt;&gt; equations, double[] values) &#123;</span></span><br><span class="line">    <span class="comment">//    Map&lt;String, Map&lt;String, Double&gt;&gt; graph = new HashMap&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    // 遍历变量对，将变量和结果存入map，</span></span><br><span class="line">    <span class="comment">//    for (int i = 0; i &lt; equations.size(); i++) &#123;</span></span><br><span class="line">    <span class="comment">//        String source = equations.get(i).get(0);</span></span><br><span class="line">    <span class="comment">//        String destination = equations.get(i).get(1);</span></span><br><span class="line">    <span class="comment">//        double value = values[i];</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        // &lt;A, &lt;B, V&gt;&gt;</span></span><br><span class="line">    <span class="comment">//        graph.computeIfAbsent(source, k -&gt; new HashMap&lt;&gt;()).put(destination, value);</span></span><br><span class="line">    <span class="comment">//        // &lt;B, &lt;A, 1/V&gt;&gt;</span></span><br><span class="line">    <span class="comment">//        graph.computeIfAbsent(destination, k -&gt; new HashMap&lt;&gt;()).put(source, 1.0 / value);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    return graph;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//private double dfs(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, String start, String end, Set&lt;String&gt; visited) &#123;</span></span><br><span class="line">    <span class="comment">//    if (!graph.containsKey(start) || !graph.containsKey(end)) &#123;</span></span><br><span class="line">    <span class="comment">//        return -1.0;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    if (start.equals(end)) &#123;</span></span><br><span class="line">    <span class="comment">//        return 1.0;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    visited.add(start);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    // 获取start对应的除法映射，求A/B或A/C，找到A/B=V，前者返回V，后者再找到B/C=X，得到A/C = (A/B) * (B/C) = V*X</span></span><br><span class="line">    <span class="comment">//    for (Map.Entry&lt;String, Double&gt; neighbor : graph.get(start).entrySet()) &#123;</span></span><br><span class="line">    <span class="comment">//        String nextNode = neighbor.getKey();</span></span><br><span class="line">    <span class="comment">//        double edgeWeight = neighbor.getValue();</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        if (!visited.contains(nextNode)) &#123;</span></span><br><span class="line">    <span class="comment">//            double result = dfs(graph, nextNode, end, visited);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//            if (result != -1.0) &#123;</span></span><br><span class="line">    <span class="comment">//                return result * edgeWeight;</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    visited.remove(start);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    return -1.0;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EvaluateDivision399 solution = <span class="keyword">new</span> EvaluateDivision399();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 1</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; equations1 = Arrays.asList(</span><br><span class="line">                Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">double</span>[] values1 = &#123;<span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; queries1 = Arrays.asList(</span><br><span class="line">                Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;x&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">double</span>[] results1 = solution.calcEquation(equations1, values1, queries1);</span><br><span class="line">        System.out.println(Arrays.toString(results1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 2</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; equations2 = Arrays.asList(</span><br><span class="line">                Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">double</span>[] values2 = &#123;<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; queries2 = Arrays.asList(</span><br><span class="line">                Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;b&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;cd&quot;</span>, <span class="string">&quot;bc&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">double</span>[] results2 = solution.calcEquation(equations2, values2, queries2);</span><br><span class="line">        System.out.println(Arrays.toString(results2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 3</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; equations3 = Arrays.asList(</span><br><span class="line">                Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">double</span>[] values3 = &#123;<span class="number">0.5</span>&#125;;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; queries3 = Arrays.asList(</span><br><span class="line">                Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>),</span><br><span class="line">                Arrays.asList(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">double</span>[] results3 = solution.calcEquation(equations3, values3, queries3);</span><br><span class="line">        System.out.println(Arrays.toString(results3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="207-课程表-lt-medium-gt"><a href="#207-课程表-lt-medium-gt" class="headerlink" title="207. 课程表 &lt;medium&gt;"></a>207. 课程表 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。</span></span><br><span class="line"><span class="comment">        请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：numCourses = 2, prerequisites = [[1,0]]</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= numCourses &lt;= 2000</span></span><br><span class="line"><span class="comment">        0 &lt;= prerequisites.length &lt;= 5000</span></span><br><span class="line"><span class="comment">        prerequisites[i].length == 2</span></span><br><span class="line"><span class="comment">        0 &lt;= ai, bi &lt; numCourses</span></span><br><span class="line"><span class="comment">prerequisites[i] 中的所有课程对 互不相同*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseSchedule207</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用深度优先搜索来检测图中是否有环</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacencyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            adjacencyList.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            <span class="keyword">int</span> course = prerequisite[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prerequisiteCourse = prerequisite[<span class="number">1</span>];</span><br><span class="line">            adjacencyList.get(prerequisiteCourse).add(course);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于每个节点，DFS遍历其邻接节点。如果在DFS遍历的过程中发现了正在访问的节点，说明存在环，返回false。如果DFS遍历完成，将该节点标记为已访问，返回true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; !dfs(adjacencyList, visited, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adjacencyList, <span class="keyword">int</span>[] visited, <span class="keyword">int</span> course)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[course] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 发现环，返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited[course] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 已访问过，返回 true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[course] = <span class="number">1</span>; <span class="comment">// 标记为正在访问</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nextCourse : adjacencyList.get(course)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(adjacencyList, visited, nextCourse)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[course] = <span class="number">2</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span></span><br><span class="line"><span class="comment">        // 拓扑排序</span></span><br><span class="line"><span class="comment">        // 创建了一个邻接表来表示图</span></span><br><span class="line"><span class="comment">        List&lt;List&lt;Integer&gt;&gt; adjacencyList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        // 并计算每个节点（课程）的入度</span></span><br><span class="line"><span class="comment">        int[] inDegrees = new int[numCourses];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 为每个课程创建一个数组</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; numCourses; i++) &#123;</span></span><br><span class="line"><span class="comment">            adjacencyList.add(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 遍历课程关系，将每个需要课程的作为前置的课程放入数组</span></span><br><span class="line"><span class="comment">        for (int[] prerequisite : prerequisites) &#123;</span></span><br><span class="line"><span class="comment">            int course = prerequisite[0];</span></span><br><span class="line"><span class="comment">            int prerequisiteCourse = prerequisite[1];</span></span><br><span class="line"><span class="comment">            adjacencyList.get(prerequisiteCourse).add(course);</span></span><br><span class="line"><span class="comment">            inDegrees[course]++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 将入度为0的课程先加入链表</span></span><br><span class="line"><span class="comment">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; numCourses; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (inDegrees[i] == 0) &#123;</span></span><br><span class="line"><span class="comment">                queue.offer(i);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 若没有入度为0的课程，直接失败</span></span><br><span class="line"><span class="comment">        while (!queue.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            // 获取可以直接学的课程</span></span><br><span class="line"><span class="comment">            int currentCourse = queue.poll();</span></span><br><span class="line"><span class="comment">            // 课程数-1表示需要判断能否学习的课程少1</span></span><br><span class="line"><span class="comment">            numCourses--;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            // 遍历需要该课程作为前置课程的后续课程，并将其入度-1，如果减为0，表示该课程也可以直接学习，将其加入链表</span></span><br><span class="line"><span class="comment">            for (int nextCourse : adjacencyList.get(currentCourse)) &#123;</span></span><br><span class="line"><span class="comment">                if (--inDegrees[nextCourse] == 0) &#123;</span></span><br><span class="line"><span class="comment">                    queue.offer(nextCourse);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 如果所有课程都可以被访问（入度减为0），则可以完成所有课程，函数返回true；否则返回false。</span></span><br><span class="line"><span class="comment">        // 时间复杂度：O(V + E)，其中V是课程的数量（节点数），E是先修关系的数量（边数）。</span></span><br><span class="line"><span class="comment">        // 空间复杂度：O(V + E)，同样考虑到邻接表和visited数组。</span></span><br><span class="line"><span class="comment">        return numCourses == 0;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CourseSchedule207 solution = <span class="keyword">new</span> CourseSchedule207();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test cases</span></span><br><span class="line">        <span class="keyword">int</span> numCourses1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] prerequisites1 = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        System.out.println(solution.canFinish(numCourses1, prerequisites1)); <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numCourses2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] prerequisites2 = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        System.out.println(solution.canFinish(numCourses2, prerequisites2)); <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="210-课程表-II-lt-medium-gt"><a href="#210-课程表-II-lt-medium-gt" class="headerlink" title="210. 课程表 II &lt;medium&gt;"></a>210. 课程表 II &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。</span></span><br><span class="line"><span class="comment">        返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：numCourses = 2, prerequisites = [[1,0]]</span></span><br><span class="line"><span class="comment">        输出：[0,1]</span></span><br><span class="line"><span class="comment">        解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span></span><br><span class="line"><span class="comment">        输出：[0,2,1,3]</span></span><br><span class="line"><span class="comment">        解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span></span><br><span class="line"><span class="comment">        因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：numCourses = 1, prerequisites = []</span></span><br><span class="line"><span class="comment">        输出：[0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment">        1 &lt;= numCourses &lt;= 2000</span></span><br><span class="line"><span class="comment">        0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</span></span><br><span class="line"><span class="comment">        prerequisites[i].length == 2</span></span><br><span class="line"><span class="comment">        0 &lt;= ai, bi &lt; numCourses</span></span><br><span class="line"><span class="comment">ai != bi</span></span><br><span class="line"><span class="comment">        所有[ai, bi] 互不相同*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseScheduleII210</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacencyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            adjacencyList.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            <span class="keyword">int</span> course = prerequisite[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prerequisiteCourse = prerequisite[<span class="number">1</span>];</span><br><span class="line">            adjacencyList.get(prerequisiteCourse).add(course);</span><br><span class="line">            indegree[course]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentCourse = queue.poll();</span><br><span class="line">            result[index++] = currentCourse;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> nextCourse : adjacencyList.get(currentCourse)) &#123;</span><br><span class="line">                indegree[nextCourse]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[nextCourse] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(nextCourse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index == numCourses ? result : <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CourseScheduleII210 solution = <span class="keyword">new</span> CourseScheduleII210();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例</span></span><br><span class="line">        <span class="keyword">int</span> numCourses1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] prerequisites1 = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(solution.findOrder(numCourses1, prerequisites1))); <span class="comment">// 输出: [0, 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numCourses2 = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] prerequisites2 = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(solution.findOrder(numCourses2, prerequisites2))); <span class="comment">// 输出: [0, 2, 1, 3]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numCourses3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] prerequisites3 = &#123;&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(solution.findOrder(numCourses3, prerequisites3))); <span class="comment">// 输出: [0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-13-图的广度优先搜索-Breadth-First-Search-BFS-in-Graphs"><a href="#3-13-图的广度优先搜索-Breadth-First-Search-BFS-in-Graphs" class="headerlink" title="3.13 图的广度优先搜索 Breadth-First Search (BFS) in Graphs"></a>3.13 图的广度优先搜索 Breadth-First Search (BFS) in Graphs</h3><h4 id="909-蛇梯棋-lt-medium-gt"><a href="#909-蛇梯棋-lt-medium-gt" class="headerlink" title="909. 蛇梯棋 &lt;medium&gt;"></a>909. 蛇梯棋 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个大小为 n x n 的整数矩阵 board ，方格按从 1 到 n2 编号，编号遵循 转行交替方式 ，从左下角开始 （即，从 board[n - 1][0] 开始）每一行交替方向。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        每一回合，玩家需要从当前方格 curr 开始出发，按下述要求前进：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        选定目标方格 next ，目标方格的编号符合范围 [curr + 1, min(curr + 6, n2)] 。</span></span><br><span class="line"><span class="comment">        该选择模拟了掷 六面体骰子 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</span></span><br><span class="line"><span class="comment">        传送玩家：如果目标方格 next 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 next 。</span></span><br><span class="line"><span class="comment">        当玩家到达编号 n2 的方格时，游戏结束。</span></span><br><span class="line"><span class="comment">        r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。编号为 1 和 n2 的方格上没有蛇或梯子。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 不能 继续移动。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        举个例子，假设棋盘是 [[-1,4],[-1,3]] ，第一次移动，玩家的目标方格是 2 。那么这个玩家将会顺着梯子到达方格 3 ，但 不能 顺着方格 3 上的梯子前往方格 4 。</span></span><br><span class="line"><span class="comment">        返回达到编号为 n2 的方格所需的最少移动次数，如果不可能，则返回 -1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        首先，从方格 1 [第 5 行，第 0 列] 开始。</span></span><br><span class="line"><span class="comment">        先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。</span></span><br><span class="line"><span class="comment">        然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。</span></span><br><span class="line"><span class="comment">        接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。</span></span><br><span class="line"><span class="comment">        最后决定移动到方格 36 , 游戏结束。</span></span><br><span class="line"><span class="comment">        可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[-1,-1],[-1,3]]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        n == board.length == board[i].length</span></span><br><span class="line"><span class="comment">        2 &lt;= n &lt;= 20</span></span><br><span class="line"><span class="comment">        grid[i][j] 的值是 -1 或在范围 [1, n2] 内</span></span><br><span class="line"><span class="comment">        编号为 1 和 n2 的方格上没有蛇或梯子*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnakesAndLadders909</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将棋盘上的每个方格看作图中的节点，根据规则构建图，然后使用BFS计算从起点到终点的最短路径。</span></span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line">        <span class="keyword">int</span> target = n * n;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        visited[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 计算多少次移动</span></span><br><span class="line">        <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在BFS的过程中，通过模拟骰子的掷动，计算每个节点的相邻节点。如果相邻节点对应的方格上有蛇或梯子，需要将玩家传送到蛇或梯子的目的地。</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (current == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> moves;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历一轮骰子能到达的距离</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> next = current + <span class="number">1</span>; next &lt;= Math.min(current + <span class="number">6</span>, target); next++) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将num转为二维的行列坐标，获取</span></span><br><span class="line">                    <span class="keyword">int</span>[] coordinates = getCoordinates(next, n);</span><br><span class="line">                    <span class="keyword">int</span> row = coordinates[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> col = coordinates[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取下一个方格的编号，-1表示没有梯子或蛇，否则通过board获取传送的位置</span></span><br><span class="line">                    <span class="keyword">int</span> nextVal = board[row][col] == -<span class="number">1</span> ? next : board[row][col];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 记录未访问过的顶点</span></span><br><span class="line">                    <span class="keyword">if</span> (!visited[nextVal]) &#123;</span><br><span class="line">                        visited[nextVal] = <span class="keyword">true</span>;</span><br><span class="line">                        queue.offer(nextVal);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            moves++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getCoordinates(<span class="keyword">int</span> num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 将方格编号映射到对应的行和列坐标,将一维编号映射到二维坐标，方便后续在二维数组中进行操作。</span></span><br><span class="line">        <span class="comment">// 方格的编号 num 和棋盘的大小 n，返回一个包含两个元素的整数数组，分别表示方格的行坐标和列坐标。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别计算行号和列号</span></span><br><span class="line">        <span class="keyword">int</span> row = (num - <span class="number">1</span>) / n;</span><br><span class="line">        <span class="keyword">int</span> col = (num - <span class="number">1</span>) % n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (row % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 由于行号为奇数时，列号需要进行翻转，所以对于奇数行，将 col 置为 n - 1 - col</span></span><br><span class="line">            col = n - <span class="number">1</span> - col;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回的数组中，n - 1 - row 表示转换后的行坐标，col 表示列坐标</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;n - <span class="number">1</span> - row, col&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SnakesAndLadders909 solution = <span class="keyword">new</span> SnakesAndLadders909();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例</span></span><br><span class="line">        <span class="keyword">int</span>[][] board1 = &#123;</span><br><span class="line">                &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">                &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">                &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">                &#123;-<span class="number">1</span>, <span class="number">35</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">13</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">                &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">                &#123;-<span class="number">1</span>, <span class="number">15</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(solution.snakesAndLadders(board1)); <span class="comment">// 输出: 4</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] board2 = &#123;</span><br><span class="line">                &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">                &#123;-<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(solution.snakesAndLadders(board2)); <span class="comment">// 输出: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="433-最小基因变化-lt-medium-gt"><a href="#433-最小基因变化-lt-medium-gt" class="headerlink" title="433. 最小基因变化 &lt;medium&gt;"></a>433. 最小基因变化 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 &#x27;A&#x27;、&#x27;C&#x27;、&#x27;G&#x27; 和 &#x27;T&#x27; 之一。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        例如，&quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot; 就是一次基因变化。</span></span><br><span class="line"><span class="comment">        另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：start = &quot;AACCGGTT&quot;, end = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：start = &quot;AACCGGTT&quot;, end = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：start = &quot;AAAAACCC&quot;, end = &quot;AACCCCCC&quot;, bank = [&quot;AAAACCCC&quot;,&quot;AAACCCCC&quot;,&quot;AACCCCCC&quot;]</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        start.length == 8</span></span><br><span class="line"><span class="comment">        end.length == 8</span></span><br><span class="line"><span class="comment">        0 &lt;= bank.length &lt;= 10</span></span><br><span class="line"><span class="comment">        bank[i].length == 8</span></span><br><span class="line"><span class="comment">        start、end 和 bank[i] 仅由字符 [&#x27;A&#x27;, &#x27;C&#x27;, &#x27;G&#x27;, &#x27;T&#x27;] 组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumGeneticMutation433</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMutation</span><span class="params">(String startGene, String endGene, String[] bank)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 BFS 进行搜索，每一层代表一次基因变化</span></span><br><span class="line">        Set&lt;String&gt; bankSet = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(bank));</span><br><span class="line">        <span class="keyword">if</span> (!bankSet.contains(endGene)) &#123;</span><br><span class="line">            <span class="comment">// 要变化的基因不在基因库</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] geneChars = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">// 使用集合 visited 记录已经访问过的基因，避免重复搜索。</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(startGene);</span><br><span class="line">        visited.add(startGene);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                String currentGene = queue.poll();</span><br><span class="line">                <span class="comment">// 已变化出end基因，返回当前次数</span></span><br><span class="line">                <span class="keyword">if</span> (currentGene.equals(endGene)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> steps;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从起始基因开始，将其每个字符替换为其他可能的字符，检查是否在基因库中，如果在则将该新基因加入队列。</span></span><br><span class="line">                <span class="keyword">char</span>[] currentChars = currentGene.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; currentChars.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> originalChar = currentChars[j];</span><br><span class="line">                    <span class="comment">// 依次尝试替换当前char，然后判断是否为基因库或已重复</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> newChar : geneChars) &#123;</span><br><span class="line">                        currentChars[j] = newChar;</span><br><span class="line">                        String newGene = <span class="keyword">new</span> String(currentChars);</span><br><span class="line">                        <span class="keyword">if</span> (!visited.contains(newGene) &amp;&amp; bankSet.contains(newGene)) &#123;</span><br><span class="line">                            <span class="comment">// 基因库的新变型</span></span><br><span class="line">                            queue.offer(newGene);</span><br><span class="line">                            visited.add(newGene);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 恢复回原基因</span></span><br><span class="line">                    currentChars[j] = originalChar;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinimumGeneticMutation433 solution = <span class="keyword">new</span> MinimumGeneticMutation433();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        String start1 = <span class="string">&quot;AACCGGTT&quot;</span>;</span><br><span class="line">        String end1 = <span class="string">&quot;AACCGGTA&quot;</span>;</span><br><span class="line">        String[] bank1 = &#123;<span class="string">&quot;AACCGGTA&quot;</span>&#125;;</span><br><span class="line">        System.out.println(solution.minMutation(start1, end1, bank1)); <span class="comment">// Output: 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        String start2 = <span class="string">&quot;AACCGGTT&quot;</span>;</span><br><span class="line">        String end2 = <span class="string">&quot;AAACGGTA&quot;</span>;</span><br><span class="line">        String[] bank2 = &#123;<span class="string">&quot;AACCGGTA&quot;</span>, <span class="string">&quot;AACCGCTA&quot;</span>, <span class="string">&quot;AAACGGTA&quot;</span>&#125;;</span><br><span class="line">        System.out.println(solution.minMutation(start2, end2, bank2)); <span class="comment">// Output: 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        String start3 = <span class="string">&quot;AAAAACCC&quot;</span>;</span><br><span class="line">        String end3 = <span class="string">&quot;AACCCCCC&quot;</span>;</span><br><span class="line">        String[] bank3 = &#123;<span class="string">&quot;AAAACCCC&quot;</span>, <span class="string">&quot;AAACCCCC&quot;</span>, <span class="string">&quot;AACCCCCC&quot;</span>&#125;;</span><br><span class="line">        System.out.println(solution.minMutation(start3, end3, bank3)); <span class="comment">// Output: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="127-单词接龙-lt-hard-gt"><a href="#127-单词接龙-lt-hard-gt" class="headerlink" title="127. 单词接龙 &lt;hard&gt;"></a>127. 单词接龙 &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        每一对相邻的单词只差一个字母。</span></span><br><span class="line"><span class="comment">        对于 1 &lt;= i &lt;= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。</span></span><br><span class="line"><span class="comment">        sk == endWord</span></span><br><span class="line"><span class="comment">        给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span></span><br><span class="line"><span class="comment">        输出：5</span></span><br><span class="line"><span class="comment">        解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment">        解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= beginWord.length &lt;= 10</span></span><br><span class="line"><span class="comment">        endWord.length == beginWord.length</span></span><br><span class="line"><span class="comment">        1 &lt;= wordList.length &lt;= 5000</span></span><br><span class="line"><span class="comment">        wordList[i].length == beginWord.length</span></span><br><span class="line"><span class="comment">        beginWord、endWord 和 wordList[i] 由小写英文字母组成</span></span><br><span class="line"><span class="comment">        beginWord != endWord</span></span><br><span class="line"><span class="comment">        wordList 中的所有字符串 互不相同*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordLadder127</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 BFS 进行搜索，每一层代表一次单词变化</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (!wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从起始单词开始，将其每个字符替换为其他可能的字符，检查是否在字典中，如果在则将该新单词加入队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                String currentWord = queue.poll();</span><br><span class="line">                <span class="keyword">char</span>[] wordChars = currentWord.toCharArray();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 依次替换单词的每个字符</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wordChars.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> originalChar = wordChars[j];</span><br><span class="line">                    <span class="comment">// 依次从a替换到z</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (c == originalChar) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        wordChars[j] = c;</span><br><span class="line">                        String newWord = <span class="keyword">new</span> String(wordChars);</span><br><span class="line">                        <span class="comment">// 字典存在的单词，若为新单词就继续遍历</span></span><br><span class="line">                        <span class="keyword">if</span> (wordSet.contains(newWord)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (newWord.equals(endWord)) &#123;</span><br><span class="line">                                <span class="comment">// 找到要转换的单词</span></span><br><span class="line">                                <span class="keyword">return</span> steps + <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!visited.contains(newWord)) &#123;</span><br><span class="line">                                queue.offer(newWord);</span><br><span class="line">                                visited.add(newWord);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    wordChars[j] = originalChar;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该层所有能转换的单词都无法命中endWord，层数+1</span></span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(m * n)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WordLadder127 solution = <span class="keyword">new</span> WordLadder127();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        String beginWord1 = <span class="string">&quot;hit&quot;</span>;</span><br><span class="line">        String endWord1 = <span class="string">&quot;cog&quot;</span>;</span><br><span class="line">        List&lt;String&gt; wordList1 = Arrays.asList(<span class="string">&quot;hot&quot;</span>, <span class="string">&quot;dot&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lot&quot;</span>, <span class="string">&quot;log&quot;</span>, <span class="string">&quot;cog&quot;</span>);</span><br><span class="line">        System.out.println(solution.ladderLength(beginWord1, endWord1, wordList1)); <span class="comment">// Output: 5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        String beginWord2 = <span class="string">&quot;hit&quot;</span>;</span><br><span class="line">        String endWord2 = <span class="string">&quot;cog&quot;</span>;</span><br><span class="line">        List&lt;String&gt; wordList2 = Arrays.asList(<span class="string">&quot;hot&quot;</span>, <span class="string">&quot;dot&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lot&quot;</span>, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">        System.out.println(solution.ladderLength(beginWord2, endWord2, wordList2)); <span class="comment">// Output: 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-14-字典树-Trie-Prefix-Tree"><a href="#3-14-字典树-Trie-Prefix-Tree" class="headerlink" title="3.14 字典树 Trie (Prefix Tree)"></a>3.14 字典树 Trie (Prefix Tree)</h3><h4 id="208-实现-Trie-前缀树-lt-medium-gt"><a href="#208-实现-Trie-前缀树-lt-medium-gt" class="headerlink" title="208. 实现 Trie (前缀树) &lt;medium&gt;"></a>208. 实现 Trie (前缀树) &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Trie（发音类似 &quot;try&quot;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请你实现 Trie 类：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Trie() 初始化前缀树对象。</span></span><br><span class="line"><span class="comment">        void insert(String word) 向前缀树中插入字符串 word 。</span></span><br><span class="line"><span class="comment">        boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</span></span><br><span class="line"><span class="comment">        boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入</span></span><br><span class="line"><span class="comment">        [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span></span><br><span class="line"><span class="comment">        [[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span></span><br><span class="line"><span class="comment">        输出</span></span><br><span class="line"><span class="comment">        [null, null, true, false, true, null, true]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        解释</span></span><br><span class="line"><span class="comment">        Trie trie = new Trie();</span></span><br><span class="line"><span class="comment">        trie.insert(&quot;apple&quot;);</span></span><br><span class="line"><span class="comment">        trie.search(&quot;apple&quot;);   // 返回 True</span></span><br><span class="line"><span class="comment">        trie.search(&quot;app&quot;);     // 返回 False</span></span><br><span class="line"><span class="comment">        trie.startsWith(&quot;app&quot;); // 返回 True</span></span><br><span class="line"><span class="comment">        trie.insert(&quot;app&quot;);</span></span><br><span class="line"><span class="comment">        trie.search(&quot;app&quot;);     // 返回 True</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= word.length, prefix.length &lt;= 2000</span></span><br><span class="line"><span class="comment">        word 和 prefix 仅由小写英文字母组成</span></span><br><span class="line"><span class="comment">        insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplementTriePrefixTree208</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 使用 TrieNode 类表示 Trie 树的节点，其中包含一个数组 children 存储子节点和一个标志 isEnd 表示是否是单词的结束</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImplementTriePrefixTree208</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入单词</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="comment">// 遍历单词的每个字符，逐级建立 Trie 树的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索单词</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历单词的每个字符，查找是否存在对应的 Trie 节点，并判断最后一个节点是否是单词的结束</span></span><br><span class="line">        TrieNode node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索前缀的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历前缀的每个字符，查找是否存在对应的 Trie 节点，不需要判断是否是单词的结束</span></span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// insert、search、startsWith 操作的时间复杂度均为 O(m)，其中 m 为单词长度。</span></span><br><span class="line">        <span class="comment">// Trie 树的空间复杂度为 O(26 * m * n)，其中 m 为单词长度，n 为单词数量。</span></span><br><span class="line">        ImplementTriePrefixTree208 trie = <span class="keyword">new</span> ImplementTriePrefixTree208();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        trie.insert(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        System.out.println(trie.search(<span class="string">&quot;apple&quot;</span>));   <span class="comment">// Output: true</span></span><br><span class="line">        System.out.println(trie.search(<span class="string">&quot;app&quot;</span>));     <span class="comment">// Output: false</span></span><br><span class="line">        System.out.println(trie.startsWith(<span class="string">&quot;app&quot;</span>)); <span class="comment">// Output: true</span></span><br><span class="line">        trie.insert(<span class="string">&quot;app&quot;</span>);</span><br><span class="line">        System.out.println(trie.search(<span class="string">&quot;app&quot;</span>));     <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        trie = <span class="keyword">new</span> ImplementTriePrefixTree208();</span><br><span class="line">        System.out.println(trie.search(<span class="string">&quot;a&quot;</span>));   <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">this</span>.isEnd = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="211-添加与搜索单词-数据结构设计-lt-medium-gt"><a href="#211-添加与搜索单词-数据结构设计-lt-medium-gt" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计 &lt;medium&gt;"></a>211. 添加与搜索单词 - 数据结构设计 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        实现词典类 WordDictionary ：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        WordDictionary() 初始化词典对象</span></span><br><span class="line"><span class="comment">        void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配</span></span><br><span class="line"><span class="comment">        bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 &#x27;.&#x27; ，每个 . 都可以表示任何一个字母。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：</span></span><br><span class="line"><span class="comment">        [&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]</span></span><br><span class="line"><span class="comment">        [[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]</span></span><br><span class="line"><span class="comment">        输出：</span></span><br><span class="line"><span class="comment">        [null,null,null,null,false,true,true,true]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        WordDictionary wordDictionary = new WordDictionary();</span></span><br><span class="line"><span class="comment">        wordDictionary.addWord(&quot;bad&quot;);</span></span><br><span class="line"><span class="comment">        wordDictionary.addWord(&quot;dad&quot;);</span></span><br><span class="line"><span class="comment">        wordDictionary.addWord(&quot;mad&quot;);</span></span><br><span class="line"><span class="comment">        wordDictionary.search(&quot;pad&quot;); // 返回 False</span></span><br><span class="line"><span class="comment">        wordDictionary.search(&quot;bad&quot;); // 返回 True</span></span><br><span class="line"><span class="comment">        wordDictionary.search(&quot;.ad&quot;); // 返回 True</span></span><br><span class="line"><span class="comment">        wordDictionary.search(&quot;b..&quot;); // 返回 True</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= word.length &lt;= 25</span></span><br><span class="line"><span class="comment">        addWord 中的 word 由小写英文字母组成</span></span><br><span class="line"><span class="comment">        search 中的 word 由 &#x27;.&#x27; 或小写英文字母组成</span></span><br><span class="line"><span class="comment">        最多调用 104 次 addWord 和 search*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignAddAndSearchWordsDataStructure211</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 TrieNode 类表示 Trie 树的节点，其中包含一个数组 children 存储子节点和一个标志 isEnd 表示是否是单词的结束</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DesignAddAndSearchWordsDataStructure211</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将每个字符分别构建对应的node</span></span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchWord(root, word, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">searchWord</span><span class="params">(TrieNode node, String word, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">            <span class="comment">// 全部命中返回true</span></span><br><span class="line">            <span class="keyword">return</span> node.isEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> ch = word.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// .任意字符，找到一个非空子节点继续</span></span><br><span class="line">            <span class="keyword">for</span> (TrieNode child : node.children) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child != <span class="keyword">null</span> &amp;&amp; searchWord(child, word, index + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若命中就继续</span></span><br><span class="line">            <span class="keyword">int</span> charIndex = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[charIndex] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> searchWord(node.children[charIndex], word, index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DesignAddAndSearchWordsDataStructure211 wordDictionary = <span class="keyword">new</span> DesignAddAndSearchWordsDataStructure211();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        wordDictionary.addWord(<span class="string">&quot;bad&quot;</span>);</span><br><span class="line">        wordDictionary.addWord(<span class="string">&quot;dad&quot;</span>);</span><br><span class="line">        wordDictionary.addWord(<span class="string">&quot;mad&quot;</span>);</span><br><span class="line">        System.out.println(wordDictionary.search(<span class="string">&quot;pad&quot;</span>)); <span class="comment">// Output: false</span></span><br><span class="line">        System.out.println(wordDictionary.search(<span class="string">&quot;bad&quot;</span>)); <span class="comment">// Output: true</span></span><br><span class="line">        System.out.println(wordDictionary.search(<span class="string">&quot;.ad&quot;</span>)); <span class="comment">// Output: true</span></span><br><span class="line">        System.out.println(wordDictionary.search(<span class="string">&quot;b..&quot;</span>)); <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        wordDictionary = <span class="keyword">new</span> DesignAddAndSearchWordsDataStructure211();</span><br><span class="line">        wordDictionary.addWord(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        wordDictionary.addWord(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(wordDictionary.search(<span class="string">&quot;.a&quot;</span>)); <span class="comment">// Output: false</span></span><br><span class="line">        System.out.println(wordDictionary.search(<span class="string">&quot;a.&quot;</span>)); <span class="comment">// Output: false</span></span><br><span class="line">        System.out.println(wordDictionary.search(<span class="string">&quot;a&quot;</span>)); <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">this</span>.isEnd = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj.addWord(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h4 id="212-单词搜索-II-lt-hard-gt"><a href="#212-单词搜索-II-lt-hard-gt" class="headerlink" title="212. 单词搜索 II &lt;hard&gt;"></a>212. 单词搜索 II &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 返回所有二维网格上的单词 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span></span><br><span class="line"><span class="comment">        输出：[&quot;eat&quot;,&quot;oath&quot;]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == board.length</span></span><br><span class="line"><span class="comment">        n == board[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 12</span></span><br><span class="line"><span class="comment">        board[i][j] 是一个小写英文字母</span></span><br><span class="line"><span class="comment">        1 &lt;= words.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">        1 &lt;= words[i].length &lt;= 10</span></span><br><span class="line"><span class="comment">        words[i] 由小写英文字母组成</span></span><br><span class="line"><span class="comment">        words 中的所有字符串互不相同*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordSearchII212</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TrieNode root = buildTrie(words);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历二维字符网格，对每个字符进行 DFS 搜索，检查是否构成 Trie 中的单词。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                dfs(board, i, j, root, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终返回所有找到的单词列表。</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">buildTrie</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 Trie 树建立单词字典，将单词按照字母序插入 Trie 中。</span></span><br><span class="line">        TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.children[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.children[index];</span><br><span class="line">            &#125;</span><br><span class="line">            node.word = word;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode node, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = board[i][j];</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span> || node.children[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字典树对应节点</span></span><br><span class="line">        node = node.children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (node.word != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为避免重复结果，将已经找到的单词从 Trie 中删除。</span></span><br><span class="line">            result.add(node.word);</span><br><span class="line">            node.word = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// Mark visited</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别遍历四个方向</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dfs(board, i - <span class="number">1</span>, j, node, result);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; board.length - <span class="number">1</span>) dfs(board, i + <span class="number">1</span>, j, node, result);</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dfs(board, i, j - <span class="number">1</span>, node, result);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) dfs(board, i, j + <span class="number">1</span>, node, result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复原</span></span><br><span class="line">        board[i][j] = ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设字典中所有单词总长度为 L，board 为 m x n 的网格：</span></span><br><span class="line">        <span class="comment">// Trie 树的构建时间复杂度为 O(L)。</span></span><br><span class="line">        <span class="comment">// 遍历网格的 DFS 搜索时间复杂度为 O(m * n * L)。</span></span><br><span class="line">        <span class="comment">// 总体时间复杂度为 O(m * n * L)。</span></span><br><span class="line">        <span class="comment">// Trie 树的空间复杂度为 O(L)</span></span><br><span class="line">        WordSearchII212 solution = <span class="keyword">new</span> WordSearchII212();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">char</span>[][] board1 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        String[] words1 = &#123;<span class="string">&quot;oath&quot;</span>, <span class="string">&quot;pea&quot;</span>, <span class="string">&quot;eat&quot;</span>, <span class="string">&quot;rain&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; result1 = solution.findWords(board1, words1);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: [&quot;eat&quot;, &quot;oath&quot;]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">char</span>[][] board2 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        String[] words2 = &#123;<span class="string">&quot;abcb&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; result2 = solution.findWords(board2, words2);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: []</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        String word;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">this</span>.word = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-15-回溯-Backtracking"><a href="#3-15-回溯-Backtracking" class="headerlink" title="3.15 回溯 Backtracking"></a>3.15 回溯 Backtracking</h3><p>回溯算法的基本思路：</p>
<ol>
<li><strong>选择：</strong> 在每一步，根据问题的要求，做出一个选择，决定接下来的路径。这个选择可能是从一组可能的选项中选择一个，也可能是决定一个变量的取值，或者其他类似的决策。</li>
<li><strong>路径：</strong> 记录选择构成的路径，通常使用递归调用的栈来保存路径。路径中的每一步都对应了一个选择。</li>
<li><strong>条件：</strong> 确定在当前状态下是否满足问题的条件，即当前路径是否是问题的解。如果满足，就终止递归，得到一个解；如果不满足，进行回溯。</li>
<li><strong>回溯：</strong> 当已经考虑过当前选择，并且发现不能继续扩展出有效解时，需要进行回溯。回溯是撤销当前选择，返回到上一步，尝试其他的可能性。</li>
</ol>
<p>在回溯算法的实现中，经常使用递归函数来实现深度优先搜索。递归函数包括选择、路径记录、条件判断和回溯这几个重要的步骤。</p>
<p>一般用于<strong>排列组合</strong>问题等。</p>
<p>顶层调用函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 最终结果集合</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前结果</span></span><br><span class="line">    List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 全排列时使用标识集合</span></span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    backtrack(nums, used, current, result);</span><br><span class="line">    <span class="comment">// 非全排列时，增加一个索引标识起点</span></span><br><span class="line">    backtrack(nums, <span class="number">0</span> or <span class="number">1</span>, current, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>回溯算法：</p>
<ul>
<li><p>非全排列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &#123;条件&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(current));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 非全排列标记一个起点，若元素能重复，则递归仍为i，否则为i+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        current.add(nums[i]);</span><br><span class="line">        <span class="comment">// 递归可以重复当前元素</span></span><br><span class="line">        backtrack(nums, target - nums[i], i, current, result);</span><br><span class="line">        <span class="comment">// &#123;回溯&#125;</span></span><br><span class="line">        current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>全排列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &#123;条件&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (current.size() == nums.length) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(current));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 全排列时每次递归都重新遍历集合，跳过已被使用的元素，在回溯时可以在上层加入靠后元素，在下层加入靠前元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">            <span class="comment">// 从0开始，依次加入nums.length个元素</span></span><br><span class="line">            current.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtrack(nums, used, current, result);</span><br><span class="line">            <span class="comment">// &#123;回溯&#125;</span></span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
<h4 id="17-电话号码的字母组合-lt-medium-gt"><a href="#17-电话号码的字母组合-lt-medium-gt" class="headerlink" title="17. 电话号码的字母组合 &lt;medium&gt;"></a>17. 电话号码的字母组合 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：digits = &quot;23&quot;</span></span><br><span class="line"><span class="comment">        输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：digits = &quot;&quot;</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：digits = &quot;2&quot;</span></span><br><span class="line"><span class="comment">        输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= digits.length &lt;= 4</span></span><br><span class="line"><span class="comment">        digits[i] 是范围 [&#x27;2&#x27;, &#x27;9&#x27;] 的一个数字。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetterCombinationsOfAPhoneNumber17</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化每个数字对应的字母集合</span></span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = initializePhoneMap();</span><br><span class="line">        <span class="comment">// 使用回溯算法，遍历数字字符串的每个数字，根据数字映射得到对应的字母集合。</span></span><br><span class="line">        backtrack(digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder(), phoneMap, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String digits, <span class="keyword">int</span> index, StringBuilder current, Map&lt;Character, String&gt; phoneMap, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            <span class="comment">// 将每次深度优先搜索得到的组合加入结果集。</span></span><br><span class="line">            result.add(current.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个组合字母，深度优先搜索，直到达到数字字符串的末尾。</span></span><br><span class="line">        <span class="keyword">char</span> digit = digits.charAt(index);</span><br><span class="line">        String letters = phoneMap.get(digit);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> letter : letters.toCharArray()) &#123;</span><br><span class="line">            current.append(letter);</span><br><span class="line">            backtrack(digits, index + <span class="number">1</span>, current, phoneMap, result);</span><br><span class="line">            current.deleteCharAt(current.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Character, String&gt; <span class="title">initializePhoneMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        phoneMap.put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        phoneMap.put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">        phoneMap.put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        phoneMap.put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        phoneMap.put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        phoneMap.put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        phoneMap.put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        phoneMap.put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> phoneMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 时间复杂度：对于每个数字，最坏情况下需要遍历其对应的字母集合，因此时间复杂度为 O(3^N * 4^M)，其中 N 和 M 分别表示 digits 中对应 3 个和 4 个字母的数字的数量。</span></span><br><span class="line">        <span class="comment">// 空间复杂度：除了返回值外，递归调用栈的最大深度为 digits 的长度，因此空间复杂度为 O(N)，其中 N 表示 digits 的长度。</span></span><br><span class="line">        LetterCombinationsOfAPhoneNumber17 solution = <span class="keyword">new</span> LetterCombinationsOfAPhoneNumber17();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        String digits1 = <span class="string">&quot;23&quot;</span>;</span><br><span class="line">        List&lt;String&gt; result1 = solution.letterCombinations(digits1);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        String digits2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        List&lt;String&gt; result2 = solution.letterCombinations(digits2);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: []</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        String digits3 = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        List&lt;String&gt; result3 = solution.letterCombinations(digits3);</span><br><span class="line">        System.out.println(result3);  <span class="comment">// Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="77-组合-lt-medium-gt"><a href="#77-组合-lt-medium-gt" class="headerlink" title="77. 组合 &lt;medium&gt;"></a>77. 组合 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以按 任何顺序 返回答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 4, k = 2</span></span><br><span class="line"><span class="comment">        输出：</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">        [2,4],</span></span><br><span class="line"><span class="comment">        [3,4],</span></span><br><span class="line"><span class="comment">        [2,3],</span></span><br><span class="line"><span class="comment">        [1,2],</span></span><br><span class="line"><span class="comment">        [1,3],</span></span><br><span class="line"><span class="comment">        [1,4],</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 1, k = 1</span></span><br><span class="line"><span class="comment">        输出：[[1]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 20</span></span><br><span class="line"><span class="comment">        1 &lt;= k &lt;= n*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Combinations77</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 主要的思路是从1到n逐个尝试作为组合的起始元素，然后递归地向后查找剩余的元素。</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(n, k, <span class="number">1</span>, current, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在递归的过程中，需要注意设置递归的终止条件，即已经选取了k个元素。</span></span><br><span class="line">        <span class="keyword">if</span> (current.size() == k) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(current));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先加入当前start，然后递归加入剩余k-1个元素，每次都移除最后一个元素，然后加入新元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">            current.add(i);</span><br><span class="line">            backtrack(n, k, i + <span class="number">1</span>, current, result);</span><br><span class="line">            <span class="comment">// 每次递归选择一个元素后，需要将其从当前组合中移除，以便尝试其他组合。</span></span><br><span class="line">            current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于需要遍历所有可能的组合，时间复杂度为O(C(n, k))，其中C(n, k)表示从n个元素中选择k个的组合数。</span></span><br><span class="line">        <span class="comment">//空间复杂度为O(k)，主要用于存储递归过程中的当前组合。</span></span><br><span class="line">        Combinations77 solution = <span class="keyword">new</span> Combinations77();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">4</span>, k1 = <span class="number">2</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result1 = solution.combine(n1, k1);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        <span class="comment">// Output: [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">1</span>, k2 = <span class="number">1</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result2 = solution.combine(n2, k2);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        <span class="comment">// Output: [[1]]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="46-全排列-lt-medium-gt"><a href="#46-全排列-lt-medium-gt" class="headerlink" title="46. 全排列 &lt;medium&gt;"></a>46. 全排列 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment">        输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,1]</span></span><br><span class="line"><span class="comment">        输出：[[0,1],[1,0]]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1]</span></span><br><span class="line"><span class="comment">        输出：[[1]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 6</span></span><br><span class="line"><span class="comment">        -10 &lt;= nums[i] &lt;= 10</span></span><br><span class="line"><span class="comment">        nums 中的所有整数 互不相同*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutations46</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums, used, current, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(current));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次递归都重新遍历集合，跳过已被使用的元素，在回溯时可以在上层加入靠后元素，在下层加入靠前元素</span></span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                <span class="comment">// 从0开始，依次加入nums.length个元素</span></span><br><span class="line">                current.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                backtrack(nums, used, current, result);</span><br><span class="line">                <span class="comment">// 恢复状态</span></span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Permutations46 solution = <span class="keyword">new</span> Permutations46();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result1 = solution.permute(nums1);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        <span class="comment">// Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result2 = solution.permute(nums2);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        <span class="comment">// Output: [[0, 1], [1, 0]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result3 = solution.permute(nums3);</span><br><span class="line">        System.out.println(result3);</span><br><span class="line">        <span class="comment">// Output: [[1]]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="39-组合总和-lt-medium-gt"><a href="#39-组合总和-lt-medium-gt" class="headerlink" title="39. 组合总和 &lt;medium&gt;"></a>39. 组合总和 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        对于给定的输入，保证和为 target 的不同组合数少于 150 个。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：candidates = [2,3,6,7], target = 7</span></span><br><span class="line"><span class="comment">        输出：[[2,2,3],[7]]</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span></span><br><span class="line"><span class="comment">        7 也是一个候选， 7 = 7 。</span></span><br><span class="line"><span class="comment">        仅有这两种组合。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: candidates = [2,3,5], target = 8</span></span><br><span class="line"><span class="comment">        输出: [[2,2,2,2],[2,3,3],[3,5]]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: candidates = [2], target = 1</span></span><br><span class="line"><span class="comment">        输出: []</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= candidates.length &lt;= 30</span></span><br><span class="line"><span class="comment">        2 &lt;= candidates[i] &lt;= 40</span></span><br><span class="line"><span class="comment">        candidates 的所有元素 互不相同</span></span><br><span class="line"><span class="comment">        1 &lt;= target &lt;= 40*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum39</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; current = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>, current, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, List&lt;Integer&gt; current, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(current));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &lt;= target) &#123;</span><br><span class="line">                current.add(candidates[i]);</span><br><span class="line">                <span class="comment">// 递归可以重复当前元素</span></span><br><span class="line">                backtrack(candidates, target - candidates[i], i, current, result);</span><br><span class="line">                current.remove(current.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CombinationSum39 solution = <span class="keyword">new</span> CombinationSum39();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] candidates1 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target1 = <span class="number">7</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result1 = solution.combinationSum(candidates1, target1);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        <span class="comment">// Output: [[2, 2, 3], [7]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] candidates2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target2 = <span class="number">8</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result2 = solution.combinationSum(candidates2, target2);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        <span class="comment">// Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        <span class="keyword">int</span>[] candidates3 = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target3 = <span class="number">1</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result3 = solution.combinationSum(candidates3, target3);</span><br><span class="line">        System.out.println(result3);</span><br><span class="line">        <span class="comment">// Output: []</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="52-N-皇后-II-lt-hard-gt"><a href="#52-N-皇后-II-lt-hard-gt" class="headerlink" title="52. N 皇后 II &lt;hard&gt;"></a>52. N 皇后 II &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 4</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        解释：如上图所示，4 皇后问题存在两个不同的解法。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 1</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 9*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NQueensII52</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用数组包装结果，方便在递归中修改</span></span><br><span class="line">        <span class="keyword">int</span>[] result = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合下标和值分别对应行列</span></span><br><span class="line">        <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充集合</span></span><br><span class="line">        Arrays.fill(queens, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在递归的过程中，每次选择一个合适的位置放置皇后，然后进入下一行的递归。如果某一行找不到合适的位置，则需要回溯到上一行，尝试其他位置，直到找到所有合适的位置或者递归结束。</span></span><br><span class="line">        solveNQueens(queens, n, <span class="number">0</span>, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span>[] queens, <span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span>[] result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归结束，结果+1，回溯</span></span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            result[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="comment">// 为了避免皇后互相攻击，需要检查当前位置是否与之前的皇后位置冲突</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(queens, row, col)) &#123;</span><br><span class="line">                queens[row] = col;</span><br><span class="line">                solveNQueens(queens, n, row + <span class="number">1</span>, result);</span><br><span class="line">                <span class="comment">// 回溯复原</span></span><br><span class="line">                queens[row] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] queens, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历皇后集合，检查同一列、同一行以及对角线上是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queens[i] == col || Math.abs(queens[i] - col) == Math.abs(i - row)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 时间复杂度为O(N!)，其中N为棋盘边长。</span></span><br><span class="line">        <span class="comment">// 空间复杂度为O(N)，主要用于存储每行皇后的位置。</span></span><br><span class="line">        NQueensII52 solution = <span class="keyword">new</span> NQueensII52();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> result1 = solution.totalNQueens(n1);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        <span class="comment">// Output: 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result2 = solution.totalNQueens(n2);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        <span class="comment">// Output: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="22-括号生成-lt-medium-gt"><a href="#22-括号生成-lt-medium-gt" class="headerlink" title="22. 括号生成 &lt;medium&gt;"></a>22. 括号生成 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 3</span></span><br><span class="line"><span class="comment">        输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 1</span></span><br><span class="line"><span class="comment">        输出：[&quot;()&quot;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 8*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateParentheses22</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        generateParenthesisHelper(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, n, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateParenthesisHelper</span><span class="params">(String current, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 满足条件</span></span><br><span class="line">        <span class="keyword">if</span> (current.length() == <span class="number">2</span> * n) &#123;</span><br><span class="line">            result.add(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左括号先递归</span></span><br><span class="line">        <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">            generateParenthesisHelper(current + <span class="string">&#x27;(&#x27;</span>, open + <span class="number">1</span>, close, n, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右括号递归，不能先于左括号出现</span></span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            generateParenthesisHelper(current + <span class="string">&#x27;)&#x27;</span>, open, close + <span class="number">1</span>, n, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenerateParentheses22 solution = <span class="keyword">new</span> GenerateParentheses22();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">3</span>;</span><br><span class="line">        List&lt;String&gt; result1 = solution.generateParenthesis(n1);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        <span class="comment">// Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">1</span>;</span><br><span class="line">        List&lt;String&gt; result2 = solution.generateParenthesis(n2);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        <span class="comment">// Output: [&quot;()&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="79-单词搜索-lt-medium-gt"><a href="#79-单词搜索-lt-medium-gt" class="headerlink" title="79. 单词搜索 &lt;medium&gt;"></a>79. 单词搜索 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == board.length</span></span><br><span class="line"><span class="comment">        n = board[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 6</span></span><br><span class="line"><span class="comment">        1 &lt;= word.length &lt;= 15</span></span><br><span class="line"><span class="comment">        board 和 word 仅由大小写英文字母组成</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordSearch79</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历整个二维字符网格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 在递归的过程中，需要进行剪枝，即在遍历的过程中标记已经访问过的位置，并在递归结束后恢复标记。</span></span><br><span class="line">                <span class="keyword">if</span> (dfs(board, word, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件，超边界 or 字符不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word.charAt(k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前字符匹配，且已经匹配到最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (k == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 临时标记当前位置已访问</span></span><br><span class="line">        <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历四个方向</span></span><br><span class="line">        <span class="keyword">boolean</span> result = dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, word, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复当前位置字符</span></span><br><span class="line">        board[i][j] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WordSearch79 solution = <span class="keyword">new</span> WordSearch79();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">char</span>[][] board1 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;S&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        String word1 = <span class="string">&quot;ABCCED&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result1 = solution.exist(board1, word1);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">char</span>[][] board2 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;S&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        String word2 = <span class="string">&quot;SEE&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result2 = solution.exist(board2, word2);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        <span class="keyword">char</span>[][] board3 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;S&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        String word3 = <span class="string">&quot;ABCB&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result3 = solution.exist(board3, word3);</span><br><span class="line">        System.out.println(result3);</span><br><span class="line">        <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-16-分治-Divide-and-Conquer"><a href="#3-16-分治-Divide-and-Conquer" class="headerlink" title="3.16 分治 Divide and Conquer"></a>3.16 分治 Divide and Conquer</h3><p><strong>分治思想：</strong>分治是将一个大问题分割成多个相同或相似的子问题，递归地解决这些子问题，然后合并其结果，得到原问题的解。</p>
<p>分治思想通常包含三个步骤：</p>
<ol>
<li><strong>分解（Divide）：</strong> 将原问题分解成若干个规模较小、相对独立且与原问题形式相同的子问题。</li>
<li><strong>解决（Conquer）：</strong> 递归地解决这些子问题。如果子问题规模足够小，直接求解。</li>
<li><strong>合并（Combine）：</strong> 将子问题的解合并成原问题的解。</li>
</ol>
<p>分治算法通常应用于可以被划分为相互独立的子问题，并且子问题的结构和整体问题相似的情况。它常被用来解决复杂度较高的问题，尤其在<strong>递归</strong>实现时可以显著降低问题的规模。</p>
<p><strong>分治算法的运用场景：</strong></p>
<ol>
<li><strong>排序算法：</strong> 归并排序和快速排序都是基于分治思想的排序算法。</li>
<li><strong>搜索问题：</strong> 二分查找是分治思想的一个经典例子。</li>
<li><strong>最大子数组问题：</strong> 通过将问题分解为左子数组、右子数组和跨越中点的子数组，并在这三者中找到最大值，从而解决整体问题。</li>
<li><strong>大整数乘法：</strong> 将大整数分解为两半，递归地计算各自的乘积，然后合并结果。</li>
<li><strong>快速傅里叶变换（FFT）：</strong> 在信号处理和图像处理领域中广泛使用的一种算法，它利用分治思想高效计算多项式的离散傅里叶变换。</li>
</ol>
<p><strong>经典分治算法例子：</strong></p>
<ol>
<li><strong>归并排序（Merge Sort）：</strong> 将数组一分为二，递归地对两个子数组进行排序，然后将有序的子数组合并成一个有序数组。</li>
<li><strong>快速排序（Quick Sort）：</strong> 选择一个基准元素，将数组分为两部分，分别递归地对两部分进行排序，然后合并。</li>
<li><strong>二分查找：</strong> 在有序数组中查找目标元素，每次将查找范围一分为二，逐步缩小范围直到找到目标或范围为空。</li>
</ol>
<p><strong>分治算法的优缺点：</strong></p>
<p><strong>优点：</strong></p>
<ol>
<li>结构清晰，易于理解和实现。</li>
<li>并行化的可能性，因为子问题相互独立。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>递归和合并步骤可能会引入额外的时间和空间开销。</li>
<li>对于一些问题，划分子问题的代价可能较高。</li>
</ol>
<p><strong>参考题目：</strong></p>
<ol>
<li><strong>归并排序：</strong> LeetCode 148. Sort List</li>
<li><strong>快速排序：</strong> LeetCode 912. Sort an Array</li>
<li><strong>二分查找：</strong> LeetCode 704. Binary Search</li>
<li><strong>最大子数组问题：</strong> LeetCode 53. Maximum Subarray</li>
<li><strong>大整数乘法：</strong> LeetCode 43. Multiply Strings</li>
</ol>
<h4 id="108-将有序数组转换为二叉搜索树-lt-easy-gt"><a href="#108-将有序数组转换为二叉搜索树-lt-easy-gt" class="headerlink" title="108. 将有序数组转换为二叉搜索树  &lt;easy&gt;"></a>108. 将有序数组转换为二叉搜索树  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [-10,-3,0,5,9]</span></span><br><span class="line"><span class="comment">        输出：[0,-3,9,-10,null,5]</span></span><br><span class="line"><span class="comment">        解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1,3]</span></span><br><span class="line"><span class="comment">        输出：[3,1]</span></span><br><span class="line"><span class="comment">        解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">        -104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">        nums 按 严格递增 顺序排列*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedArrayToBinarySearchTree108</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于数组已经按照升序排列，我们可以选择数组的中间元素作为根节点，然后递归地对左右两个子数组分别构建左右子树，直到整个数组构建完毕。</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = buildBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = buildBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每个节点都会被访问一次，因此时间复杂度是O(n)，其中n是数组的长度。</span></span><br><span class="line">        <span class="comment">// 递归调用的深度是树的高度，平均情况下为O(log n)，最坏情况下为O(n)（当树退化为链表时）。</span></span><br><span class="line">        ConvertSortedArrayToBinarySearchTree108 solution = <span class="keyword">new</span> ConvertSortedArrayToBinarySearchTree108();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;-<span class="number">10</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        TreeNode result1 = solution.sortedArrayToBST(nums1);</span><br><span class="line">        System.out.println(result1.val);</span><br><span class="line">        <span class="comment">// Output: [0,-3,9,-10,null,5]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        TreeNode result2 = solution.sortedArrayToBST(nums2);</span><br><span class="line">        System.out.println(result2.val);</span><br><span class="line">        <span class="comment">// Output: [3,1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="148-排序链表-lt-medium-gt"><a href="#148-排序链表-lt-medium-gt" class="headerlink" title="148. 排序链表 &lt;medium&gt;"></a>148. 排序链表 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [4,2,1,3]</span></span><br><span class="line"><span class="comment">        输出：[1,2,3,4]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = [-1,5,3,4,0]</span></span><br><span class="line"><span class="comment">        输出：[-1,0,3,4,5]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：head = []</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        链表中节点的数目在范围 [0, 5 * 104] 内</span></span><br><span class="line"><span class="comment">        -105 &lt;= Node.val &lt;= 105</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortList148</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用归并排序的思想，将链表不断划分成两半，递归地对左右两半进行排序，最后合并两个有序链表</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode mid = findMiddle(head);</span><br><span class="line">        <span class="comment">// 递归切割左边</span></span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        <span class="comment">// 递归切割右边</span></span><br><span class="line">        ListNode right = sortList(mid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 升序合并两个链表</span></span><br><span class="line">        <span class="keyword">return</span> merge(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">findMiddle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指针，快指针是慢指针的两倍速度</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prev指向slow指针，即链表中间，将链表截断</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时遍历两个链表</span></span><br><span class="line">        <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用current指向小的节点，将两个链表连在一起</span></span><br><span class="line">            <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">                current.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连上剩余的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            current.next = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            current.next = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">createLinkedList</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : values) &#123;</span><br><span class="line">            current.next = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次递归划分链表，时间复杂度为O(log n)，每次合并两个有序链表的时间复杂度为O(n)，总体时间复杂度为O(n log n)</span></span><br><span class="line">        <span class="comment">// 递归调用的深度为O(log n)，因此空间复杂度为O(log n)</span></span><br><span class="line">        SortList148 solution = <span class="keyword">new</span> SortList148();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        ListNode head1 = solution.createLinkedList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;);</span><br><span class="line">        ListNode result1 = solution.sortList(head1);</span><br><span class="line">        solution.printLinkedList(result1);</span><br><span class="line">        <span class="comment">// Output: [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        ListNode head2 = solution.createLinkedList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        ListNode result2 = solution.sortList(head2);</span><br><span class="line">        solution.printLinkedList(result2);</span><br><span class="line">        <span class="comment">// Output: [-1,0,3,4,5]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        ListNode head3 = solution.createLinkedList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;);</span><br><span class="line">        ListNode result3 = solution.sortList(head3);</span><br><span class="line">        solution.printLinkedList(result3);</span><br><span class="line">        <span class="comment">// Output: []</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="427-建立四叉树-lt-medium-gt"><a href="#427-建立四叉树-lt-medium-gt" class="headerlink" title="427. 建立四叉树 &lt;medium&gt;"></a>427. 建立四叉树 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个 n * n 矩阵 grid ，矩阵由若干 0 和 1 组成。请你用四叉树表示该矩阵 grid 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你需要返回能表示矩阵 grid 的 四叉树 的根结点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        val：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False。注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。</span></span><br><span class="line"><span class="comment">        isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 。</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public boolean val;</span></span><br><span class="line"><span class="comment">    public boolean isLeaf;</span></span><br><span class="line"><span class="comment">    public Node topLeft;</span></span><br><span class="line"><span class="comment">    public Node topRight;</span></span><br><span class="line"><span class="comment">    public Node bottomLeft;</span></span><br><span class="line"><span class="comment">    public Node bottomRight;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">我们可以按以下步骤为二维区域构建四叉树：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果当前网格的值相同（即，全为 0 或者全为 1），将 isLeaf 设为 True ，将 val 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</span></span><br><span class="line"><span class="comment">        如果当前网格的值不同，将 isLeaf 设为 False， 将 val 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</span></span><br><span class="line"><span class="comment">        使用适当的子网格递归每个子节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果你想了解更多关于四叉树的内容，可以参考 wiki 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        四叉树格式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你不需要阅读本节来解决这个问题。只有当你想了解输出格式时才会这样做。输出为使用层序遍历后四叉树的序列化形式，其中 null 表示路径终止符，其下面不存在节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 [isLeaf, val] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果 isLeaf 或者 val 的值为 True ，则表示它在列表 [isLeaf, val] 中的值为 1 ；如果 isLeaf 或者 val 的值为 False ，则表示值为 0 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：grid = [[0,1],[1,0]]</span></span><br><span class="line"><span class="comment">        输出：[[0,1],[1,0],[1,1],[1,1],[1,0]]</span></span><br><span class="line"><span class="comment">        解释：此示例的解释如下：</span></span><br><span class="line"><span class="comment">        请注意，在下面四叉树的图示中，0 表示 false，1 表示 True 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]</span></span><br><span class="line"><span class="comment">        输出：[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]</span></span><br><span class="line"><span class="comment">        解释：网格中的所有值都不相同。我们将网格划分为四个子网格。</span></span><br><span class="line"><span class="comment">        topLeft，bottomLeft 和 bottomRight 均具有相同的值。</span></span><br><span class="line"><span class="comment">        topRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。</span></span><br><span class="line"><span class="comment">        解释如下图所示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        n == grid.length == grid[i].length</span></span><br><span class="line"><span class="comment">        n == 2x 其中 0 &lt;= x &lt;= 6*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructQuadTree427</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">construct</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给定一个由 0 和 1 组成的矩阵 grid，我们需要构建一个四叉树表示这个矩阵。四叉树的每个节点有两个属性：val 表示节点的值（0 或 1），isLeaf 表示是否为叶子节点。如果一个节点是叶子节点，则其四个子节点都为 null。</span></span><br><span class="line">        <span class="comment">// 构建四叉树的基本思路是递归处理，首先判断当前区域是否为叶子节点，如果是，则创建一个叶子节点，否则，将当前区域划分为四个子区域，分别递归构建四叉树。</span></span><br><span class="line">        <span class="keyword">return</span> build(grid, <span class="number">0</span>, <span class="number">0</span>, grid.length - <span class="number">1</span>, grid[<span class="number">0</span>].length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">build</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> rowStart, <span class="keyword">int</span> colStart, <span class="keyword">int</span> rowEnd, <span class="keyword">int</span> colEnd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个递归函数 build，该函数接收矩阵的左上角和右下角的坐标，然后判断当前区域是否为叶子节点。</span></span><br><span class="line">        <span class="comment">// 如果是叶子节点，创建一个叶子节点，将 val 设置为当前区域的值，isLeaf 设置为 true。</span></span><br><span class="line">        <span class="comment">// 如果不是叶子节点，计算当前区域的中心坐标 (midRow, midCol)，然后递归构建四个子区域。</span></span><br><span class="line">        <span class="comment">// 返回根节点。</span></span><br><span class="line">        <span class="keyword">if</span> (rowStart &gt; rowEnd || colStart &gt; colEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if the current region is a leaf</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeaf = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> val = grid[rowStart][colStart];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rowStart; i &lt;= rowEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colStart; j &lt;= colEnd; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != val) &#123;</span><br><span class="line">                    isLeaf = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If it&#x27;s a leaf, create a leaf node</span></span><br><span class="line">        <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(val == <span class="number">1</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If it&#x27;s not a leaf, divide the region into four sub-regions</span></span><br><span class="line">        <span class="keyword">int</span> midRow = (rowStart + rowEnd) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midCol = (colStart + colEnd) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        Node topLeft = build(grid, rowStart, colStart, midRow, midCol);</span><br><span class="line">        Node topRight = build(grid, rowStart, midCol + <span class="number">1</span>, midRow, colEnd);</span><br><span class="line">        Node bottomLeft = build(grid, midRow + <span class="number">1</span>, colStart, rowEnd, midCol);</span><br><span class="line">        Node bottomRight = build(grid, midRow + <span class="number">1</span>, midCol + <span class="number">1</span>, rowEnd, colEnd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a non-leaf node</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="keyword">false</span>, <span class="keyword">false</span>, topLeft, topRight, bottomLeft, bottomRight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在每个递归步骤中，我们对每个区域进行常数次操作，因此时间复杂度为 O(n)，其中 n 是矩阵的总元素数量。</span></span><br><span class="line">        <span class="comment">//递归调用的深度是 O(logn)，因此空间复杂度也是 O(logn)。</span></span><br><span class="line">        ConstructQuadTree427 solution = <span class="keyword">new</span> ConstructQuadTree427();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] grid1 = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        Node result1 = solution.construct(grid1);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] grid2 = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Node result2 = solution.construct(grid2);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> val;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isLeaf;</span><br><span class="line">        <span class="keyword">public</span> Node topLeft;</span><br><span class="line">        <span class="keyword">public</span> Node topRight;</span><br><span class="line">        <span class="keyword">public</span> Node bottomLeft;</span><br><span class="line">        <span class="keyword">public</span> Node bottomRight;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> val, <span class="keyword">boolean</span> isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.isLeaf = isLeaf;</span><br><span class="line">            <span class="keyword">this</span>.topLeft = topLeft;</span><br><span class="line">            <span class="keyword">this</span>.topRight = topRight;</span><br><span class="line">            <span class="keyword">this</span>.bottomLeft = bottomLeft;</span><br><span class="line">            <span class="keyword">this</span>.bottomRight = bottomRight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="23-合并-K-个升序链表-lt-hard-gt"><a href="#23-合并-K-个升序链表-lt-hard-gt" class="headerlink" title="23. 合并 K 个升序链表 &lt;hard&gt;"></a>23. 合并 K 个升序链表 &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个链表数组，每个链表都已经按升序排列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请你将所有链表合并到一个升序链表中，返回合并后的链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：lists = [[1,4,5],[1,3,4],[2,6]]</span></span><br><span class="line"><span class="comment">        输出：[1,1,2,3,4,4,5,6]</span></span><br><span class="line"><span class="comment">        解释：链表数组如下：</span></span><br><span class="line"><span class="comment">        [</span></span><br><span class="line"><span class="comment">        1-&gt;4-&gt;5,</span></span><br><span class="line"><span class="comment">        1-&gt;3-&gt;4,</span></span><br><span class="line"><span class="comment">        2-&gt;6</span></span><br><span class="line"><span class="comment">        ]</span></span><br><span class="line"><span class="comment">        将它们合并到一个有序链表中得到。</span></span><br><span class="line"><span class="comment">        1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：lists = []</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：lists = [[]]</span></span><br><span class="line"><span class="comment">        输出：[]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        k == lists.length</span></span><br><span class="line"><span class="comment">        0 &lt;= k &lt;= 10^4</span></span><br><span class="line"><span class="comment">        0 &lt;= lists[i].length &lt;= 500</span></span><br><span class="line"><span class="comment">        -10^4 &lt;= lists[i][j] &lt;= 10^4</span></span><br><span class="line"><span class="comment">        lists[i] 按 升序 排列</span></span><br><span class="line"><span class="comment">        lists[i].length 的总和不超过 10^4*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeKSortedLists23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个小顶堆，堆中的元素为链表的头结点：使用优先队列（PriorityQueue）来维护链表的头结点，每次取出最小的结点进行合并。</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.val));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个链表，将链表的头结点加入到优先队列中。</span></span><br><span class="line">        <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                minHeap.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 dummy 结点作为合并后链表的头结点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环处理堆中的结点，每次取出堆顶最小结点，将其下一个结点加入堆中，直到所有链表都合并完成。</span></span><br><span class="line">        <span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">            ListNode minNode = minHeap.poll();</span><br><span class="line">            current.next = minNode;</span><br><span class="line">            current = current.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                minHeap.add(minNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helper method to create a linked list from an array</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">createList</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode current = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : values) &#123;</span><br><span class="line">            current.next = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helper method to print a linked list</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设所有链表的总节点数为 n，每次从优先队列中取出最小结点的时间复杂度为 O(logk)，其中 k 是链表的个数。总体时间复杂度为 O(n * logk)。</span></span><br><span class="line">        <span class="comment">// 优先队列中最多有 k 个节点，因此空间复杂度为 O(k)。</span></span><br><span class="line">        MergeKSortedLists23 solution = <span class="keyword">new</span> MergeKSortedLists23();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] values1 = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] values2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] values3 = &#123;<span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        ListNode list1 = solution.createList(values1);</span><br><span class="line">        ListNode list2 = solution.createList(values2);</span><br><span class="line">        ListNode list3 = solution.createList(values3);</span><br><span class="line">        ListNode[] lists1 = &#123;list1, list2, list3&#125;;</span><br><span class="line">        ListNode result1 = solution.mergeKLists(lists1);</span><br><span class="line">        solution.printList(result1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 2</span></span><br><span class="line">        ListNode[] lists2 = &#123;&#125;;</span><br><span class="line">        ListNode result2 = solution.mergeKLists(lists2);</span><br><span class="line">        solution.printList(result2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 3</span></span><br><span class="line">        ListNode[] lists3 = &#123;<span class="keyword">null</span>&#125;;</span><br><span class="line">        ListNode result3 = solution.mergeKLists(lists3);</span><br><span class="line">        solution.printList(result3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() &#123;&#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-17-Kadane算法-Kadane’s-Algorithm"><a href="#3-17-Kadane算法-Kadane’s-Algorithm" class="headerlink" title="3.17 Kadane算法 Kadane’s Algorithm"></a>3.17 Kadane算法 Kadane’s Algorithm</h3><p>Kadane算法用于解决最大子数组和问题，即在一个数组中找到一个连续的子数组，使得该子数组的和最大。算法的核心思想是使用<strong>动态规划</strong>的思想，维护两个变量：</p>
<ol>
<li><code>currentMax</code>: 表示以当前元素为结尾的子数组的最大和。</li>
<li><code>globalMax</code>: 表示整个数组中最大的子数组和。</li>
</ol>
<p>算法的步骤如下：</p>
<ol>
<li>初始化 <code>currentMax</code> 和 <code>globalMax</code> 为数组的第一个元素。</li>
<li>遍历数组，对于每个元素，更新 <code>currentMax</code> 为当前元素与当前元素加上 <code>currentMax</code> 的较大值。</li>
<li>每次更新 <code>currentMax</code> 时，将其与 <code>globalMax</code> 比较，更新 <code>globalMax</code> 为两者的较大值。</li>
<li>最终，<code>globalMax</code> 就是数组中最大的子数组和。</li>
</ol>
<p>以下是Kadane算法的Java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KadaneAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Input array is invalid.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentMax = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> globalMax = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            currentMax = Math.max(nums[i], currentMax + nums[i]);</span><br><span class="line">            globalMax = Math.max(globalMax, currentMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> globalMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Test case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test case 1: &quot;</span> + maxSubArray(nums1)); <span class="comment">// Output: 6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test case 2: &quot;</span> + maxSubArray(nums2)); <span class="comment">// Output: 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 3</span></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">5</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test case 3: &quot;</span> + maxSubArray(nums3)); <span class="comment">// Output: 23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法复杂度:</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组的长度。</li>
<li>空间复杂度：O(1)，算法只使用了常数个额外的变量。</li>
</ul>
<h4 id="53-最大子数组和-lt-medium-gt"><a href="#53-最大子数组和-lt-medium-gt" class="headerlink" title="53. 最大子数组和 &lt;medium&gt;"></a>53. 最大子数组和 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        子数组 是数组中的一个连续部分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span></span><br><span class="line"><span class="comment">        输出：6</span></span><br><span class="line"><span class="comment">        解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [5,4,-1,7,8]</span></span><br><span class="line"><span class="comment">        输出：23</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">        -104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarray53</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentMax = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> globalMax = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            currentMax = Math.max(nums[i], currentMax + nums[i]);</span><br><span class="line">            globalMax = Math.max(globalMax, currentMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> globalMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaximumSubarray53 solution = <span class="keyword">new</span> MaximumSubarray53();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxSubArray(nums));</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxSubArray(nums1));</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">5</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxSubArray(nums2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="918-环形子数组的最大和-lt-medium-gt"><a href="#918-环形子数组的最大和-lt-medium-gt" class="headerlink" title="918. 环形子数组的最大和 &lt;medium&gt;"></a>918. 环形子数组的最大和 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % n == k2 % n 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1,-2,3,-2]</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        解释：从子数组 [3] 得到最大和 3</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [5,-3,5]</span></span><br><span class="line"><span class="comment">        输出：10</span></span><br><span class="line"><span class="comment">        解释：从子数组 [5,5] 得到最大和 5 + 5 = 10</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [3,-2,2,-3]</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        n == nums.length</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">        -3 * 104 &lt;= nums[i] &lt;= 3 * 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumSumCircularSubarray918</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> currentMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> currentMin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别获取总和、最大子数组和、最小子数组和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            totalSum += num;</span><br><span class="line"></span><br><span class="line">            currentMax = Math.max(currentMax + num, num);</span><br><span class="line">            maxSum = Math.max(maxSum, currentMax);</span><br><span class="line"></span><br><span class="line">            currentMin = Math.min(currentMin + num, num);</span><br><span class="line">            minSum = Math.min(minSum, currentMin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当最大子数组和大于0时，取最大子数组和、总和-最小子数组和二者最大的值为实际上的最大和</span></span><br><span class="line">        <span class="keyword">if</span> (maxSum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(maxSum, totalSum - minSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当最大子数组和小于0时，数组中不包含大于等于 0 的元素</span></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaximumSumCircularSubarray918 solution = <span class="keyword">new</span> MaximumSumCircularSubarray918();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,-<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxSubarraySumCircular(nums));</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">5</span>,-<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxSubarraySumCircular(nums1));</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">3</span>,-<span class="number">2</span>,<span class="number">2</span>,-<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxSubarraySumCircular(nums2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-18-二分查找-Binary-Search"><a href="#3-18-二分查找-Binary-Search" class="headerlink" title="3.18 二分查找 Binary Search"></a>3.18 二分查找 Binary Search</h3><p>二分查找：通过比较目标值与数组中间元素的大小关系，从而将搜索范围缩小一半。如果目标值等于中间元素，搜索成功。如果目标值小于中间元素，说明目标值可能在数组的左半部分，可以将搜索范围缩小到左半部分。如果目标值大于中间元素，说明目标值可能在数组的右半部分，可以将搜索范围缩小到右半部分。重复这个过程，直到找到目标值或者搜索范围为空。</p>
<p>基本步骤：</p>
<ol>
<li>初始化左右两个指针，分别指向数组的第一个元素和最后一个元素。</li>
<li>计算中间元素的索引。</li>
<li>比较中间元素与目标值的大小。<ul>
<li>如果中间元素等于目标值，返回中间元素的索引。</li>
<li>如果中间元素小于目标值，说明目标值可能在右半部分，将左指针移动到中间元素的右侧一位。</li>
<li>如果中间元素大于目标值，说明目标值可能在左半部分，将右指针移动到中间元素的左侧一位。</li>
</ul>
</li>
<li>重复步骤2到步骤3，直到左指针大于右指针，说明搜索范围为空，返回 -1 表示未找到目标值。</li>
</ol>
<p>时间复杂度是 O(log n)，其中 n 是数组的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 目标值找到，返回索引</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 目标值在右半部分，更新左指针</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 目标值在左半部分，更新右指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 搜索范围为空，未找到目标值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = binarySearch(nums, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目标值 &quot;</span> + target + <span class="string">&quot; 在数组中的索引为 &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目标值 &quot;</span> + target + <span class="string">&quot; 不在数组中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="35-搜索插入位置-lt-easy-gt"><a href="#35-搜索插入位置-lt-easy-gt" class="headerlink" title="35. 搜索插入位置  &lt;easy&gt;"></a>35. 搜索插入位置  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请必须使用时间复杂度为 O(log n) 的算法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums = [1,3,5,6], target = 5</span></span><br><span class="line"><span class="comment">        输出: 2</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums = [1,3,5,6], target = 2</span></span><br><span class="line"><span class="comment">        输出: 1</span></span><br><span class="line"><span class="comment">        示例 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums = [1,3,5,6], target = 7</span></span><br><span class="line"><span class="comment">        输出: 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 104</span></span><br><span class="line"><span class="comment">        -104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">        nums 为 无重复元素 的 升序 排列数组</span></span><br><span class="line"><span class="comment">        -104 &lt;= target &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInsertPosition35</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 在后半数组</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SearchInsertPosition35 solution = <span class="keyword">new</span> SearchInsertPosition35();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(solution.searchInsert(nums, <span class="number">5</span>));</span><br><span class="line">        System.out.println(solution.searchInsert(nums, <span class="number">2</span>));</span><br><span class="line">        System.out.println(solution.searchInsert(nums, <span class="number">7</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="74-搜索二维矩阵-lt-medium-gt"><a href="#74-搜索二维矩阵-lt-medium-gt" class="headerlink" title="74. 搜索二维矩阵 &lt;medium&gt;"></a>74. 搜索二维矩阵 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个满足下述两条属性的 m x n 整数矩阵：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        每行中的整数从左到右按非严格递增顺序排列。</span></span><br><span class="line"><span class="comment">        每行的第一个整数大于前一行的最后一个整数。</span></span><br><span class="line"><span class="comment">        给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == matrix.length</span></span><br><span class="line"><span class="comment">        n == matrix[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 100</span></span><br><span class="line"><span class="comment">        -104 &lt;= matrix[i][j], target &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchA2dMatrix74</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二维矩阵的第一个和最后一个元素</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = rows * cols - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将矩阵按行展开成一个有序数组，通过二分查找找到目标值</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// mid为中间值，但要换算为二维坐标，mid/cols获得在第几行，求余可得在第几列</span></span><br><span class="line">            <span class="keyword">int</span> midValue = matrix[mid / cols][mid % cols];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (midValue == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midValue &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分查找的时间复杂度为 O(log(m * n))，其中 m 为矩阵的行数，n 为矩阵的列数</span></span><br><span class="line">        <span class="comment">// 使用了常数级的额外空间，空间复杂度为 O(1)</span></span><br><span class="line">        SearchA2dMatrix74 solution = <span class="keyword">new</span> SearchA2dMatrix74();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix1 = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>&#125;,</span><br><span class="line">                &#123;<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">60</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> target1 = <span class="number">3</span>;</span><br><span class="line">        System.out.println(solution.searchMatrix(matrix1, target1)); <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix2 = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>&#125;,</span><br><span class="line">                &#123;<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">60</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> target2 = <span class="number">13</span>;</span><br><span class="line">        System.out.println(solution.searchMatrix(matrix2, target2)); <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="162-寻找峰值-lt-medium-gt"><a href="#162-寻找峰值-lt-medium-gt" class="headerlink" title="162. 寻找峰值 &lt;medium&gt;"></a>162. 寻找峰值 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*峰值元素是指其值严格大于左右相邻值的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以假设 nums[-1] = nums[n] = -∞ 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1,2,3,1]</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        解释：3 是峰值元素，你的函数应该返回其索引 2。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1,2,1,3,5,6,4]</span></span><br><span class="line"><span class="comment">        输出：1 或 5</span></span><br><span class="line"><span class="comment">        解释：你的函数可以返回索引 1，其峰值元素为 2；</span></span><br><span class="line"><span class="comment">        或者返回索引 5， 其峰值元素为 6。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 1000</span></span><br><span class="line"><span class="comment">        -231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">        对于所有有效的 i 都有 nums[i] != nums[i + 1]*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindPeakElement162</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较中间元素和右侧相邻元素大小，小于表示峰值在右侧，否则在左侧，最终left回指向一个峰值</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(log n)</span></span><br><span class="line">        FindPeakElement162 solution = <span class="keyword">new</span> FindPeakElement162();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result1 = solution.findPeakElement(nums1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Peak element index for nums1: &quot;</span> + result1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result2 = solution.findPeakElement(nums2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Peak element index for nums2: &quot;</span> + result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="33-搜索旋转排序数组-lt-medium-gt"><a href="#33-搜索旋转排序数组-lt-medium-gt" class="headerlink" title="33. 搜索旋转排序数组 &lt;medium&gt;"></a>33. 搜索旋转排序数组 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*整数数组 nums 按升序排列，数组中的值 互不相同 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [4,5,6,7,0,1,2], target = 0</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [4,5,6,7,0,1,2], target = 3</span></span><br><span class="line"><span class="comment">        输出：-1</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1], target = 0</span></span><br><span class="line"><span class="comment">        输出：-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 5000</span></span><br><span class="line"><span class="comment">        -104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment">        nums 中的每个值都 独一无二</span></span><br><span class="line"><span class="comment">        题目数据保证 nums 在预先未知的某个下标上进行了旋转</span></span><br><span class="line"><span class="comment">        -104 &lt;= target &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInRotatedSortedArray33</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 左半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SearchInRotatedSortedArray33 solution = <span class="keyword">new</span> SearchInRotatedSortedArray33();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result1 = solution.search(nums1, target1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Index of target1: &quot;</span> + result1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target2 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> result2 = solution.search(nums2, target2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Index of target2: &quot;</span> + result2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 3</span></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result3 = solution.search(nums3, target3);</span><br><span class="line">        System.out.println(<span class="string">&quot;Index of target3: &quot;</span> + result3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="34-在排序数组中查找元素的第一个和最后一个位置-lt-medium-gt"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-lt-medium-gt" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置 &lt;medium&gt;"></a>34. 在排序数组中查找元素的第一个和最后一个位置 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果数组中不存在目标值 target，返回 [-1, -1]。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [5,7,7,8,8,10], target = 8</span></span><br><span class="line"><span class="comment">        输出：[3,4]</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [5,7,7,8,8,10], target = 6</span></span><br><span class="line"><span class="comment">        输出：[-1,-1]</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [], target = 0</span></span><br><span class="line"><span class="comment">        输出：[-1,-1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">        -109 &lt;= nums[i] &lt;= 109</span></span><br><span class="line"><span class="comment">        nums 是一个非递减数组</span></span><br><span class="line"><span class="comment">        -109 &lt;= target &lt;= 109*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindFirstAndLastPositionOfElementInSortedArray34</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 使用两次二分查找，分别找到目标值的第一次出现位置和最后一次出现位置</span></span><br><span class="line">        <span class="keyword">int</span> firstOccurrence = findFirstOccurrence(nums, target);</span><br><span class="line">        <span class="keyword">int</span> lastOccurrence = findLastOccurrence(nums, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstOccurrence, lastOccurrence&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirstOccurrence</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                first = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLastOccurrence</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                last = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FindFirstAndLastPositionOfElementInSortedArray34 solution = <span class="keyword">new</span> FindFirstAndLastPositionOfElementInSortedArray34();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target1 = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result1 = solution.searchRange(nums1, target1);</span><br><span class="line">        printList(result1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target2 = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result2 = solution.searchRange(nums2, target2);</span><br><span class="line">        printList(result2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 3</span></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> target3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result3 = solution.searchRange(nums3, target3);</span><br><span class="line">        printList(result3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums4 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result4 = solution.searchRange(nums4, target4);</span><br><span class="line">        printList(result4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums5 = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target5 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result5 = solution.searchRange(nums5, target5);</span><br><span class="line">        printList(result5);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums6 = &#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target6 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result6 = solution.searchRange(nums6, target6);</span><br><span class="line">        printList(result6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : result) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="153-寻找旋转排序数组中的最小值-lt-medium-gt"><a href="#153-寻找旋转排序数组中的最小值-lt-medium-gt" class="headerlink" title="153. 寻找旋转排序数组中的最小值 &lt;medium&gt;"></a>153. 寻找旋转排序数组中的最小值 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：</span></span><br><span class="line"><span class="comment">        若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</span></span><br><span class="line"><span class="comment">        若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]</span></span><br><span class="line"><span class="comment">        注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [3,4,5,1,2]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [4,5,6,7,0,1,2]</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment">        解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [11,13,15,17]</span></span><br><span class="line"><span class="comment">        输出：11</span></span><br><span class="line"><span class="comment">        解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        n == nums.length</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 5000</span></span><br><span class="line"><span class="comment">        -5000 &lt;= nums[i] &lt;= 5000</span></span><br><span class="line"><span class="comment">        nums 中的所有整数 互不相同</span></span><br><span class="line"><span class="comment">        nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMinimumInRotatedSortedArray153</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 左边有序，区间最小值为最左边</span></span><br><span class="line">                min = Math.min(min, nums[left]);</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左边无序，最小值为区间中间的某个值</span></span><br><span class="line">                min = Math.min(min, nums[mid]);</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FindMinimumInRotatedSortedArray153 solution = <span class="keyword">new</span> FindMinimumInRotatedSortedArray153();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(solution.findMin(nums1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(solution.findMin(nums2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 3</span></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>&#125;;</span><br><span class="line">        System.out.println(solution.findMin(nums3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-寻找两个正序数组的中位数-lt-hard-gt"><a href="#4-寻找两个正序数组的中位数-lt-hard-gt" class="headerlink" title="4. 寻找两个正序数组的中位数 &lt;hard&gt;"></a>4. 寻找两个正序数组的中位数 &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        算法的时间复杂度应该为 O(log (m+n)) 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums1 = [1,3], nums2 = [2]</span></span><br><span class="line"><span class="comment">        输出：2.00000</span></span><br><span class="line"><span class="comment">        解释：合并数组 = [1,2,3] ，中位数 2</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums1 = [1,2], nums2 = [3,4]</span></span><br><span class="line"><span class="comment">        输出：2.50000</span></span><br><span class="line"><span class="comment">        解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        nums1.length == m</span></span><br><span class="line"><span class="comment">        nums2.length == n</span></span><br><span class="line"><span class="comment">        0 &lt;= m &lt;= 1000</span></span><br><span class="line"><span class="comment">        0 &lt;= n &lt;= 1000</span></span><br><span class="line"><span class="comment">        1 &lt;= m + n &lt;= 2000</span></span><br><span class="line"><span class="comment">        -106 &lt;= nums1[i], nums2[i] &lt;= 106*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianOfTwoSortedArrays4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalLength = nums1.length + nums2.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对于总长度为偶数的情况，中位数即为第 (totalLength / 2) 和第 (totalLength / 2 + 1) 小的元素的平均值。</span></span><br><span class="line">            <span class="keyword">int</span> leftMedian = findKthElement(nums1, nums2, totalLength / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> rightMedian = findKthElement(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (leftMedian + rightMedian) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对于总长度为奇数的情况，中位数即为第 (totalLength / 2 + 1) 小的元素</span></span><br><span class="line">            <span class="keyword">return</span> findKthElement(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findKthElement</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到第K位元素</span></span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果某一数组遍历完毕，那k元素一定在另一数组</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == nums1.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == nums2.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回两数组的最小值</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将k分半，分别在两数组中查找</span></span><br><span class="line">            <span class="keyword">int</span> half = k / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> newIndex1 = Math.min(index1 + half, nums1.length) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> newIndex2 = Math.min(index2 + half, nums2.length) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[newIndex1] &lt;= nums2[newIndex2]) &#123;</span><br><span class="line">                <span class="comment">// 数组1中间元素小于数组2，说明k元素一定在数组1的后半和数组2的前半，分别更新索引和最新的k值</span></span><br><span class="line">                k -= (newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 同理</span></span><br><span class="line">                k -= (newIndex2 - index2 + <span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MedianOfTwoSortedArrays4 solution = <span class="keyword">new</span> MedianOfTwoSortedArrays4();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span> result1 = solution.findMedianSortedArrays(nums1, nums2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result for test case 1: &quot;</span> + result1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums4 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span> result2 = solution.findMedianSortedArrays(nums3, nums4);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result for test case 2: &quot;</span> + result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-19-堆-Heap"><a href="#3-19-堆-Heap" class="headerlink" title="3.19 堆 Heap"></a>3.19 堆 Heap</h3><p>堆（Heap）是一种特殊的数据结构，它通常是一个完全二叉树。根据节点值之间的关系，堆分为最大堆和最小堆。</p>
<ul>
<li><strong>最大堆（Max Heap）：</strong> 在最大堆中，每个节点的值都大于或等于其子节点的值。堆顶元素是整个堆中的最大值。</li>
<li><strong>最小堆（Min Heap）：</strong> 在最小堆中，每个节点的值都小于或等于其子节点的值。堆顶元素是整个堆中的最小值。</li>
</ul>
<p>堆的操作包括插入元素、删除元素、以及获取堆顶元素。</p>
<ul>
<li>插入元素时，可以先将元素添加到堆的末尾，然后通过“上浮”（percolate up）的方式，将元素移到合适的位置，以保持堆的性质。</li>
<li>删除元素时，可以将堆顶元素与堆的最后一个元素交换，然后通过“下沉”（percolate down）的方式，将新的堆顶元素移到合适的位置。</li>
</ul>
<p>堆的应用。</p>
<ul>
<li>最大堆常常用于实现优先队列，优先队列是一种可以按照优先级取出元素的队列，而堆可以高效地实现这种数据结构。</li>
<li>最小堆用于实现一些特定场景的算法，比如 Dijkstra 算法等。</li>
</ul>
<p>在 Java 中，堆可以通过 <code>PriorityQueue</code> 类来实现。<code>PriorityQueue</code> 默认是最小堆，如果需要实现最大堆，可以通过传递一个比较器（<code>Comparator</code>）来实现。</p>
<h4 id="215-数组中的第K个最大元素-lt-medium-gt"><a href="#215-数组中的第K个最大元素-lt-medium-gt" class="headerlink" title="215. 数组中的第K个最大元素 &lt;medium&gt;"></a>215. 数组中的第K个最大元素 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: [3,2,1,5,6,4], k = 2</span></span><br><span class="line"><span class="comment">        输出: 5</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: [3,2,3,1,2,4,5,5,6], k = 4</span></span><br><span class="line"><span class="comment">        输出: 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= k &lt;= nums.length &lt;= 105</span></span><br><span class="line"><span class="comment">        -104 &lt;= nums[i] &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLargestElementInAnArray215</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用最小堆来维护前 k 个最大的元素，小值会优先移除，最终堆保留前K大的元素，堆顶为最小元素</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果堆的大小超过 k，移除堆顶元素，保持堆的大小为 k</span></span><br><span class="line">            <span class="keyword">if</span> (minHeap.size() &gt; k) &#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 堆顶元素即为第 k 个最大的元素</span></span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        KthLargestElementInAnArray215 solution = <span class="keyword">new</span> KthLargestElementInAnArray215();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 示例 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k1 = <span class="number">2</span>;</span><br><span class="line">        System.out.println(solution.findKthLargest(nums1, k1)); <span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 示例 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k2 = <span class="number">4</span>;</span><br><span class="line">        System.out.println(solution.findKthLargest(nums2, k2)); <span class="comment">// 输出: 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="502-IPO-lt-hard-gt"><a href="#502-IPO-lt-hard-gt" class="headerlink" title="502. IPO &lt;hard&gt;"></a>502. IPO &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给你 n 个项目。对于每个项目 i ，它都有一个纯利润 profits[i] ，和启动该项目需要的最小资本 capital[i] 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        最初，你的资本为 w 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得的最多资本。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        答案保证在 32 位有符号整数范围内。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        由于你的初始资本为 0，你仅可以从 0 号项目开始。</span></span><br><span class="line"><span class="comment">        在完成后，你将获得 1 的利润，你的总资本将变为 1。</span></span><br><span class="line"><span class="comment">        此时你可以选择开始 1 号或 2 号项目。</span></span><br><span class="line"><span class="comment">        由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。</span></span><br><span class="line"><span class="comment">        因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]</span></span><br><span class="line"><span class="comment">        输出：6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= k &lt;= 105</span></span><br><span class="line"><span class="comment">        0 &lt;= w &lt;= 109</span></span><br><span class="line"><span class="comment">        n == profits.length</span></span><br><span class="line"><span class="comment">        n == capital.length</span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 105</span></span><br><span class="line"><span class="comment">        0 &lt;= profits[i] &lt;= 104</span></span><br><span class="line"><span class="comment">        0 &lt;= capital[i] &lt;= 109*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ipo502</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> w, <span class="keyword">int</span>[] profits, <span class="keyword">int</span>[] capital)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = profits.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个最小堆，按照 capital 的升序排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; minCapitalHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个最大堆，按照 profits 的降序排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; maxProfitHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将项目按照 capital 分别加入最小堆和最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            minCapitalHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;capital[i], profits[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选取最多 k 个项目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">// 将所有符合资本要求的项目加入最大堆</span></span><br><span class="line">            <span class="keyword">while</span> (!minCapitalHeap.isEmpty() &amp;&amp; minCapitalHeap.peek()[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">                maxProfitHeap.offer(minCapitalHeap.poll());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果最大堆为空，说明没有项目可做，直接返回当前资本</span></span><br><span class="line">            <span class="keyword">if</span> (maxProfitHeap.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> w;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 选择利润最大的项目，更新资本</span></span><br><span class="line">            w += maxProfitHeap.poll()[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最小堆和最大堆的插入和删除操作的时间复杂度为 O(log n)，整体时间复杂度为 O(n log n)，其中 n 是项目的数量。</span></span><br><span class="line">        <span class="comment">// 使用了两个堆来存储项目，堆的大小最大为 n，因此空间复杂度为 O(n)。</span></span><br><span class="line">        Ipo502 solution = <span class="keyword">new</span> Ipo502();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例1</span></span><br><span class="line">        <span class="keyword">int</span> k1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> w1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] profits1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] capital1 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(solution.findMaximizedCapital(k1, w1, profits1, capital1)); <span class="comment">// Output: 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例2</span></span><br><span class="line">        <span class="keyword">int</span> k2 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> w2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] profits2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] capital2 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(solution.findMaximizedCapital(k2, w2, profits2, capital2)); <span class="comment">// Output: 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="373-查找和最小的-K-对数字-lt-medium-gt"><a href="#373-查找和最小的-K-对数字-lt-medium-gt" class="headerlink" title="373. 查找和最小的 K 对数字 &lt;medium&gt;"></a>373. 查找和最小的 K 对数字 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定两个以 非递减顺序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span></span><br><span class="line"><span class="comment">        输出: [1,2],[1,4],[1,6]</span></span><br><span class="line"><span class="comment">        解释: 返回序列中的前 3 对数：</span></span><br><span class="line"><span class="comment">        [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span></span><br><span class="line"><span class="comment">        示例 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2</span></span><br><span class="line"><span class="comment">        输出: [1,1],[1,1]</span></span><br><span class="line"><span class="comment">        解释: 返回序列中的前 2 对数：</span></span><br><span class="line"><span class="comment">        [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span></span><br><span class="line"><span class="comment">        示例 3:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: nums1 = [1,2], nums2 = [3], k = 3</span></span><br><span class="line"><span class="comment">        输出: [1,3],[2,3]</span></span><br><span class="line"><span class="comment">        解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums1.length, nums2.length &lt;= 105</span></span><br><span class="line"><span class="comment">        -109 &lt;= nums1[i], nums2[i] &lt;= 109</span></span><br><span class="line"><span class="comment">        nums1 和 nums2 均为 升序排列</span></span><br><span class="line"><span class="comment">        1 &lt;= k &lt;= 104</span></span><br><span class="line"><span class="comment">        k &lt;= nums1.length * nums2.length*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindKPairsWithSmallestSums373</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个最小堆，按照和的升序排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a[<span class="number">0</span>] + a[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化最小堆，将所有 nums1 和 nums2 的组合加入堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(nums1.length, k); i++) &#123;</span><br><span class="line">            minHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[i], nums2[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出最小堆中的元素，直到满足 k 个</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !minHeap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] pair = minHeap.poll();</span><br><span class="line">            <span class="keyword">int</span> i = pair[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前最小和的组合添加到结果列表</span></span><br><span class="line">            List&lt;Integer&gt; currentPair = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            currentPair.add(pair[<span class="number">0</span>]);</span><br><span class="line">            currentPair.add(pair[<span class="number">1</span>]);</span><br><span class="line">            result.add(currentPair);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 nums2 中和当前 nums1[i] 对应的下一个数加入最小堆</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; nums2.length) &#123;</span><br><span class="line">                minHeap.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pair[<span class="number">0</span>], nums2[i + <span class="number">1</span>], i + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FindKPairsWithSmallestSums373 solution = <span class="keyword">new</span> FindKPairsWithSmallestSums373();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums11 = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums21 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k1 = <span class="number">3</span>;</span><br><span class="line">        System.out.println(solution.kSmallestPairs(nums11, nums21, k1)); <span class="comment">// Output: [[1,2],[1,4],[1,6]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums12 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums22 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k2 = <span class="number">2</span>;</span><br><span class="line">        System.out.println(solution.kSmallestPairs(nums12, nums22, k2)); <span class="comment">// Output: [[1,1],[1,1]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试用例3</span></span><br><span class="line">        <span class="keyword">int</span>[] nums13 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums23 = &#123;<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k3 = <span class="number">3</span>;</span><br><span class="line">        System.out.println(solution.kSmallestPairs(nums13, nums23, k3)); <span class="comment">// Output: [[1,3],[2,3]]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="295-数据流的中位数-lt-hard-gt"><a href="#295-数据流的中位数-lt-hard-gt" class="headerlink" title="295. 数据流的中位数 &lt;hard&gt;"></a>295. 数据流的中位数 &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        例如 arr = [2,3,4] 的中位数是 3 。</span></span><br><span class="line"><span class="comment">        例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。</span></span><br><span class="line"><span class="comment">        实现 MedianFinder 类:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        MedianFinder() 初始化 MedianFinder 对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        void addNum(int num) 将数据流中的整数 num 添加到数据结构中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入</span></span><br><span class="line"><span class="comment">        [&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span></span><br><span class="line"><span class="comment">        [[], [1], [2], [], [3], []]</span></span><br><span class="line"><span class="comment">        输出</span></span><br><span class="line"><span class="comment">        [null, null, null, 1.5, null, 2.0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        解释</span></span><br><span class="line"><span class="comment">        MedianFinder medianFinder = new MedianFinder();</span></span><br><span class="line"><span class="comment">        medianFinder.addNum(1);    // arr = [1]</span></span><br><span class="line"><span class="comment">        medianFinder.addNum(2);    // arr = [1, 2]</span></span><br><span class="line"><span class="comment">        medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)</span></span><br><span class="line"><span class="comment">        medianFinder.addNum(3);    // arr[1, 2, 3]</span></span><br><span class="line"><span class="comment">        medianFinder.findMedian(); // return 2.0</span></span><br><span class="line"><span class="comment">        提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        -105 &lt;= num &lt;= 105</span></span><br><span class="line"><span class="comment">        在调用 findMedian 之前，数据结构中至少有一个元素</span></span><br><span class="line"><span class="comment">        最多 5 * 104 次调用 addNum 和 findMedian*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMedianFromDataStream295</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap; <span class="comment">// 小顶堆，存放较大的一半元素</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap; <span class="comment">// 大顶堆，存放较小的一半元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FindMedianFromDataStream295</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.isEmpty() || num &lt;= maxHeap.peek()) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素小于等于大顶堆的堆顶元素，将其加入大顶堆</span></span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整堆的大小，使得两个堆的大小之差不超过1</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() &gt; minHeap.size() + <span class="number">1</span>) &#123;</span><br><span class="line">            minHeap.offer(maxHeap.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minHeap.size() &gt; maxHeap.size()) &#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;</span><br><span class="line">            <span class="comment">// 如果两个堆的大小相等，取两个堆的堆顶元素的平均值。</span></span><br><span class="line">            <span class="keyword">return</span> (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，取大顶堆的堆顶元素。</span></span><br><span class="line">            <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(log N)</span></span><br><span class="line">        FindMedianFromDataStream295 medianFinder = <span class="keyword">new</span> FindMedianFromDataStream295();</span><br><span class="line">        medianFinder.addNum(<span class="number">1</span>);</span><br><span class="line">        medianFinder.addNum(<span class="number">2</span>);</span><br><span class="line">        System.out.println(medianFinder.findMedian()); <span class="comment">// Output: 1.5</span></span><br><span class="line">        medianFinder.addNum(<span class="number">3</span>);</span><br><span class="line">        System.out.println(medianFinder.findMedian()); <span class="comment">// Output: 2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h3 id="3-20-位运算-Bit-Manipulation"><a href="#3-20-位运算-Bit-Manipulation" class="headerlink" title="3.20 位运算 Bit Manipulation"></a>3.20 位运算 Bit Manipulation</h3><p>Java中的二进制是有符号整数类型</p>
<ul>
<li><p>二进制的表示：</p>
<ol>
<li><p><strong>二进制字面量：</strong> 在Java 7及更高版本中，可以使用前缀<code>0b</code>或<code>0B</code>表示二进制数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binaryNumber = <span class="number">0b101010</span>; <span class="comment">// 表示42</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Integer.toBinaryString方法：</strong> 可以使用<code>Integer.toBinaryString</code>方法将整数转换为二进制字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeint decimalNumber = <span class="number">42</span>;</span><br><span class="line">String binaryString = Integer.toBinaryString(decimalNumber); <span class="comment">// 得到&quot;101</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>有符号整数使用补码表示，其中最高位（最左边的位）是符号位，0表示正数，1表示负数。</p>
</li>
<li><p>Java中并没有直接支持无符号整数的原生数据类型。所有整数类型都是有符号的。</p>
</li>
<li><p>在Java中，如果要处理无符号整数，通常会使用更大的数据类型（如<code>long</code>）来容纳更大范围的正数。</p>
</li>
</ul>
<p>Java中的位运算操作符：</p>
<ul>
<li><p>按位与 <code>&amp;</code>：两个对应位都为 1 时，结果为 1；否则，结果为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;   <span class="comment">// 二进制表示为 0101</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;   <span class="comment">// 二进制表示为 0011</span></span><br><span class="line"><span class="keyword">int</span> result = a &amp; b;  <span class="comment">// 结果为 0001，即 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>按位或 <code>|</code> ：两个对应位有一个为 1 时，结果为 1；否则，结果为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;   <span class="comment">// 二进制表示为 0101</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;   <span class="comment">// 二进制表示为 0011</span></span><br><span class="line"><span class="keyword">int</span> result = a | b;  <span class="comment">// 结果为 0111，即 7</span></span><br></pre></td></tr></table></figure></li>
<li><p>按位异或 <code>^</code> ：两个对应位相异时，结果为 1；否则，结果为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;   <span class="comment">// 二进制表示为 0101</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;   <span class="comment">// 二进制表示为 0011</span></span><br><span class="line"><span class="keyword">int</span> result = a ^ b;  <span class="comment">// 结果为 0110，即 6</span></span><br></pre></td></tr></table></figure></li>
<li><p>取反 <code>~</code> ：对操作数的每一位取反，即 0 变为 1，1 变为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;   <span class="comment">// 二进制表示为 0101</span></span><br><span class="line"><span class="keyword">int</span> result = ~a;  <span class="comment">// 结果为 1010，即 -6（取反后再加1）</span></span><br></pre></td></tr></table></figure></li>
<li><p>左移 <code>&lt;&lt;</code> ：将操作数的二进制表示向左移动指定的位数，右侧空出的位用 0 填充。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;   <span class="comment">// 二进制表示为 0101</span></span><br><span class="line"><span class="keyword">int</span> result = a &lt;&lt; <span class="number">2</span>;  <span class="comment">// 结果为 010100（左移两位），即 20</span></span><br></pre></td></tr></table></figure></li>
<li><p>右移 <code>&gt;&gt;</code> ：将操作数的二进制表示向右移动指定的位数，左侧空出的位用符号位（正数为 0，负数为 1）填充。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;   <span class="comment">// 二进制表示为 0101</span></span><br><span class="line"><span class="keyword">int</span> result = a &gt;&gt; <span class="number">1</span>;  <span class="comment">// 结果为 0010（右移一位），即 2</span></span><br></pre></td></tr></table></figure></li>
<li><p>无符号右移 <code>&gt;&gt;&gt;</code> ：将操作数的二进制表示向右移动指定的位数，左侧空出的位用 0 填充。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">5</span>;  <span class="comment">// 二进制表示为 11111111111111111111111111111011</span></span><br><span class="line"><span class="keyword">int</span> result = a &gt;&gt;&gt; <span class="number">1</span>;  <span class="comment">// 结果为 01111111111111111111111111111101，即 2147483645</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="67-二进制求和-lt-easy-gt"><a href="#67-二进制求和-lt-easy-gt" class="headerlink" title="67. 二进制求和  &lt;easy&gt;"></a>67. 二进制求和  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入:a = &quot;11&quot;, b = &quot;1&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;100&quot;</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：a = &quot;1010&quot;, b = &quot;1011&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;10101&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= a.length, b.length &lt;= 104</span></span><br><span class="line"><span class="comment">        a 和 b 仅由字符 &#x27;0&#x27; 或 &#x27;1&#x27; 组成</span></span><br><span class="line"><span class="comment">        字符串如果不是 &quot;0&quot; ，就不含前导零*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddBinary67</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解法1.模拟二进制加法 O(max&#123;a, b&#125;)</span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = b.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取当前位的数字，如果超出字符串长度，用0代替</span></span><br><span class="line">            <span class="keyword">int</span> digitA = (i &gt;= <span class="number">0</span>) ? Character.getNumericValue(a.charAt(i--)) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> digitB = (j &gt;= <span class="number">0</span>) ? Character.getNumericValue(b.charAt(j--)) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算当前位的和</span></span><br><span class="line">            <span class="keyword">int</span> sum = digitA + digitB + carry;</span><br><span class="line">            <span class="comment">// 将和的最低位插入到结果字符串的最前面</span></span><br><span class="line">            result.insert(<span class="number">0</span>, sum % <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 更新进位</span></span><br><span class="line">            carry = sum / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String binaryA = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        String binaryB = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        String sum = addBinary(binaryA, binaryB);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Binary A: &quot;</span> + binaryA);</span><br><span class="line">        System.out.println(<span class="string">&quot;Binary B: &quot;</span> + binaryB);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        binaryA = <span class="string">&quot;1010&quot;</span>;</span><br><span class="line">        binaryB = <span class="string">&quot;1011&quot;</span>;</span><br><span class="line">        sum = addBinary(binaryA, binaryB);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Binary A: &quot;</span> + binaryA);</span><br><span class="line">        System.out.println(<span class="string">&quot;Binary B: &quot;</span> + binaryB);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="190-颠倒二进制位-lt-easy-gt"><a href="#190-颠倒二进制位-lt-easy-gt" class="headerlink" title="190. 颠倒二进制位  &lt;easy&gt;"></a>190. 颠倒二进制位  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*颠倒给定的 32 位无符号整数的二进制位。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</span></span><br><span class="line"><span class="comment">        在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 00000010100101000001111010011100</span></span><br><span class="line"><span class="comment">        输出：964176192 (00111001011110000010100101000000)</span></span><br><span class="line"><span class="comment">        解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span></span><br><span class="line"><span class="comment">        因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 11111111111111111111111111111101</span></span><br><span class="line"><span class="comment">        输出：3221225471 (10111111111111111111111111111111)</span></span><br><span class="line"><span class="comment">        解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span></span><br><span class="line"><span class="comment">        因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入是一个长度为 32 的二进制字符串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶: 如果多次调用这个函数，你将如何优化你的算法？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseBits190</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// M1用于将相邻的两位交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M1 = <span class="number">0x55555555</span>; <span class="comment">// 01010101010101010101010101010101</span></span><br><span class="line">    <span class="comment">// M2用于将相邻的四位交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M2 = <span class="number">0x33333333</span>; <span class="comment">// 00110011001100110011001100110011</span></span><br><span class="line">    <span class="comment">// M4用于将相邻的八位交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M4 = <span class="number">0x0f0f0f0f</span>; <span class="comment">// 00001111000011110000111100001111</span></span><br><span class="line">    <span class="comment">// M4用于将相邻的十六位交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M8 = <span class="number">0x00ff00ff</span>; <span class="comment">// 00000000111111110000000011111111</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解法1.转二进制字符串，再反转字符串，再转为整数 O(log₂n)</span></span><br><span class="line">        <span class="comment">//// 补零确保32位，不足则会填充空格，然后替换为0</span></span><br><span class="line">        <span class="comment">//String binaryString = String.format(&quot;%32s&quot;, Integer.toBinaryString(n)).replace(&#x27; &#x27;, &#x27;0&#x27;);</span></span><br><span class="line">        <span class="comment">//StringBuilder sb = new StringBuilder();</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// 反转字符串</span></span><br><span class="line">        <span class="comment">//for (int i = binaryString.length() - 1; i &gt;= 0; i--) &#123;</span></span><br><span class="line">        <span class="comment">//    sb.append(binaryString.charAt(i));</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//// 用更大的long来进行转换</span></span><br><span class="line">        <span class="comment">//return Long.valueOf(sb.toString(), 2).intValue();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解法2.逐位颠倒 O(logn)</span></span><br><span class="line">        <span class="comment">//int rev = 0;</span></span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; 32 &amp;&amp; n != 0; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//    // n &amp; 1获取n的最低位，&lt;&lt; (31 - i)将当前位放置到反转的位置，即左移31-i位，通过|=按位或加到rev中</span></span><br><span class="line">        <span class="comment">//    rev |= (n &amp; 1) &lt;&lt; (31 - i);</span></span><br><span class="line">        <span class="comment">//    // 将n逻辑右移1位，去掉已经处理过的最低位</span></span><br><span class="line">        <span class="comment">//    n &gt;&gt;&gt;= 1;</span></span><br><span class="line">        <span class="comment">//    //System.out.println(i + &quot;rev=&quot; + Integer.toBinaryString(rev));</span></span><br><span class="line">        <span class="comment">//    //System.out.println(i + &quot;n=&quot; + Integer.toBinaryString(n));</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return rev;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解法3.位运算分治 O(1)</span></span><br><span class="line">        <span class="comment">// 将相邻数字互换：将n逻辑右移1位与M1进行按位与操作，使奇数位的数字清零；n直接与M1进行按位与操作后再左移1位，使奇数位的数字移动到偶数位；通过按位或实现奇偶数字互换</span></span><br><span class="line">        n = n &gt;&gt;&gt; <span class="number">1</span> &amp; M1 | (n &amp; M1) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(n)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        <span class="comment">// 将每两位数字互换</span></span><br><span class="line">        n = n &gt;&gt;&gt; <span class="number">2</span> &amp; M2 | (n &amp; M2) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(n)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        <span class="comment">// 将每四位数字互换</span></span><br><span class="line">        n = n &gt;&gt;&gt; <span class="number">4</span> &amp; M4 | (n &amp; M4) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(n)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        <span class="comment">// 将每八位数字互换</span></span><br><span class="line">        n = n &gt;&gt;&gt; <span class="number">8</span> &amp; M8 | (n &amp; M8) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%32s&quot;</span>, Integer.toBinaryString(n)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        <span class="comment">// 将整个32位数字颠倒</span></span><br><span class="line">        <span class="keyword">return</span> n &gt;&gt;&gt; <span class="number">16</span> | n &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseBits190 solution = <span class="keyword">new</span> ReverseBits190();</span><br><span class="line">        <span class="keyword">int</span> result = solution.reverseBits(<span class="number">0b00000010100101000001111010011100</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        System.out.println(solution.reverseBits(<span class="number">0b11111111111111111111111111111101</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="191-位1的个数-lt-easy-gt"><a href="#191-位1的个数-lt-easy-gt" class="headerlink" title="191. 位1的个数  &lt;easy&gt;"></a>191. 位1的个数  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &#x27;1&#x27; 的个数（也被称为汉明重量）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</span></span><br><span class="line"><span class="comment">        在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 3 中，输入表示有符号整数 -3。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 00000000000000000000000000001011</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 00000000000000000000000010000000</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 11111111111111111111111111111101</span></span><br><span class="line"><span class="comment">        输出：31</span></span><br><span class="line"><span class="comment">        解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入必须是长度为 32 的 二进制串 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果多次调用这个函数，你将如何优化你的算法？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOf1Bits191</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解法1.转字符串</span></span><br><span class="line">        <span class="comment">//String binaryString = String.format(&quot;%32s&quot;, Integer.toBinaryString(n)).replace(&quot; &quot;, &quot;0&quot;);</span></span><br><span class="line">        <span class="comment">//int count = 0;</span></span><br><span class="line">        <span class="comment">//for (int i = 0;i &lt; binaryString.length();i++) &#123;</span></span><br><span class="line">        <span class="comment">//    char e = binaryString.charAt(i);</span></span><br><span class="line">        <span class="comment">//    if (&#x27;1&#x27; == e) &#123;</span></span><br><span class="line">        <span class="comment">//        count++;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return count;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解法2. Brian Kernighan 算法，通过n &amp;= (n - 1)消除n最左侧的1，直到n等于0； O(k)，k为1的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NumberOf1Bits191 solution = <span class="keyword">new</span> NumberOf1Bits191();</span><br><span class="line">        System.out.println(solution.hammingWeight(<span class="number">0b00000000000000000000000000001011</span>));</span><br><span class="line">        System.out.println(solution.hammingWeight(<span class="number">0b00000000000000000000000010000000</span>));</span><br><span class="line">        System.out.println(solution.hammingWeight(<span class="number">0b11111111111111111111111111111101</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="136-只出现一次的数字-lt-easy-gt"><a href="#136-只出现一次的数字-lt-easy-gt" class="headerlink" title="136. 只出现一次的数字  &lt;easy&gt;"></a>136. 只出现一次的数字  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1 ：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [2,2,1]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        示例 2 ：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [4,1,2,1,2]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        示例 3 ：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [1]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">        -3 * 104 &lt;= nums[i] &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">        除了某个元素只出现一次以外，其余每个元素均出现两次。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumber136</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 相同数异或后为0，任意数字与0异或仍为原数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            result ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleNumber136 solution = <span class="keyword">new</span> SingleNumber136();</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(solution.singleNumber(nums1));</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(solution.singleNumber(nums2));</span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(solution.singleNumber(nums3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="137-只出现一次的数字-II-lt-medium-gt"><a href="#137-只出现一次的数字-II-lt-medium-gt" class="headerlink" title="137. 只出现一次的数字 II &lt;medium&gt;"></a>137. 只出现一次的数字 II &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [2,2,3,2]</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,1,0,1,0,1,99]</span></span><br><span class="line"><span class="comment">        输出：99</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 3 * 104</span></span><br><span class="line"><span class="comment">        -231 &lt;= nums[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">        nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumberII137</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化一个32位数组count，用于记录每一位上的出现次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="comment">// 对每个数字的每一位进行统计</span></span><br><span class="line">                count[i] += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对count数组的每一位取模3，得到的结果就是只出现一次的数字在该位上的二进制表示</span></span><br><span class="line">            result |= (count[i] % <span class="number">3</span>) &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleNumberII137 solution = <span class="keyword">new</span> SingleNumberII137();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(solution.singleNumber(nums1));  <span class="comment">// Output: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        System.out.println(solution.singleNumber(nums2));  <span class="comment">// Output: 99</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="201-数字范围按位与-lt-medium-gt"><a href="#201-数字范围按位与-lt-medium-gt" class="headerlink" title="201. 数字范围按位与 &lt;medium&gt;"></a>201. 数字范围按位与 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：left = 5, right = 7</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：left = 0, right = 0</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：left = 1, right = 2147483647</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= left &lt;= right &lt;= 231 - 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitwiseAndOfNumbersRange201</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &lt;&lt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BitwiseAndOfNumbersRange201 solution = <span class="keyword">new</span> BitwiseAndOfNumbersRange201();</span><br><span class="line"></span><br><span class="line">        System.out.println(solution.rangeBitwiseAnd(<span class="number">5</span>, <span class="number">7</span>));  <span class="comment">// Output: 4</span></span><br><span class="line">        System.out.println(solution.rangeBitwiseAnd(<span class="number">0</span>, <span class="number">0</span> ));  <span class="comment">// Output: 0</span></span><br><span class="line">        System.out.println(solution.rangeBitwiseAnd(<span class="number">1</span>, <span class="number">2147483647</span>));  <span class="comment">// Output: 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-21-数学-Mathematics"><a href="#3-21-数学-Mathematics" class="headerlink" title="3.21 数学 Mathematics"></a>3.21 数学 Mathematics</h3><h4 id="9-回文数-lt-easy-gt"><a href="#9-回文数-lt-easy-gt" class="headerlink" title="9. 回文数  &lt;easy&gt;"></a>9. 回文数  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        例如，121 是回文，而 123 不是。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：x = 121</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：x = -121</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：x = 10</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        解释：从右向左读, 为 01 。因此它不是一个回文数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        -231 &lt;= x &lt;= 231 - 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：你能不将整数转为字符串来解决这个问题吗？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromeNumber9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        String string = String.valueOf(x);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = string.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> a = string.charAt(left++);</span><br><span class="line">            <span class="keyword">char</span> b = string.charAt(right--);</span><br><span class="line">            <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PalindromeNumber9 solution = <span class="keyword">new</span> PalindromeNumber9();</span><br><span class="line"></span><br><span class="line">        System.out.println(solution.isPalindrome(<span class="number">121</span>));  <span class="comment">// Output: true</span></span><br><span class="line">        System.out.println(solution.isPalindrome(-<span class="number">121</span>));  <span class="comment">// Output: false</span></span><br><span class="line">        System.out.println(solution.isPalindrome(<span class="number">10</span>));  <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="66-加一-lt-easy-gt"><a href="#66-加一-lt-easy-gt" class="headerlink" title="66. 加一  &lt;easy&gt;"></a>66. 加一  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以假设除了整数 0 之外，这个整数不会以零开头。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：digits = [1,2,3]</span></span><br><span class="line"><span class="comment">        输出：[1,2,4]</span></span><br><span class="line"><span class="comment">        解释：输入数组表示数字 123。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：digits = [4,3,2,1]</span></span><br><span class="line"><span class="comment">        输出：[4,3,2,2]</span></span><br><span class="line"><span class="comment">        解释：输入数组表示数字 4321。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：digits = [0]</span></span><br><span class="line"><span class="comment">        输出：[1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= digits.length &lt;= 100</span></span><br><span class="line"><span class="comment">        0 &lt;= digits[i] &lt;= 9*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusOne66</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = digits.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从数组的最后一位开始向前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 在当前位置加1</span></span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="comment">// 如果加1后不产生进位，直接返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (digits[i] &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果加1后产生进位，当前位置变为0，继续向前进位</span></span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最高位产生了进位，需要在数组的最前面插入一个新的最高位1</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">int</span>[] digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : digits) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PlusOne66 solution = <span class="keyword">new</span> PlusOne66();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] digits1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        printList(solution.plusOne(digits1));  <span class="comment">// Output: [1,2,4]</span></span><br><span class="line">        <span class="keyword">int</span>[] digits2 = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        printList(solution.plusOne(digits2));  <span class="comment">// Output: [4,3,2,2]</span></span><br><span class="line">        <span class="keyword">int</span>[] digits3 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        printList(solution.plusOne(digits3));  <span class="comment">// Output: [1]</span></span><br><span class="line">        <span class="keyword">int</span>[] digits4 = &#123;<span class="number">9</span>&#125;;</span><br><span class="line">        printList(solution.plusOne(digits4));  <span class="comment">// Output: [1,0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="172-阶乘后的零-lt-medium-gt"><a href="#172-阶乘后的零-lt-medium-gt" class="headerlink" title="172. 阶乘后的零 &lt;medium&gt;"></a>172. 阶乘后的零 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个整数 n ，返回 n! 结果中尾随零的数量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 3</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment">        解释：3! = 6 ，不含尾随 0</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 5</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        解释：5! = 120 ，有一个尾随 0</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 0</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= n &lt;= 104</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialTrailingZeroes172</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计n!中因子5的个数，即末尾零的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个因子5都会贡献一个零，所以只需统计5的倍数的个数</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(logn)</span></span><br><span class="line">        FactorialTrailingZeroes172 solution = <span class="keyword">new</span> FactorialTrailingZeroes172();</span><br><span class="line"></span><br><span class="line">        System.out.println(solution.trailingZeroes(<span class="number">3</span>));  <span class="comment">// Output: 0</span></span><br><span class="line">        System.out.println(solution.trailingZeroes(<span class="number">5</span>));  <span class="comment">// Output: 1</span></span><br><span class="line">        System.out.println(solution.trailingZeroes(<span class="number">0</span>));  <span class="comment">// Output: 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="69-x-的平方根-lt-easy-gt"><a href="#69-x-的平方根-lt-easy-gt" class="headerlink" title="69. x 的平方根  &lt;easy&gt;"></a>69. x 的平方根  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：x = 4</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：x = 8</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= x &lt;= 231 - 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqrtX69</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用二分查找法求解</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义一个范围在[1, x]之间的左右指针。</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 在每一步中，通过计算中间值mid，将问题缩小为[left, mid-1]或[mid+1, right]。</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 对于每个mid值，都计算mid的平方sqrt，然后与x进行比较。</span></span><br><span class="line">            <span class="keyword">int</span> sqrt = x / mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mid == sqrt) &#123;</span><br><span class="line">                <span class="comment">// 如果mid的平方等于x，直接返回mid。</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; sqrt) &#123;</span><br><span class="line">                <span class="comment">// 如果mid的平方小于x，说明平方根应该在[mid+1, right]之间，将left指针更新为mid+1。</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果mid的平方大于x，说明平方根应该在[left, mid-1]之间，将right指针更新为mid-1。</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(logn)</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SqrtX69 solution = <span class="keyword">new</span> SqrtX69();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span> result1 = solution.mySqrt(<span class="number">4</span>);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span> result2 = solution.mySqrt(<span class="number">8</span>);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="50-Pow-x-n-lt-medium-gt"><a href="#50-Pow-x-n-lt-medium-gt" class="headerlink" title="50. Pow(x, n) &lt;medium&gt;"></a>50. Pow(x, n) &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：x = 2.00000, n = 10</span></span><br><span class="line"><span class="comment">        输出：1024.00000</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：x = 2.10000, n = 3</span></span><br><span class="line"><span class="comment">        输出：9.26100</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：x = 2.00000, n = -2</span></span><br><span class="line"><span class="comment">        输出：0.25000</span></span><br><span class="line"><span class="comment">        解释：2 = 1/2 = 1/4 = 0.25</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        -100.0 &lt; x &lt; 100.0</span></span><br><span class="line"><span class="comment">        -231 &lt;= n &lt;= 231-1</span></span><br><span class="line"><span class="comment">        n 是一个整数</span></span><br><span class="line"><span class="comment">        要么 x 不为零，要么 n &gt; 0 。</span></span><br><span class="line"><span class="comment">        -104 &lt;= xn &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowxN50</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 超出时间限制</span></span><br><span class="line">        <span class="comment">//if (n == 0) &#123;</span></span><br><span class="line">        <span class="comment">//    return 1;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//if (n &lt; 0) &#123;</span></span><br><span class="line">        <span class="comment">//    x = 1 / x;</span></span><br><span class="line">        <span class="comment">//    n = -n;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//double base = x;</span></span><br><span class="line">        <span class="comment">//while (n &gt; 1) &#123;</span></span><br><span class="line">        <span class="comment">//    x *= base;</span></span><br><span class="line">        <span class="comment">//    n--;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return x;</span></span><br><span class="line">        <span class="comment">// 2.分治解法</span></span><br><span class="line">        <span class="comment">// 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 n 转为 long 类型，避免负整数越界问题</span></span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 n 为负数，转换为正数，并取倒数</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(logn)</span></span><br><span class="line">        <span class="keyword">return</span> fastPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分治，降低问题规模</span></span><br><span class="line">        <span class="keyword">double</span> half = fastPow(x, n / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据奇偶性，分情况计算结果</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PowxN50 solution = <span class="keyword">new</span> PowxN50();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">double</span> result1 = solution.myPow(<span class="number">2.00000</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: 1024.00000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">double</span> result2 = solution.myPow(<span class="number">2.10000</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: 9.26100</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        <span class="keyword">double</span> result3 = solution.myPow(<span class="number">2.00000</span>, -<span class="number">2</span>);</span><br><span class="line">        System.out.println(result3);  <span class="comment">// Output: 0.25000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="149-直线上最多的点数-lt-hard-gt"><a href="#149-直线上最多的点数-lt-hard-gt" class="headerlink" title="149. 直线上最多的点数 &lt;hard&gt;"></a>149. 直线上最多的点数 &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：points = [[1,1],[2,2],[3,3]]</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= points.length &lt;= 300</span></span><br><span class="line"><span class="comment">        points[i].length == 2</span></span><br><span class="line"><span class="comment">        -104 &lt;= xi, yi &lt;= 104</span></span><br><span class="line"><span class="comment">        points 中的所有点 互不相同*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPointsOnALine149</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过枚举每一对点，计算它们的斜率，并使用哈希表进行统计，找出具有最多点数的斜率</span></span><br><span class="line">        <span class="comment">// 特殊情况处理</span></span><br><span class="line">        <span class="keyword">if</span> (points.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> points.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxPoints = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个点 points[i]，以其为起点，计算与其他点之间的斜率。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; slopeCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> duplicatePoints = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> localMax = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> deltaX = points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> deltaY = points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (deltaX == <span class="number">0</span> &amp;&amp; deltaY == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 处理相同点的情况</span></span><br><span class="line">                    duplicatePoints++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 计算最简斜率，用字符串表示以避免浮点误差</span></span><br><span class="line">                    <span class="keyword">int</span> gcd = gcd(deltaX, deltaY);</span><br><span class="line">                    String slope = (deltaX / gcd) + <span class="string">&quot;/&quot;</span> + (deltaY / gcd);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 更新斜率统计</span></span><br><span class="line">                    slopeCount.put(slope, slopeCount.getOrDefault(slope, <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 更新本轮局部最大值</span></span><br><span class="line">                    localMax = Math.max(localMax, slopeCount.get(slope));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新全局最大值</span></span><br><span class="line">            maxPoints = Math.max(maxPoints, localMax + duplicatePoints);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxPoints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  O(N^2)</span></span><br><span class="line">        MaxPointsOnALine149 solution = <span class="keyword">new</span> MaxPointsOnALine149();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span>[][] points1 = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> result1 = solution.maxPoints(points1);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span>[][] points2 = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">5</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> result2 = solution.maxPoints(points2);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-22-一维动态规划-One-dimensional-Dynamic-Programming"><a href="#3-22-一维动态规划-One-dimensional-Dynamic-Programming" class="headerlink" title="3.22 一维动态规划 One-dimensional Dynamic Programming"></a>3.22 一维动态规划 One-dimensional Dynamic Programming</h3><p>动态规划（Dynamic Programming，简称 DP）是一种解决问题的优化方法，它通常用于处理具有重叠子问题和最优子结构性质的问题。动态规划主要通过将原问题分解成子问题，先解决子问题，然后保存子问题的解，最后利用这些子问题的解构建原问题的解。</p>
<p>动态规划的基本思路包含以下步骤：</p>
<ol>
<li><strong>定义状态：</strong> 明确问题的状态，找到问题的子结构。状态通常是原问题中变化的量，同时要保证问题的最优解能够通过子问题的最优解得到。</li>
<li><strong>设计状态转移方程：</strong> 根据问题的子结构，定义状态之间的关系。状态转移方程描述了问题的最优子结构，通过递推关系求解问题。</li>
<li><strong>初始化：</strong> 初始化问题的边界状态，通常是最简单的情况，从而能够递推得到更复杂的状态。</li>
<li><strong>计算最终解：</strong> 根据状态转移方程和初始状态，计算得到原问题的解。</li>
<li><strong>优化空间：</strong> 由于动态规划算法通常会使用数组来存储状态，可以考虑优化空间复杂度，例如使用滚动数组等方法。</li>
</ol>
<p>动态规划广泛应用于求解最优化问题，如最短路径、最长公共子序列、背包问题等。</p>
<p>斐波那契数列：是一个经典的动态规划问题，其中每个数等于前两个数的和。数列的前几项为：0, 1, 1, 2, 3, 5, 8, 13, 21, …</p>
<ul>
<li>状态定义：设 <code>dp[i]</code> 表示第 <code>i</code> 个斐波那契数。</li>
<li>状态转移方程：<code>dp[i] = dp[i-1] + dp[i-2]</code></li>
<li>初始化：<code>dp[0] = 0, dp[1] = 1</code></li>
<li>计算最终解：遍历 <code>i</code>，计算 <code>dp[i]</code> 直到达到目标。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fibonacci of &quot;</span> + n + <span class="string">&quot;: &quot;</span> + fib(n)); <span class="comment">// Output: 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="70-爬楼梯-lt-easy-gt"><a href="#70-爬楼梯-lt-easy-gt" class="headerlink" title="70. 爬楼梯  &lt;easy&gt;"></a>70. 爬楼梯  &lt;easy&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 2</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        解释：有两种方法可以爬到楼顶。</span></span><br><span class="line"><span class="comment">        1. 1 阶 + 1 阶</span></span><br><span class="line"><span class="comment">        2. 2 阶</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：n = 3</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        解释：有三种方法可以爬到楼顶。</span></span><br><span class="line"><span class="comment">        1. 1 阶 + 1 阶 + 1 阶</span></span><br><span class="line"><span class="comment">        2. 1 阶 + 2 阶</span></span><br><span class="line"><span class="comment">        3. 2 阶 + 1 阶</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= n &lt;= 45*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs70</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用dp表示爬到第i阶楼梯的方法总数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 爬到第i阶楼梯的方法数等于爬到第i-1阶楼梯的方法数加上爬到第i-2阶楼梯的方法数</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        ClimbingStairs70 solution = <span class="keyword">new</span> ClimbingStairs70();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span> result1 = solution.climbStairs(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span> result2 = solution.climbStairs(<span class="number">3</span>);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="198-打家劫舍-lt-medium-gt"><a href="#198-打家劫舍-lt-medium-gt" class="headerlink" title="198. 打家劫舍 &lt;medium&gt;"></a>198. 打家劫舍 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：[1,2,3,1]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span></span><br><span class="line"><span class="comment">        偷窃到的最高金额 = 1 + 3 = 4 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：[2,7,9,3,1]</span></span><br><span class="line"><span class="comment">        输出：12</span></span><br><span class="line"><span class="comment">        解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span></span><br><span class="line"><span class="comment">        偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 100</span></span><br><span class="line"><span class="comment">        0 &lt;= nums[i] &lt;= 400*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobber198</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 第i号房屋的最大金额等于第i-1房屋的金额与第i加上第i-2个房屋的金额中的最大值</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]+ nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        HouseRobber198 solution = <span class="keyword">new</span> HouseRobber198();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result1 = solution.rob(nums);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result2 = solution.rob(nums1);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: 12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="139-单词拆分-lt-medium-gt"><a href="#139-单词拆分-lt-medium-gt" class="headerlink" title="139. 单词拆分 &lt;medium&gt;"></a>139. 单词拆分 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span></span><br><span class="line"><span class="comment">        输出: true</span></span><br><span class="line"><span class="comment">        解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span></span><br><span class="line"><span class="comment">        输出: true</span></span><br><span class="line"><span class="comment">        解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span></span><br><span class="line"><span class="comment">        注意，你可以重复使用字典中的单词。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span></span><br><span class="line"><span class="comment">        输出: false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 300</span></span><br><span class="line"><span class="comment">        1 &lt;= wordDict.length &lt;= 1000</span></span><br><span class="line"><span class="comment">        1 &lt;= wordDict[i].length &lt;= 20</span></span><br><span class="line"><span class="comment">        s 和 wordDict[i] 仅由小写英文字母组成</span></span><br><span class="line"><span class="comment">        wordDict 中的所有字符串 互不相同*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordBreak139</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || wordDict == <span class="keyword">null</span> || wordDict.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// dp[i] 表示字符串 s 的前 i 个字符是否可以拆分成 wordDict 中的单词</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">// 空字符串可以被拆分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串每个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历字典表</span></span><br><span class="line">            <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = word.length();</span><br><span class="line">                <span class="comment">// 当前字符数大于等于单词长度，且与单词相等，并且单词前的第i-len个字符可以匹配</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= len &amp;&amp; dp[i - len] &amp;&amp; s.substring(i - len, i).equals(word)) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WordBreak139 solution = <span class="keyword">new</span> WordBreak139();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        String s1 = <span class="string">&quot;leetcode&quot;</span>;</span><br><span class="line">        List&lt;String&gt; wordDict1 = Arrays.asList(<span class="string">&quot;leet&quot;</span>, <span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> result1 = solution.wordBreak(s1, wordDict1);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        String s2 = <span class="string">&quot;applepenapple&quot;</span>;</span><br><span class="line">        List&lt;String&gt; wordDict2 = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pen&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> result2 = solution.wordBreak(s2, wordDict2);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        String s3 = <span class="string">&quot;catsandog&quot;</span>;</span><br><span class="line">        List&lt;String&gt; wordDict3 = Arrays.asList(<span class="string">&quot;cats&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;sand&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> result3 = solution.wordBreak(s3, wordDict3);</span><br><span class="line">        System.out.println(result3);  <span class="comment">// Output: false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="322-零钱兑换-lt-medium-gt"><a href="#322-零钱兑换-lt-medium-gt" class="headerlink" title="322. 零钱兑换 &lt;medium&gt;"></a>322. 零钱兑换 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以认为每种硬币的数量是无限的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：coins = [1, 2, 5], amount = 11</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        解释：11 = 5 + 5 + 1</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：coins = [2], amount = 3</span></span><br><span class="line"><span class="comment">        输出：-1</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：coins = [1], amount = 0</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= coins.length &lt;= 12</span></span><br><span class="line"><span class="comment">        1 &lt;= coins[i] &lt;= 231 - 1</span></span><br><span class="line"><span class="comment">        0 &lt;= amount &lt;= 104*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinChange322</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 无法凑成负数金额</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i]表示凑成金额i所需的最少硬币个数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历硬币集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// 从coin遍历到amount，若i-coin不是初始状态，则更新其最小硬币数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i - coin] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CoinChange322 solution = <span class="keyword">new</span> CoinChange322();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] coins1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount1 = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">int</span> result1 = solution.coinChange(coins1, amount1);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] coins2 = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount2 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> result2 = solution.coinChange(coins2, amount2);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: -1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        <span class="keyword">int</span>[] coins3 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> amount3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result3 = solution.coinChange(coins3, amount3);</span><br><span class="line">        System.out.println(result3);  <span class="comment">// Output: 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="300-最长递增子序列-lt-medium-gt"><a href="#300-最长递增子序列-lt-medium-gt" class="headerlink" title="300. 最长递增子序列 &lt;medium&gt;"></a>300. 最长递增子序列 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [10,9,2,5,3,7,101,18]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [0,1,0,3,2,3]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：nums = [7,7,7,7,7,7,7]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= nums.length &lt;= 2500</span></span><br><span class="line"><span class="comment">        -104 &lt;= nums[i] &lt;= 104</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你能将算法的时间复杂度降低到 O(n log(n)) 吗?*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestIncreasingSubsequence300</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// dp[i]表示以nums[i]结尾的最长递增子序列的长度</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始时，将dp数组填充为1，表示每个元素本身构成一个递增子序列</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历i之前所有元素，只要小于nums[i]，就更新最大长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongestIncreasingSubsequence300 solution = <span class="keyword">new</span> LongestIncreasingSubsequence300();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">101</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result1 = solution.lengthOfLIS(nums1);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result2 = solution.lengthOfLIS(nums2);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        <span class="keyword">int</span>[] nums3 = &#123;<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result3 = solution.lengthOfLIS(nums3);</span><br><span class="line">        System.out.println(result3);  <span class="comment">// Output: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-23-多维动态规划-Multi-dimensional-Dynamic-Programming"><a href="#3-23-多维动态规划-Multi-dimensional-Dynamic-Programming" class="headerlink" title="3.23 多维动态规划 Multi-dimensional Dynamic Programming"></a>3.23 多维动态规划 Multi-dimensional Dynamic Programming</h3><h4 id="120-三角形最小路径和-lt-medium-gt"><a href="#120-三角形最小路径和-lt-medium-gt" class="headerlink" title="120. 三角形最小路径和 &lt;medium&gt;"></a>120. 三角形最小路径和 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个三角形 triangle ，找出自顶向下的最小路径和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</span></span><br><span class="line"><span class="comment">        输出：11</span></span><br><span class="line"><span class="comment">        解释：如下面简图所示：</span></span><br><span class="line"><span class="comment">        2</span></span><br><span class="line"><span class="comment">        3 4</span></span><br><span class="line"><span class="comment">        6 5 7</span></span><br><span class="line"><span class="comment">        4 1 8 3</span></span><br><span class="line"><span class="comment">        自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：triangle = [[-10]]</span></span><br><span class="line"><span class="comment">        输出：-10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= triangle.length &lt;= 200</span></span><br><span class="line"><span class="comment">        triangle[0].length == 1</span></span><br><span class="line"><span class="comment">        triangle[i].length == triangle[i - 1].length + 1</span></span><br><span class="line"><span class="comment">        -104 &lt;= triangle[i][j] &lt;= 104</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle120</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用一维数组 dp 存储每一层的最小路径和</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 dp 数组为最后一层的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = triangle.get(n - <span class="number">1</span>).get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从倒数第二层开始更新 dp 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">// 更新 dp 数组为当前位置的值加上下一层的最小路径和</span></span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Triangle120 solution = <span class="keyword">new</span> Triangle120();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; triangle1 = Arrays.asList(</span><br><span class="line">                Arrays.asList(<span class="number">2</span>),</span><br><span class="line">                Arrays.asList(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">                Arrays.asList(<span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>),</span><br><span class="line">                Arrays.asList(<span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span> result1 = solution.minimumTotal(triangle1);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: 11</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; triangle2 = Arrays.asList(</span><br><span class="line">                Arrays.asList(-<span class="number">10</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span> result2 = solution.minimumTotal(triangle2);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: -10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="64-最小路径和-lt-medium-gt"><a href="#64-最小路径和-lt-medium-gt" class="headerlink" title="64. 最小路径和 &lt;medium&gt;"></a>64. 最小路径和 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        说明：每次只能向下或者向右移动一步。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span></span><br><span class="line"><span class="comment">        输出：7</span></span><br><span class="line"><span class="comment">        解释：因为路径 1→3→1→1→1 的总和最小。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：grid = [[1,2,3],[4,5,6]]</span></span><br><span class="line"><span class="comment">        输出：12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == grid.length</span></span><br><span class="line"><span class="comment">        n == grid[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 200</span></span><br><span class="line"><span class="comment">        0 &lt;= grid[i][j] &lt;= 200*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumPathSum64</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 dp 数组，dp[i][j] 表示从左上角到达坐标 (i, j) 的最小路径和</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划递推公式：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MinimumPathSum64 solution = <span class="keyword">new</span> MinimumPathSum64();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span>[][] grid1 = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> result1 = solution.minPathSum(grid1);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: 7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span>[][] grid2 = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> result2 = solution.minPathSum(grid2);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: 12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="63-不同路径-II-lt-medium-gt"><a href="#63-不同路径-II-lt-medium-gt" class="headerlink" title="63. 不同路径 II &lt;medium&gt;"></a>63. 不同路径 II &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        网格中的障碍物和空位置分别用 1 和 0 来表示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        解释：3x3 网格的正中间有一个障碍物。</span></span><br><span class="line"><span class="comment">        从左上角到右下角一共有 2 条不同的路径：</span></span><br><span class="line"><span class="comment">        1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span></span><br><span class="line"><span class="comment">        2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：obstacleGrid = [[0,1],[0,0]]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == obstacleGrid.length</span></span><br><span class="line"><span class="comment">        n == obstacleGrid[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 100</span></span><br><span class="line"><span class="comment">        obstacleGrid[i][j] 为 0 或 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePathsII63</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个二维数组dp，dp[i][j]表示从起点到达坐标(i, j)的不同路径数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1]，如果 obstacleGrid[i][j] == 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UniquePathsII63 solution = <span class="keyword">new</span> UniquePathsII63();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span>[][] obstacleGrid1 = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> result1 = solution.uniquePathsWithObstacles(obstacleGrid1);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span>[][] obstacleGrid2 = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> result2 = solution.uniquePathsWithObstacles(obstacleGrid2);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-最长回文子串-lt-medium-gt"><a href="#5-最长回文子串-lt-medium-gt" class="headerlink" title="5. 最长回文子串 &lt;medium&gt;"></a>5. 最长回文子串 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个字符串 s，找到 s 中最长的回文子串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;babad&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;bab&quot;</span></span><br><span class="line"><span class="comment">        解释：&quot;aba&quot; 同样是符合题意的答案。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s = &quot;cbbd&quot;</span></span><br><span class="line"><span class="comment">        输出：&quot;bb&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= s.length &lt;= 1000</span></span><br><span class="line"><span class="comment">        s 仅由数字和英文字母组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestPalindromicSubstring5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解法1动态规划 O(n^2)</span></span><br><span class="line">        <span class="comment">//if (s == null || s.length() == 0) &#123;</span></span><br><span class="line">        <span class="comment">//    return &quot;&quot;;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//int n = s.length();</span></span><br><span class="line">        <span class="comment">////  dp[i][j] 表示字符串从第 i 个字符到第 j 个字符是否构成回文子串</span></span><br><span class="line">        <span class="comment">//boolean[][] dp = new boolean[n][n];</span></span><br><span class="line">        <span class="comment">//int start = 0;</span></span><br><span class="line">        <span class="comment">//int end = 0;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//for (int len = 1; len &lt;= n; len++) &#123;</span></span><br><span class="line">        <span class="comment">//    for (int i = 0; i &lt;= n - len; i++) &#123;</span></span><br><span class="line">        <span class="comment">//        int j = i + len - 1;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//        // 判断首尾两个字符是否相等，且剩余部分是回文</span></span><br><span class="line">        <span class="comment">//        if (len == 1 || (s.charAt(i) == s.charAt(j) &amp;&amp; (len == 2 || dp[i + 1][j - 1]))) &#123;</span></span><br><span class="line">        <span class="comment">//            dp[i][j] = true;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//            if (len &gt; end - start + 1) &#123;</span></span><br><span class="line">        <span class="comment">//                start = i;</span></span><br><span class="line">        <span class="comment">//                end = j;</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//return s.substring(start, end + 1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解法2中心扩展法 O(n^2)</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于每个字符，分别以该字符为中心，或者以该字符与其右侧字符之间为中心，进行扩展，找到最长的回文子串。在扩展的过程中，通过比较左右两侧的字符是否相等，来确定是否构成回文。通过不断更新最长回文子串的起始位置和结束位置，最终得到最长回文子串。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LongestPalindromicSubstring5 solution = <span class="keyword">new</span> LongestPalindromicSubstring5();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        String s1 = <span class="string">&quot;babad&quot;</span>;</span><br><span class="line">        String result1 = solution.longestPalindrome(s1);</span><br><span class="line">        System.out.println(result1);  <span class="comment">// Output: &quot;bab&quot; or &quot;aba&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        String s2 = <span class="string">&quot;cbbd&quot;</span>;</span><br><span class="line">        String result2 = solution.longestPalindrome(s2);</span><br><span class="line">        System.out.println(result2);  <span class="comment">// Output: &quot;bb&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="97-交错字符串-lt-medium-gt"><a href="#97-交错字符串-lt-medium-gt" class="headerlink" title="97. 交错字符串 &lt;medium&gt;"></a>97. 交错字符串 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        s = s1 + s2 + ... + sn</span></span><br><span class="line"><span class="comment">        t = t1 + t2 + ... + tm</span></span><br><span class="line"><span class="comment">        |n - m| &lt;= 1</span></span><br><span class="line"><span class="comment">        交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...</span></span><br><span class="line"><span class="comment">        注意：a + b 意味着字符串 a 和 b 连接。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span></span><br><span class="line"><span class="comment">        输出：false</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;</span></span><br><span class="line"><span class="comment">        输出：true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= s1.length, s2.length &lt;= 100</span></span><br><span class="line"><span class="comment">        0 &lt;= s3.length &lt;= 200</span></span><br><span class="line"><span class="comment">        s1、s2、和 s3 都由小写英文字母组成</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        进阶：您能否仅使用 O(s2.length) 额外的内存空间来解决它?*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterleavingString97</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(m * n)</span></span><br><span class="line">        <span class="keyword">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s1 的前 i 个字符和 s2 的前 j 个字符是否可以交错形成 s3 的前 i + j 个字符</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 空字符串和空字符串交错为一个空字符串</span></span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 对于第一行，只要当前字符和 s3 对应位置的字符相等，就可以继续扩展</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 对于第一列，只要当前字符和 s3 对应位置的字符相等，就可以继续扩展</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果 s1.charAt(i - 1) == s3.charAt(i + j - 1)，则 dp[i][j] = dp[i - 1][j]；</span></span><br><span class="line">                    <span class="comment">// 如果 s2.charAt(j - 1) == s3.charAt(i + j - 1)，则 dp[i][j] = dp[i][j - 1]。</span></span><br><span class="line">                    dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>))</span><br><span class="line">                            || (dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(i + j - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InterleavingString97 solution = <span class="keyword">new</span> InterleavingString97();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        String s1 = <span class="string">&quot;aabcc&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;dbbca&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;aadbbcbcac&quot;</span>;</span><br><span class="line">        System.out.println(solution.isInterleave(s1, s2, s3));  <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        String s4 = <span class="string">&quot;aabcc&quot;</span>;</span><br><span class="line">        String s5 = <span class="string">&quot;dbbca&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;aadbbbaccc&quot;</span>;</span><br><span class="line">        System.out.println(solution.isInterleave(s4, s5, s6));  <span class="comment">// Output: false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        String s7 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String s8 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String s9 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(solution.isInterleave(s7, s8, s9));  <span class="comment">// Output: true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="72-编辑距离-lt-medium-gt"><a href="#72-编辑距离-lt-medium-gt" class="headerlink" title="72. 编辑距离 &lt;medium&gt;"></a>72. 编辑距离 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        你可以对一个单词进行如下三种操作：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        插入一个字符</span></span><br><span class="line"><span class="comment">        删除一个字符</span></span><br><span class="line"><span class="comment">        替换一个字符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span></span><br><span class="line"><span class="comment">        输出：3</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span></span><br><span class="line"><span class="comment">        rorse -&gt; rose (删除 &#x27;r&#x27;)</span></span><br><span class="line"><span class="comment">        rose -&gt; ros (删除 &#x27;e&#x27;)</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span></span><br><span class="line"><span class="comment">        输出：5</span></span><br><span class="line"><span class="comment">        解释：</span></span><br><span class="line"><span class="comment">        intention -&gt; inention (删除 &#x27;t&#x27;)</span></span><br><span class="line"><span class="comment">        inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span></span><br><span class="line"><span class="comment">        enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span></span><br><span class="line"><span class="comment">        exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span></span><br><span class="line"><span class="comment">        exection -&gt; execution (插入 &#x27;u&#x27;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0 &lt;= word1.length, word2.length &lt;= 500</span></span><br><span class="line"><span class="comment">        word1 和 word2 由小写英文字母组成*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditDistance72</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">// 从0转0=0开始，word2每多一个字符，结果+1</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="comment">// 从0转0=0开始，word1每多一个字符，结果+1</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 字符相等，则不需转换，直接等于前面一位的结果</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 字符不相等，则取word1少一个元素，word2少一个元素，二者都少一个元素的最小结果+1</span></span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EditDistance72 solution = <span class="keyword">new</span> EditDistance72();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        String word1_1 = <span class="string">&quot;horse&quot;</span>;</span><br><span class="line">        String word2_1 = <span class="string">&quot;ros&quot;</span>;</span><br><span class="line">        System.out.println(solution.minDistance(word1_1, word2_1));  <span class="comment">// Output: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        String word1_2 = <span class="string">&quot;intention&quot;</span>;</span><br><span class="line">        String word2_2 = <span class="string">&quot;execution&quot;</span>;</span><br><span class="line">        System.out.println(solution.minDistance(word1_2, word2_2));  <span class="comment">// Output: 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="123-买卖股票的最佳时机-III-lt-hard-gt"><a href="#123-买卖股票的最佳时机-III-lt-hard-gt" class="headerlink" title="123. 买卖股票的最佳时机 III &lt;hard&gt;"></a>123. 买卖股票的最佳时机 III &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：prices = [3,3,5,0,0,3,1,4]</span></span><br><span class="line"><span class="comment">        输出：6</span></span><br><span class="line"><span class="comment">        解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span></span><br><span class="line"><span class="comment">        随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：prices = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span></span><br><span class="line"><span class="comment">        注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span></span><br><span class="line"><span class="comment">        因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：prices = [7,6,4,3,1]</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment">        解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span></span><br><span class="line"><span class="comment">        示例 4：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：prices = [1]</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= prices.length &lt;= 105</span></span><br><span class="line"><span class="comment">        0 &lt;= prices[i] &lt;= 105*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStockIII123</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp数组：dp[j][k]表示在第i天结束时，最多进行j次交易，持有状态为k（0表示不持有，1表示持有）时的最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一天，未进行交易，持有状态为0的情况</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一天，未进行交易，持有状态为1的情况，即购买了股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一天，进行了一次交易，持有状态为0的情况，因为是第一天，不可能卖出</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一天，进行了一次交易，持有状态为1的情况，即购买了股票</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一天，进行了两次交易，持有状态为0的情况，因为是第一天，不可能卖出</span></span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一天，进行了两次交易，持有状态为1的情况，即购买了股票</span></span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 第i天未进行交易，持有状态为0的情况</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天未进行交易，持有状态为1的情况，可能是前一天持有，或者前一天卖出了</span></span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天进行了一次交易，持有状态为0的情况，可能是前一天进行了一次交易，或者前一天持有，然后卖出了</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天进行了一次交易，持有状态为1的情况，可能是前一天进行了两次交易，或者前一天进行了一次交易，然后买入了</span></span><br><span class="line">            dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>][<span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天进行了两次交易，持有状态为0的情况，可能是前一天进行了两次交易，或者前一天进行了一次交易，然后卖出了</span></span><br><span class="line">            dp[<span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[<span class="number">2</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第i天进行了两次交易，持有状态为1的情况，可能是前一天进行了两次交易，或者前一天进行了两次交易，然后买入了</span></span><br><span class="line">            dp[<span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[<span class="number">2</span>][<span class="number">1</span>], dp[<span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果在最后一天，未进行交易，持有状态为0的情况中</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">0</span>]), dp[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BestTimeToBuyAndSellStockIII123 solution = <span class="keyword">new</span> BestTimeToBuyAndSellStockIII123();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span>[] prices1 = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxProfit(prices1));  <span class="comment">// Output: 6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span>[] prices2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxProfit(prices2));  <span class="comment">// Output: 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        <span class="keyword">int</span>[] prices3 = &#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxProfit(prices3));  <span class="comment">// Output: 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 4</span></span><br><span class="line">        <span class="keyword">int</span>[] prices4 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxProfit(prices4));  <span class="comment">// Output: 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="188-买卖股票的最佳时机-IV-lt-hard-gt"><a href="#188-买卖股票的最佳时机-IV-lt-hard-gt" class="headerlink" title="188. 买卖股票的最佳时机 IV &lt;hard&gt;"></a>188. 买卖股票的最佳时机 IV &lt;hard&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：k = 2, prices = [2,4,1]</span></span><br><span class="line"><span class="comment">        输出：2</span></span><br><span class="line"><span class="comment">        解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：k = 2, prices = [3,2,6,5,0,3]</span></span><br><span class="line"><span class="comment">        输出：7</span></span><br><span class="line"><span class="comment">        解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span></span><br><span class="line"><span class="comment">        随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 &lt;= k &lt;= 100</span></span><br><span class="line"><span class="comment">        1 &lt;= prices.length &lt;= 1000</span></span><br><span class="line"><span class="comment">        0 &lt;= prices[i] &lt;= 1000*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStockIv188</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果交易次数 k 大于等于数组长度的一半，说明可以尽情地进行交易</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    maxProfit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxProfit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp数组：dp[i][j]表示在第i天结束时，最多进行j次交易时的最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一天，未进行交易，持有状态为0的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一天，未进行交易，持有状态为1的情况，即购买了股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                <span class="comment">// 第i天未进行交易，持有状态为0的情况</span></span><br><span class="line">                dp[j][<span class="number">0</span>] = Math.max(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第i天未进行交易，持有状态为1的情况，可能是前一天持有，或者前一天卖出了</span></span><br><span class="line">                dp[j][<span class="number">1</span>] = Math.max(dp[j][<span class="number">1</span>], dp[j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果在最后一天，未进行交易，持有状态为0的情况中</span></span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BestTimeToBuyAndSellStockIv188 solution = <span class="keyword">new</span> BestTimeToBuyAndSellStockIv188();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">int</span> k1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] prices1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxProfit(k1, prices1));  <span class="comment">// Output: 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">int</span> k2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] prices2 = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(solution.maxProfit(k2, prices2));  <span class="comment">// Output: 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="221-最大正方形-lt-medium-gt"><a href="#221-最大正方形-lt-medium-gt" class="headerlink" title="221. 最大正方形 &lt;medium&gt;"></a>221. 最大正方形 &lt;medium&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在一个由 &#x27;0&#x27; 和 &#x27;1&#x27; 组成的二维矩阵内，找到只包含 &#x27;1&#x27; 的最大正方形，并返回其面积。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span></span><br><span class="line"><span class="comment">        输出：4</span></span><br><span class="line"><span class="comment">        示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]</span></span><br><span class="line"><span class="comment">        输出：1</span></span><br><span class="line"><span class="comment">        示例 3：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        输入：matrix = [[&quot;0&quot;]]</span></span><br><span class="line"><span class="comment">        输出：0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        提示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        m == matrix.length</span></span><br><span class="line"><span class="comment">        n == matrix[i].length</span></span><br><span class="line"><span class="comment">        1 &lt;= m, n &lt;= 300</span></span><br><span class="line"><span class="comment">        matrix[i][j] 为 &#x27;0&#x27; 或 &#x27;1&#x27;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximalSquare221</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp数组：dp[i][j]表示以matrix[i][j]为右下角的正方形的最大边长</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            maxSide = Math.max(maxSide, dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            maxSide = Math.max(maxSide, dp[<span class="number">0</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递推计算dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 状态转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</span></span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MaximalSquare221 solution = <span class="keyword">new</span> MaximalSquare221();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 1</span></span><br><span class="line">        <span class="keyword">char</span>[][] matrix1 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(solution.maximalSquare(matrix1));  <span class="comment">// Output: 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 2</span></span><br><span class="line">        <span class="keyword">char</span>[][] matrix2 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(solution.maximalSquare(matrix2));  <span class="comment">// Output: 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test Case 3</span></span><br><span class="line">        <span class="keyword">char</span>[][] matrix3 = &#123;</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(solution.maximalSquare(matrix3));  <span class="comment">// Output: 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>-————————————–</p>
<p>参考：</p>
<p>🔗<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/138951555">后端面试的所有知识点</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019102501.html" title="面试整理——算法">http://linyishui.top/2019102501.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019102401.html" rel="prev" title="面试整理——JVM">
                  <i class="fa fa-chevron-left"></i> 面试整理——JVM
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019102601.html" rel="next" title="面试整理——网络">
                  面试整理——网络 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
