<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的Java虚拟机相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——JVM">
<meta property="og:url" content="http://linyishui.top/2019102401.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的Java虚拟机相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-10-24T08:06:28.000Z">
<meta property="article:modified_time" content="2020-08-29T14:45:04.000Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://linyishui.top/2019102401.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019102401.html","path":"2019102401.html","title":"面试整理——JVM"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——JVM | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E7%BB%BC%E5%90%88"><span class="nav-text">第一节 综合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ajre%E3%80%81jdk%E3%80%81jvm%E7%9A%84%E5%85%B3%E7%B3%BB-%EF%BC%9F"><span class="nav-text">问：jre、jdk、jvm的关系 ？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-text">第二节 内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BJVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="nav-text">问：简单介绍一下JVM内存区域？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%EF%BC%9F%E8%AE%B2%E8%A7%A3%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="nav-text">问：堆空间分哪些部分？讲解新生代和老年代？以及如何设置各个部分？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AEden%E5%8C%BA%E5%92%8CSurvivor%E5%8C%BA%E7%9A%84%E6%AF%94%E4%BE%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%99%E4%B8%AA%E6%AF%94%E4%BE%8B%EF%BC%8C%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B-%EF%BC%9F"><span class="nav-text">问：Eden区和Survivor区的比例，为什么是这个比例，工作过程 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%E5%B8%A7%EF%BC%9F%E6%A0%88%E5%B8%A7%E5%AD%98%E5%82%A8%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：什么是栈帧？栈帧存储了什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AF%B9%E8%B1%A14%E7%A7%8D%E5%BC%95%E7%94%A8-%EF%BC%9FJava-%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-text">问：对象4种引用 ？Java 中都有哪些引用类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E6%88%90-%EF%BC%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%EF%BC%8C%E6%B6%89%E5%8F%8A%E5%88%B0%E9%94%81%E7%9A%84%E9%83%A8%E5%88%86-%EF%BC%9F"><span class="nav-text">问：对象的构成 ？对象的内存布局，涉及到锁的部分 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB-%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E8%A2%AB%E8%A7%86%E4%B8%BAGC-Roots%EF%BC%9F"><span class="nav-text">问：如果判断一个对象是否存活 ？哪些对象可被视为GC Roots？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A-JVM%E5%8F%82%E6%95%B0%E4%B8%BB%E8%A6%81%E6%9C%89%E5%87%A0%E7%A7%8D%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="nav-text">问： JVM参数主要有几种分类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E4%B8%AD%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97%EF%BC%8C%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="nav-text">问：Java中会存在内存泄漏吗，简述一下？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E4%B8%A4%E4%B8%AAJava%E7%B1%BB%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%9F"><span class="nav-text">问：Java虚拟机是如何判定两个Java类是相同的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ajava%E6%98%AF%E6%A0%B9%E6%8D%AE%E4%BB%80%E4%B9%88%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%9A%84-%EF%BC%9F"><span class="nav-text">问：java是根据什么来执行可达性分析的 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">问：堆外内存的优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9F%E8%BF%99%E4%BA%9B%E5%8C%BA%E5%9F%9F%E9%83%BD%E5%88%86%E5%88%AB%E6%98%AF%E5%B9%B2%E5%95%A5%E7%94%A8%E7%9A%84%EF%BC%9Fjava%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8Cjvm%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%B3%A8%E6%84%8F%E5%8C%BA%E5%88%86-%EF%BC%9F"><span class="nav-text">问：说一下JVM的线程模型？这些区域都分别是干啥用的？java线程模型和jvm线程模型注意区分 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9B%B8%E5%85%B3-%EF%BC%9F"><span class="nav-text">问：字符串常量池相关 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ajdk-8-%E5%8E%BB%E6%8E%89%E6%96%B9%E6%B3%95%E5%8C%BA%E7%94%A8-%E5%85%83%E6%95%B0%E6%8D%AE-%E4%BB%A3%E6%9B%BF%EF%BC%8C%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88-%EF%BC%9F"><span class="nav-text">问：jdk 8 去掉方法区用 元数据 代替，是为什么 ？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">第三节 垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AGC-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-GC%EF%BC%9F"><span class="nav-text">问：GC 是什么？为什么要有 GC？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AF%BC%E8%87%B4fullGC%E7%9A%84%E5%8E%9F%E5%9B%A0-%EF%BC%9F"><span class="nav-text">问：导致fullGC的原因 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-text">问：对象什么时候可以被垃圾回收？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E7%94%9F%E6%88%90GC%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="nav-text">问：如何设置参数生成GC日志？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJVM%E4%B8%83%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-%EF%BC%9F"><span class="nav-text">问：JVM七种垃圾收集器 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-%EF%BC%9F"><span class="nav-text">问：使用场景 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Acms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B-%EF%BC%9F"><span class="nav-text">问：cms垃圾回收过程 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AGC-Roots%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D-%EF%BC%9F"><span class="nav-text">问：GC Roots有以下几种 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AG1-%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88-%EF%BC%9F"><span class="nav-text">问：G1 处理方案 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AG1%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A8%A1%E5%BC%8F-%EF%BC%9F"><span class="nav-text">问：G1中提供了三种模式垃圾回收模式 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Aarthas-%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7-%EF%BC%9F"><span class="nav-text">问：arthas 监控工具 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AE%9A%E4%BD%8D%E9%A2%91%E7%B9%81full-GC%EF%BC%8C%E5%A0%86%E5%86%85%E5%AD%98%E6%BB%A1-oom-%EF%BC%9F"><span class="nav-text">问：定位频繁full GC，堆内存满 oom ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-%EF%BC%9F"><span class="nav-text">问：G1垃圾回收器（重点） ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9FFull-GC%E5%91%A2-%EF%BC%9F"><span class="nav-text">问：什么时候发生Full GC呢 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%9C%A8%E5%BC%95%E7%94%A8%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%9B%B4%E6%8E%A5%E6%9B%B4%E6%96%B0RS%E5%91%A2-%EF%BC%9F"><span class="nav-text">问：那为什么不在引用赋值语句处直接更新RS呢 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E9%85%8D%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88TLAB%EF%BC%9A-Thread-Local-Allocation-Buffer%EF%BC%89-%EF%BC%9F"><span class="nav-text">问：线程本地分配缓冲区（TLAB： Thread Local Allocation Buffer） ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9APLAB%EF%BC%9A-Promotion-Thread-Local-Allocation-Buffer-%EF%BC%9F"><span class="nav-text">问：PLAB： Promotion Thread Local Allocation Buffer ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AOOM%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95-%EF%BC%9F"><span class="nav-text">问：OOM问题定位方法 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%97%A2%E7%84%B6jvm%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-text">问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F%E8%AF%B4%E8%AF%B4GC%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">问：简单介绍一下GC垃圾回收算法？说说GC的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="nav-text">问：常见的垃圾回收器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava-GC%E6%9C%BA%E5%88%B6%EF%BC%9FGC-Roots%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">问：Java GC机制？GC Roots有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%BC%BA%E5%88%B6young-gc%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：强制young gc会有什么问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%9F%A5%E9%81%93G1%E4%B9%88%EF%BC%9F%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">问：知道G1么？回收过程是怎么样的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AFull-GC-%E5%8F%91%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E3%80%81%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%A0%86%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%81%E6%80%8E%E4%B9%88%E5%87%8F%E5%B0%91-Full-GC-%E3%80%81JVM-%E8%B0%83%E4%BC%98%EF%BC%9F"><span class="nav-text">问：Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AGC-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%EF%BC%8CCMS-%E4%BB%A5%E5%8F%8A-G1-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%EF%BC%8CCMS-%E7%9A%84%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%93%AA%E4%B8%A4%E4%B8%AA%E6%98%AF-Stop-the-world-%E7%9A%84%EF%BC%8CCMS-%E4%BC%9A%E4%B8%8D%E4%BC%9A%E4%BA%A7%E7%94%9F%E7%A2%8E%E7%89%87%EF%BC%8CG1-%E7%9A%84%E4%BC%98%E5%8A%BF-%EF%BC%9F"><span class="nav-text">问：GC 常见算法，CMS 以及 G1 的垃圾回收过程，CMS 的各个阶段哪两个是 Stop the world 的，CMS 会不会产生碎片，G1 的优势 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9-%EF%BC%9F"><span class="nav-text">问：标记清除、复制和标记整理算法的理解以及优缺点 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJVM-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E8%AF%A5%E8%A2%AB-GC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%A7%86%E4%B8%BA-root-%E7%9A%84%E9%83%BD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B-%EF%BC%9F"><span class="nav-text">问：JVM 如何判断一个对象是否该被 GC，可以视为 root 的都有哪几种类型 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A-GC-%E5%AF%B9%E4%BB%96%E4%BB%AC%E6%89%A7%E8%A1%8C%E6%80%8E%E6%A0%B7%E7%9A%84%E6%93%8D%E4%BD%9C-%EF%BC%9F"><span class="nav-text">问：强软弱虚引用的区别以及 GC 对他们执行怎样的操作 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5-GC-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-%EF%BC%9F"><span class="nav-text">问：Java 是否可以 GC 直接内存 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AGC-%E4%BC%98%E5%8C%96%E7%9A%84%E6%AD%A5%E9%AA%A4-%EF%BC%9F"><span class="nav-text">问：GC 优化的步骤 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%9C%89%E8%BF%87GC%E8%B0%83%E4%BC%98%E7%9A%84%E7%BB%8F%E5%8E%86%E4%B9%88%EF%BC%9F"><span class="nav-text">问：有过GC调优的经历么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ACMS-%E5%92%8C-G1-%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B-%EF%BC%9F"><span class="nav-text">问：CMS 和 G1 收集过程 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ajava-new-%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F-GC-%EF%BC%9F"><span class="nav-text">问：java new 一个对象的时候，什么情况下会发生 GC ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E6%B2%A1%E6%9C%89%E6%BB%A1%E5%91%A2-%EF%BC%9F"><span class="nav-text">问：如果新生代和老年代没有满呢 ？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-text">第四节 类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F-%EF%BC%9F"><span class="nav-text">问：JVM 类加载顺序 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJVM%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%EF%BC%9F"><span class="nav-text">问：JVM三种类加载器 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6-%EF%BC%9F"><span class="nav-text">问：双亲委派机制 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%95%A5%E4%BD%9C%E7%94%A8-%EF%BC%9F"><span class="nav-text">问：双亲委派模型有啥作用 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B-%EF%BC%9F"><span class="nav-text">问：如何打破双亲委派模型 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Atomcat%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B-%EF%BC%9F"><span class="nav-text">问：tomcat是如何打破双亲委派模型 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASPI%EF%BC%9A-%EF%BC%88Service-Provider-interface%EF%BC%89-%EF%BC%9F"><span class="nav-text">问：SPI： （Service Provider interface） ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASPI%E5%BA%94%E7%94%A8-%EF%BC%9F"><span class="nav-text">问：SPI应用 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%BC%BA%E9%99%B7-%EF%BC%9F"><span class="nav-text">问：双亲委派机制缺陷 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">问：说下类加载的过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F"><span class="nav-text">问：什么时候需要自定义类加载器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AClass-forName-%E6%98%AF%E5%90%A6%E4%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%EF%BC%9F"><span class="nav-text">问：Class.forName 是否会初始化类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Astatic-%E5%9D%97%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%87%A0%E6%AC%A1%EF%BC%9F%E6%80%8E%E4%B9%88%E8%AE%A9%E5%AE%83%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%EF%BC%9F"><span class="nav-text">问：static 块会执行几次？怎么让它执行第二次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%EF%BC%9F"><span class="nav-text">问：类加载的过程，以及双亲委派机制、自定义类加载器 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-text">问：Java为什么要设计双亲委派模型？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-%E8%B0%83%E4%BC%98"><span class="nav-text">第五节 调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D%EF%BC%9F"><span class="nav-text">问：Java内存泄漏问题如何进行定位？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AStackOverflow%E5%BC%82%E5%B8%B8%E6%9C%89%E6%B2%A1%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%EF%BC%9F%E4%B8%80%E8%88%AC%E4%BD%A0%E7%8C%9C%E6%B5%8B%E4%BC%9A%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%A2%AB%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="nav-text">问：StackOverflow异常有没有遇到过？一般你猜测会在什么情况下被触发？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84-JVM-%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0-%EF%BC%9F"><span class="nav-text">问：常用的 JVM 调优参数 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%BD%93%E5%87%BA%E7%8E%B0%E4%BA%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%88%96%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%92%E9%94%99-%EF%BC%9F"><span class="nav-text">问：当出现了内存泄漏或内存溢出，怎么排错 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E8%B0%88%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E8%BF%87%E5%93%AA%E4%BA%9B%EF%BC%9FJVM%E3%80%81MySQL%E3%80%81%E4%BB%A3%E7%A0%81%E7%AD%89%E9%83%BD%E8%B0%88%E8%B0%88%EF%BC%9F%E8%87%AA%E5%B7%B1%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E8%B0%83%E4%BC%98%EF%BC%9FJVM%E8%B0%83%E4%BC%98%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%E9%83%BD%E8%A1%8C"><span class="nav-text">问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">313</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019102401.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——JVM
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-24 16:06:28" itemprop="dateCreated datePublished" datetime="2019-10-24T16:06:28+08:00">2019-10-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-08-29 22:45:04" itemprop="dateModified" datetime="2020-08-29T22:45:04+08:00">2020-08-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的Java虚拟机相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><strong>JVM</strong></h1><h2 id="第一节-综合"><a href="#第一节-综合" class="headerlink" title="第一节 综合"></a><strong>第一节 综合</strong></h2><h4 id="问：jre、jdk、jvm的关系-？"><a href="#问：jre、jdk、jvm的关系-？" class="headerlink" title="问：jre、jdk、jvm的关系 ？"></a><strong>问：jre、jdk、jvm的关系 ？</strong></h4><ul>
<li>jdk是最小的开发环境，由jre + java工具组成。</li>
<li>jre是java运行的最小环境，由jvm + 核心类库组成。</li>
<li>jvm是虚拟机，是java字节码运行的容器，如果只有jvm是无法运行java的，因为缺少了核心类库。</li>
</ul>
<h2 id="第二节-内存区域"><a href="#第二节-内存区域" class="headerlink" title="第二节 内存区域"></a><strong>第二节 内存区域</strong></h2><h4 id="问：简单介绍一下JVM内存区域？"><a href="#问：简单介绍一下JVM内存区域？" class="headerlink" title="问：简单介绍一下JVM内存区域？"></a><strong>问：简单介绍一下JVM内存区域？</strong></h4><ol>
<li>堆{对象，静态变量，共享}</li>
<li>方法区{ 存放类信息，常量池，共享}（java8移除了永久代（PermGen），替换为元空间（Metaspace））</li>
<li>虚拟机栈{线程执行方法的时候内部存局部变量会存堆中对象的地址等等数据}</li>
<li>本地方法栈{存放各种native方法的局部变量表之类的信息}</li>
<li>程序计数器{记录当前线程执行到哪一条字节码指令位置}</li>
</ol>
<h4 id="问：堆空间分哪些部分？讲解新生代和老年代？以及如何设置各个部分？"><a href="#问：堆空间分哪些部分？讲解新生代和老年代？以及如何设置各个部分？" class="headerlink" title="问：堆空间分哪些部分？讲解新生代和老年代？以及如何设置各个部分？"></a><strong>问：堆空间分哪些部分？讲解新生代和老年代？以及如何设置各个部分？</strong></h4><p>堆空间包括：采用分代收集算法</p>
<ul>
<li>新生代：对象一般会先放置在新生代，经历一次Minor GC后进入Survivor区增加一岁，超过年龄阈值就移到老年代。<ul>
<li>Eden区：新对象的出生地。</li>
<li>From Survivor区</li>
<li>To Survivor区：Minor GC时将另外两区存活的对象复制到此区，同时年龄+1，清空另外两区对象后，将To区和From区互换。</li>
</ul>
</li>
<li>老年代：大对象直接进入老年代，长期存活对象陆续进入老年代。</li>
<li>运行时常量池：1.7以后迁移到堆中</li>
</ul>
<p>配置参数：</p>
<ul>
<li><code>-Xms</code> ：初始堆大小。</li>
<li><code>-Xmx</code> ：最大堆大小。</li>
</ul>
<h4 id="问：Eden区和Survivor区的比例，为什么是这个比例，工作过程-？"><a href="#问：Eden区和Survivor区的比例，为什么是这个比例，工作过程-？" class="headerlink" title="问：Eden区和Survivor区的比例，为什么是这个比例，工作过程 ？"></a><strong>问：Eden区和Survivor区的比例，为什么是这个比例，工作过程 ？</strong></h4><p>一个Eden区和一个Survivor区的比例是 8 : 1，即新生代可用空间是总空间的9 / 10。据说有95%的对象都存活期较短，所以Eden区应远大于Survivor区，具体比例应该取决于工程验证和数据统计的结果。</p>
<p>工作过程：初始对象一般诞生于Eden区，除非对象比较大如字符串或数组。当Eden区域不够时会发生Minor GC，根据垃圾回收算法回收部分对象，将当前存活对象（Eden区和From Survivor区剩余对象）转移到To Survivor区，年龄+1，并将To区和From区互换。如果Survivor区剩余空间不足，还要向老年代做分配担保，并转移到老年代。</p>
<h4 id="问：什么是栈帧？栈帧存储了什么？"><a href="#问：什么是栈帧？栈帧存储了什么？" class="headerlink" title="问：什么是栈帧？栈帧存储了什么？"></a><strong>问：什么是栈帧？栈帧存储了什么？</strong></h4><p>虚拟机栈中的栈帧是方法执行的内存模型，每个方法执行时会创建一个栈帧，栈帧会存放局部变量表、操作数栈、动态链接、方法出口等。</p>
<h4 id="问：对象4种引用-？Java-中都有哪些引用类型？"><a href="#问：对象4种引用-？Java-中都有哪些引用类型？" class="headerlink" title="问：对象4种引用 ？Java 中都有哪些引用类型？"></a><strong>问：对象4种引用 ？Java 中都有哪些引用类型？</strong></h4><ol>
<li>强引用（内存泄露主因）：不会被回收。</li>
<li>软引用（只有软引用的话，空间不足将被回收）：内存即将溢出时会被回收，适合缓存用。</li>
<li>弱引用（只，GC会回收）：下一次GC时就会被回收。</li>
<li>虚引用（用于跟踪GC状态）用于管理堆外内存：不影响回收，但会在回收时通知系统。</li>
</ol>
<h4 id="问：对象的构成-？对象的内存布局，涉及到锁的部分-？"><a href="#问：对象的构成-？对象的内存布局，涉及到锁的部分-？" class="headerlink" title="问：对象的构成 ？对象的内存布局，涉及到锁的部分 ？"></a><strong>问：对象的构成 ？对象的内存布局，涉及到锁的部分 ？</strong></h4><p>一个对象分为3个区域：对象头、实例数据、对齐填充</p>
<ol>
<li>对象头：主要是包括两部分：<ul>
<li>运行时数据（Mark Word）：存储自身的运行时数据比如hash码，分代年龄，锁标记等（但是不是绝对，锁状态如果是偏向锁，轻量级锁，是没有hash码的）</li>
<li>指向类的元数据指针。</li>
<li>还有可能存在第三部分，那就是数组类型，会多一块记录数组的长度（因为数组的长度是jvm判断不出来的，jvm只有元数据信息）</li>
</ul>
</li>
<li>实例数据：会根据虚拟机分配策略来定，分配策略中，会把相同大小的类型放在一起，并按照定义顺序排列。</li>
<li>对齐填充：这个意义不是很大，主要在虚拟机规范中对象必须是8字节的整数，所以当对象不满足这个情况时，就会用占位符填充。</li>
</ol>
<h4 id="问：如果判断一个对象是否存活-？哪些对象可被视为GC-Roots？"><a href="#问：如果判断一个对象是否存活-？哪些对象可被视为GC-Roots？" class="headerlink" title="问：如果判断一个对象是否存活 ？哪些对象可被视为GC Roots？"></a><strong>问：如果判断一个对象是否存活 ？哪些对象可被视为GC Roots？</strong></h4><p>一般判断对象是否存活有两种算法，一种是引用计数，另外一种是可达性分析。</p>
<ul>
<li>引用计数算法：通过计数器统计被引用次数，但难以处理循环依赖问题。</li>
<li>可达性分析：判断GC Roots作为根节点，是否存在可到达对象的引用链。</li>
</ul>
<p>可被视为GC Roots：</p>
<ul>
<li>虚拟机栈中引用的对象。</li>
<li>方法区中静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNC引用的对象。</li>
</ul>
<h4 id="问：-JVM参数主要有几种分类？"><a href="#问：-JVM参数主要有几种分类？" class="headerlink" title="问： JVM参数主要有几种分类？"></a><strong>问： JVM参数主要有几种分类？</strong></h4><p>包括：</p>
<ul>
<li>标准参数：-开头</li>
<li>非标准参数：-X开头</li>
<li>不稳定参数：-XX开头</li>
</ul>
<h4 id="问：Java中会存在内存泄漏吗，简述一下？"><a href="#问：Java中会存在内存泄漏吗，简述一下？" class="headerlink" title="问：Java中会存在内存泄漏吗，简述一下？"></a><strong>问：Java中会存在内存泄漏吗，简述一下？</strong></h4><p>会存在，首先内存泄漏即不再会被使用的对象等一直占据内存空间。</p>
<p>JVM通过垃圾回收机制来自动清除不再有用的内存，但仍有多种情况会导致内存泄漏。</p>
<p>长生命周期对象强引用短生命周期对象。</p>
<h4 id="问：Java虚拟机是如何判定两个Java类是相同的？"><a href="#问：Java虚拟机是如何判定两个Java类是相同的？" class="headerlink" title="问：Java虚拟机是如何判定两个Java类是相同的？"></a><strong>问：Java虚拟机是如何判定两个Java类是相同的？</strong></h4><ol>
<li>类的全限定名相等。</li>
<li>类加载器相等（不同的类加载器加载相同字节代码也是两个不同的类实例）。</li>
</ol>
<h4 id="问：java是根据什么来执行可达性分析的-？"><a href="#问：java是根据什么来执行可达性分析的-？" class="headerlink" title="问：java是根据什么来执行可达性分析的 ？"></a><strong>问：java是根据什么来执行可达性分析的 ？</strong></h4><p>根据GC ROOTS，GC ROOTS可以的对象有：</p>
<ul>
<li>虚拟机栈中的引用对象</li>
<li>方法区的类变量的引用</li>
<li>方法区中的常量引用</li>
<li>本地方法栈中的对象引用</li>
</ul>
<h4 id="问：堆外内存的优缺点？"><a href="#问：堆外内存的优缺点？" class="headerlink" title="问：堆外内存的优缺点？"></a><strong>问：堆外内存的优缺点？</strong></h4><p>Ehcache中的一些版本，各种 NIO 框架，Dubbo，Memcache 等中会用到，NIO包下ByteBuffer来创建堆外内存，其实就是不受JVM控制的内存。</p>
<p>NIO直接通过Native函数库分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>
<p>优点：</p>
<ul>
<li>减少了垃圾回收的工作，因为垃圾回收会暂停其他的工作。 </li>
<li>加快了复制的速度。因为堆内在 flush 到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了复制这项工作。 可以扩展至更大的内存空间。比如超过 1TB 甚至比主存还大的空间。</li>
</ul>
<p>缺点：</p>
<ul>
<li>难以控制，内存泄漏很难排查；</li>
<li>很难存储较复杂对象。</li>
</ul>
<p>堆外内存难以控制，如果内存泄漏，那么很难排查，通过-XX：MaxDirectMemerySize来指定，当达到阈值的时候，调用system.gc来进行一次full gc 堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合 jstat查看内存回收概况，实时查看各个分区的分配回收情况， jmap查看内存栈，查看内存中对象占用大小， jstack查看线程栈，死锁，性能瓶颈</p>
<h4 id="问：说一下JVM的线程模型？这些区域都分别是干啥用的？java线程模型和jvm线程模型注意区分-？"><a href="#问：说一下JVM的线程模型？这些区域都分别是干啥用的？java线程模型和jvm线程模型注意区分-？" class="headerlink" title="问：说一下JVM的线程模型？这些区域都分别是干啥用的？java线程模型和jvm线程模型注意区分 ？"></a><strong>问：说一下JVM的线程模型？这些区域都分别是干啥用的？java线程模型和jvm线程模型注意区分 ？</strong></h4><p>Java使用的是一对一线程模型，所以它的一个线程对应于一个内核线程，调度完全交给操作系统来处理</p>
<p>JVM内部的主要线程分为：</p>
<ul>
<li>NamedThread：支持命名的非Java线程<ul>
<li>VMThread：VM原始线程，用于执行VM操作</li>
<li>ConcurrentGCThread：并发GC线程</li>
<li>WorkerThread：工作线程<ul>
<li>GangWorker：一组线程，类似线程池</li>
<li>GCTaskThread：GC任务线程</li>
</ul>
</li>
</ul>
</li>
<li>JavaThread：C++层面的Java线程实现<ul>
<li>各种子类，如：编译器线程，服务线程</li>
</ul>
</li>
<li>WatcherThread：监视器线程，用于模拟计时器中断</li>
</ul>
<p>在JVM内部产生一个线程的方法有两种：</p>
<ul>
<li>调用 <code>java.lang.Thread</code> 的 <code>start()</code> 方法。</li>
<li>通过 <code>JNI</code> attach到一个已经存在的本地线程。</li>
</ul>
<p> <code>java.lang.Thread</code> 启动时会分别创建一个相关联的JavaThread和OSThread对象，最终创建本地线程。</p>
<p>TODO</p>
<h4 id="问：字符串常量池相关-？"><a href="#问：字符串常量池相关-？" class="headerlink" title="问：字符串常量池相关 ？"></a><strong>问：字符串常量池相关 ？</strong></h4><h4 id="问：jdk-8-去掉方法区用-元数据-代替，是为什么-？"><a href="#问：jdk-8-去掉方法区用-元数据-代替，是为什么-？" class="headerlink" title="问：jdk 8 去掉方法区用 元数据 代替，是为什么 ？"></a><strong>问：jdk 8 去掉方法区用 元数据 代替，是为什么 ？</strong></h4><hr>
<h2 id="第三节-垃圾回收"><a href="#第三节-垃圾回收" class="headerlink" title="第三节 垃圾回收"></a><strong>第三节 垃圾回收</strong></h2><h4 id="问：GC-是什么？为什么要有-GC？"><a href="#问：GC-是什么？为什么要有-GC？" class="headerlink" title="问：GC 是什么？为什么要有 GC？"></a><strong>问：GC 是什么？为什么要有 GC？</strong></h4><h4 id="问：导致fullGC的原因-？"><a href="#问：导致fullGC的原因-？" class="headerlink" title="问：导致fullGC的原因 ？"></a><strong>问：导致fullGC的原因 ？</strong></h4><p>（1）：老年代空间不足</p>
<p>（2）：永久代（方法区）空间不足</p>
<p>（3）：显式调用system.gc（）</p>
<h4 id="问：对象什么时候可以被垃圾回收？"><a href="#问：对象什么时候可以被垃圾回收？" class="headerlink" title="问：对象什么时候可以被垃圾回收？"></a><strong>问：对象什么时候可以被垃圾回收？</strong></h4><h4 id="问：如何设置参数生成GC日志？"><a href="#问：如何设置参数生成GC日志？" class="headerlink" title="问：如何设置参数生成GC日志？"></a><strong>问：如何设置参数生成GC日志？</strong></h4><h4 id="问：JVM七种垃圾收集器-？"><a href="#问：JVM七种垃圾收集器-？" class="headerlink" title="问：JVM七种垃圾收集器 ？"></a><strong>问：JVM七种垃圾收集器 ？</strong></h4><p>（1）： Serial 收集器 复制算法，单线程，新生代）</p>
<p>（2）： ParNew 收集器（复制算法，多线程，新生代）</p>
<p>（3）： Parallel Scavenge 收集器（多线程，复制算法，新生代，高吞吐量）</p>
<p>（4）：Serial Old 收集器（标记-整理算法，老年代）</p>
<p>（5）：Parallel Old 收集器（标记-整理算法，老年代，注重吞吐量的场景下，jdk8默认采用 Parallel Scavenge + Parallel Old 的组合）</p>
<p>（6）：CMS 收集器（标记-清除算法，老年代，垃圾回收线程几乎能做到与用户线程同时工作，吞吐量低，内存碎片）以牺牲吞吐量为代价来获得最短回收停顿时间-XX：+UseConcMarkSweepGC jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代） jdk1.9 默认垃圾收集器G1</p>
<h4 id="问：使用场景-？"><a href="#问：使用场景-？" class="headerlink" title="问：使用场景 ？"></a><strong>问：使用场景 ？</strong></h4><p>（1）：应用程序对停顿比较敏感</p>
<p>（2）：在JVM中，有相对较多存活时间较长的对象（老年代比较大）会更适合使用CMS</p>
<h4 id="问：cms垃圾回收过程-？"><a href="#问：cms垃圾回收过程-？" class="headerlink" title="问：cms垃圾回收过程 ？"></a><strong>问：cms垃圾回收过程 ？</strong></h4><!--（1）：初始标识<找到gcroot（stw）>-->




<h4 id="问：GC-Roots有以下几种-？"><a href="#问：GC-Roots有以下几种-？" class="headerlink" title="问：GC Roots有以下几种 ？"></a><strong>问：GC Roots有以下几种 ？</strong></h4><p>1：系统类加载器加载的对象</p>
<p>2：处于激活状态的线程</p>
<p>3：JNI栈中的对象</p>
<p>4：正在被用于同步的各种锁对象</p>
<p>5：JVM自身持有的对象，比如系统类加载器等。</p>
<p>（2）：并发标记（三色标记算法） 三色标记算法处理并发标记出现对象引用变化情况： 黑：自己+子对象标记完成 灰：自己完成，子对象未完成 白：未标记； 并发标记 黑-&gt;灰-&gt;白 重新标记 灰-&gt;白引用消失，黑引用指向-&gt;白，导致白漏标 cms处理办法是incremental update方案 （增量更新）把黑色变成灰色 多线程下并发标记依旧会产生漏标问题，所以cms必须remark一遍（jdk1.9以后不用cms了）</p>
<h4 id="问：G1-处理方案-？"><a href="#问：G1-处理方案-？" class="headerlink" title="问：G1 处理方案 ？"></a><strong>问：G1 处理方案 ？</strong></h4><p>SATB（snapshot at the begining）把白放入栈中，标记过程是和应用程序并发运行的（不需要Stop-The-World） 这种方式会造成某些是垃圾的对象也被当做是存活的，所以G1会使得占用的内存被实际需要的内存大。不过下一次就回收了 ZGC 处理方案： 颜色指针（color pointers） 2*42方=4T</p>
<p>（3）：重新标记（stw）</p>
<p>（4）并发清理</p>
<p>备注：重新标记是防止标记成垃圾之后，对象被引用</p>
<p>（5）：G1 收集器（新生代 + 老年代，在多 CPU 和大内存的场景下有很好的性能） G1在java9 便是默认的垃圾收集器，是cms 的替代者 逻辑分代，用分区（region）的思想（默认分2048份） 还是有stw 为解决CMS算法产生空间碎片HotSpot提供垃圾收集器，通过-XX：+UseG1GC来启用</p>
<h4 id="问：G1中提供了三种模式垃圾回收模式-？"><a href="#问：G1中提供了三种模式垃圾回收模式-？" class="headerlink" title="问：G1中提供了三种模式垃圾回收模式 ？"></a><strong>问：G1中提供了三种模式垃圾回收模式 ？</strong></h4><p>（1）：young gc（eden region被耗尽无法申请内存时，就会触发）</p>
<p>（2）：mixed gc（当老年代大小占整个堆大小百分比达到该阈值时，会触发）</p>
<p>（3）：full gc（对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发）</p>
<p>（8）：ZGC和shenandoah （oracle产收费） no stw</p>
<h4 id="问：arthas-监控工具-？"><a href="#问：arthas-监控工具-？" class="headerlink" title="问：arthas 监控工具 ？"></a><strong>问：arthas 监控工具 ？</strong></h4><p>（1）：dashboard命令查看总体jvm运行情况</p>
<p>（2）：jvm显示jvm详细信息</p>
<p>（3）：thread 显示jvm里面所有线程信息（类似于jstack） 查看死锁线程命令thread -b</p>
<p>（4）：sc * 显示所有类（search class）</p>
<p>（5）：trace 跟踪方法</p>
<h4 id="问：定位频繁full-GC，堆内存满-oom-？"><a href="#问：定位频繁full-GC，堆内存满-oom-？" class="headerlink" title="问：定位频繁full GC，堆内存满 oom ？"></a><strong>问：定位频繁full GC，堆内存满 oom ？</strong></h4><p>第一步：jps获取进程号 第二步：jmap -histo pid | head -20 得知有个对象在不断创建 备注：jmap如果线上服务器堆内存特别大，，会卡死需堆转存（一般会说在测试环境压测，导出转存） -XX：+HeapDumpOnOutOfMemoryError或jmap -dumpLformat=b，file=xxx pid 转出文件进行分析 （arthas没有实现jmap命令）heapdump –live /xxx/xx.hprof导出文件</p>
<h4 id="问：G1垃圾回收器（重点）-？"><a href="#问：G1垃圾回收器（重点）-？" class="headerlink" title="问：G1垃圾回收器（重点） ？"></a><strong>问：G1垃圾回收器（重点） ？</strong></h4><p>回收过程 （1）：young gc（年轻代回收）–当年轻代的Eden区用尽时–stw 第一阶段，扫描根。 根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等 第二阶段，更新RS（Remembered Sets）。 处理dirty card queue中的card，更新RS。此阶段完成后，RS可以准确的反映老年代对所在的内存分段中对象的引用 第三阶段，处理RS。 识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。 第四阶段，复制对象。 此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段 第五阶段，处理引用。 处理Soft，Weak，Phantom，Final，JNI Weak 等引用。</p>
<p>（2）：concrruent marking（老年代并发标记） 当堆内存使用达到一定值（默认45%）时，不需要Stop-The-World，在并发标记前先进行一次young gc</p>
<p>（3）：混合回收（mixed gc） 并发标记过程结束以后，紧跟着就会开始混合回收过程。混合回收的意思是年轻代和老年代会同时被回收</p>
<p>（4）：Full GC? Full GC是指上述方式不能正常工作，G1会停止应用程序的执行，使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。要避免Full GC的发生，一旦发生需要进行调整。</p>
<h4 id="问：什么时候发生Full-GC呢-？"><a href="#问：什么时候发生Full-GC呢-？" class="headerlink" title="问：什么时候发生Full GC呢 ？"></a><strong>问：什么时候发生Full GC呢 ？</strong></h4><p>比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc，这种情况可以通过增大内存解决</p>
<p>尽管G1堆内存仍然是分代的，但是同一个代的内存不再采用连续的内存结构</p>
<p>年轻代分为Eden和Survivor两个区，老年代分为Old和Humongous两个区</p>
<p>新分配的对象会被分配到Eden区的内存分段上</p>
<p>Humongous区用于保存大对象，如果一个对象占用的空间超过内存分段Region的一半；</p>
<p>如果对象的大小超过一个甚至几个分段的大小，则对象会分配在物理连续的多个Humongous分段上。</p>
<p>Humongous对象因为占用内存较大并且连续会被优先回收</p>
<p>为了在回收单个内存分段的时候不必对整个堆内存的对象进行扫描（单个内存分段中的对象可能被其他内存分段中的对象引用）引入了RS数据结构。RS使得G1可以在年轻代回收的时候不必去扫描老年代的对象，从而提高了性能。每一个内存分段都对应一个RS，RS保存了来自其他分段内的对象对于此分段的引用</p>
<p>JVM会对应用程序的每一个引用赋值语句object.field=object进行记录和处理，把引用关系更新到RS中。但是这个RS的更新并不是实时的。G1维护了一个Dirty Card Queue</p>
<h4 id="问：那为什么不在引用赋值语句处直接更新RS呢-？"><a href="#问：那为什么不在引用赋值语句处直接更新RS呢-？" class="headerlink" title="问：那为什么不在引用赋值语句处直接更新RS呢 ？"></a><strong>问：那为什么不在引用赋值语句处直接更新RS呢 ？</strong></h4><p>这是为了性能的需要，使用队列性能会好很多。</p>
<h4 id="问：线程本地分配缓冲区（TLAB：-Thread-Local-Allocation-Buffer）-？"><a href="#问：线程本地分配缓冲区（TLAB：-Thread-Local-Allocation-Buffer）-？" class="headerlink" title="问：线程本地分配缓冲区（TLAB： Thread Local Allocation Buffer） ？"></a><strong>问：线程本地分配缓冲区（TLAB： Thread Local Allocation Buffer） ？</strong></h4><p>栈上分配-&gt;tlab-&gt;堆上分配 由于堆内存是应用程序共享的，应用程序的多个线程在分配内存的时候需要加锁以进行同步。为了避免加锁，提高性能每一个应用程序的线程会被分配一个TLAB。TLAB中的内存来自于G1年轻代中的内存分段。当对象不是Humongous对象，TLAB也能装的下的时候，对象会被优先分配于创建此对象的线程的TLAB中。这样分配会很快，因为TLAB隶属于线程，所以不需要加锁</p>
<h4 id="问：PLAB：-Promotion-Thread-Local-Allocation-Buffer-？"><a href="#问：PLAB：-Promotion-Thread-Local-Allocation-Buffer-？" class="headerlink" title="问：PLAB： Promotion Thread Local Allocation Buffer ？"></a><strong>问：PLAB： Promotion Thread Local Allocation Buffer ？</strong></h4><p>G1会在年轻代回收过程中把Eden区中的对象复制（“提升”）到Survivor区中，Survivor区中的对象复制到Old区中。G1的回收过程是多线程执行的，为了避免多个线程往同一个内存分段进行复制，那么复制的过程也需要加锁。为了避免加锁，G1的每个线程都关联了一个PLAB，这样就不需要进行加锁了</p>
<h4 id="问：OOM问题定位方法-？"><a href="#问：OOM问题定位方法-？" class="headerlink" title="问：OOM问题定位方法 ？"></a><strong>问：OOM问题定位方法 ？</strong></h4><p>（1）：jmap -heap 10765如上图，可以查看新生代，老生代堆内存的分配大小以及使用情况；</p>
<p>（2）：jstat 查看GC收集情况</p>
<p>（3）：jmap -dump：live，format=b，file=到本地</p>
<p>（4）：通过MAT工具打开分析</p>
<h4 id="问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？"><a href="#问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？" class="headerlink" title="问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？"></a><strong>问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？</strong></h4><h4 id="问：简单介绍一下GC垃圾回收算法？说说GC的过程"><a href="#问：简单介绍一下GC垃圾回收算法？说说GC的过程" class="headerlink" title="问：简单介绍一下GC垃圾回收算法？说说GC的过程"></a><strong>问：简单介绍一下GC垃圾回收算法？说说GC的过程</strong></h4><p>垃圾回收。如何通知gc回收?（System.gc）除了这个方法还有吗?（将不用的对象赋值为null）</p>
<h4 id="问：常见的垃圾回收器？"><a href="#问：常见的垃圾回收器？" class="headerlink" title="问：常见的垃圾回收器？"></a><strong>问：常见的垃圾回收器？</strong></h4><h4 id="问：Java-GC机制？GC-Roots有哪些？"><a href="#问：Java-GC机制？GC-Roots有哪些？" class="headerlink" title="问：Java GC机制？GC Roots有哪些？"></a><strong>问：Java GC机制？GC Roots有哪些？</strong></h4><h4 id="问：强制young-gc会有什么问题？"><a href="#问：强制young-gc会有什么问题？" class="headerlink" title="问：强制young gc会有什么问题？"></a><strong>问：强制young gc会有什么问题？</strong></h4><h4 id="问：知道G1么？回收过程是怎么样的？"><a href="#问：知道G1么？回收过程是怎么样的？" class="headerlink" title="问：知道G1么？回收过程是怎么样的？"></a><strong>问：知道G1么？回收过程是怎么样的？</strong></h4><p>你提到的Remember Set底层是怎么实现的？CMS GC有什么问题？怎么避免产生浮动垃圾？</p>
<h4 id="问：Full-GC-发生的条件、怎么设置永久代和堆的大小、怎么减少-Full-GC-、JVM-调优？"><a href="#问：Full-GC-发生的条件、怎么设置永久代和堆的大小、怎么减少-Full-GC-、JVM-调优？" class="headerlink" title="问：Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优？"></a><strong>问：Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优？</strong></h4><h4 id="问：GC-常见算法，CMS-以及-G1-的垃圾回收过程，CMS-的各个阶段哪两个是-Stop-the-world-的，CMS-会不会产生碎片，G1-的优势-？"><a href="#问：GC-常见算法，CMS-以及-G1-的垃圾回收过程，CMS-的各个阶段哪两个是-Stop-the-world-的，CMS-会不会产生碎片，G1-的优势-？" class="headerlink" title="问：GC 常见算法，CMS 以及 G1 的垃圾回收过程，CMS 的各个阶段哪两个是 Stop the world 的，CMS 会不会产生碎片，G1 的优势 ？"></a><strong>问：GC 常见算法，CMS 以及 G1 的垃圾回收过程，CMS 的各个阶段哪两个是 Stop the world 的，CMS 会不会产生碎片，G1 的优势 ？</strong></h4><h4 id="问：标记清除、复制和标记整理算法的理解以及优缺点-？"><a href="#问：标记清除、复制和标记整理算法的理解以及优缺点-？" class="headerlink" title="问：标记清除、复制和标记整理算法的理解以及优缺点 ？"></a><strong>问：标记清除、复制和标记整理算法的理解以及优缺点 ？</strong></h4><h4 id="问：JVM-如何判断一个对象是否该被-GC，可以视为-root-的都有哪几种类型-？"><a href="#问：JVM-如何判断一个对象是否该被-GC，可以视为-root-的都有哪几种类型-？" class="headerlink" title="问：JVM 如何判断一个对象是否该被 GC，可以视为 root 的都有哪几种类型 ？"></a><strong>问：JVM 如何判断一个对象是否该被 GC，可以视为 root 的都有哪几种类型 ？</strong></h4><h4 id="问：强软弱虚引用的区别以及-GC-对他们执行怎样的操作-？"><a href="#问：强软弱虚引用的区别以及-GC-对他们执行怎样的操作-？" class="headerlink" title="问：强软弱虚引用的区别以及 GC 对他们执行怎样的操作 ？"></a><strong>问：强软弱虚引用的区别以及 GC 对他们执行怎样的操作 ？</strong></h4><h4 id="问：Java-是否可以-GC-直接内存-？"><a href="#问：Java-是否可以-GC-直接内存-？" class="headerlink" title="问：Java 是否可以 GC 直接内存 ？"></a><strong>问：Java 是否可以 GC 直接内存 ？</strong></h4><h4 id="问：GC-优化的步骤-？"><a href="#问：GC-优化的步骤-？" class="headerlink" title="问：GC 优化的步骤 ？"></a><strong>问：GC 优化的步骤 ？</strong></h4><h4 id="问：有过GC调优的经历么？"><a href="#问：有过GC调优的经历么？" class="headerlink" title="问：有过GC调优的经历么？"></a><strong>问：有过GC调优的经历么？</strong></h4><h4 id="问：CMS-和-G1-收集过程-？"><a href="#问：CMS-和-G1-收集过程-？" class="headerlink" title="问：CMS 和 G1 收集过程 ？"></a><strong>问：CMS 和 G1 收集过程 ？</strong></h4><h4 id="问：java-new-一个对象的时候，什么情况下会发生-GC-？"><a href="#问：java-new-一个对象的时候，什么情况下会发生-GC-？" class="headerlink" title="问：java new 一个对象的时候，什么情况下会发生 GC ？"></a><strong>问：java new 一个对象的时候，什么情况下会发生 GC ？</strong></h4><h4 id="问：如果新生代和老年代没有满呢-？"><a href="#问：如果新生代和老年代没有满呢-？" class="headerlink" title="问：如果新生代和老年代没有满呢 ？"></a><strong>问：如果新生代和老年代没有满呢 ？</strong></h4><hr>
<h2 id="第四节-类加载"><a href="#第四节-类加载" class="headerlink" title="第四节 类加载"></a><strong>第四节 类加载</strong></h2><h4 id="问：JVM-类加载顺序-？"><a href="#问：JVM-类加载顺序-？" class="headerlink" title="问：JVM 类加载顺序 ？"></a><strong>问：JVM 类加载顺序 ？</strong></h4><p>（1）：加载 获取类的二进制字节流，将其静态存储结构转化为方法区的运行时数据结构</p>
<p>（2）：校验 文件格式验证，元数据验证，字节码验证，符号引用验证</p>
<p>（3）：准备 在方法区中对类的static变量分配内存并设置类变量数据类型默认的初始值，不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中</p>
<p>（4）：解析 将常量池内的符号引用替换为直接引用的过程</p>
<p>（5）：初始化 为类的静态变量赋予正确的初始值（Java代码中被显式地赋予的值）</p>
<h4 id="问：JVM三种类加载器-？"><a href="#问：JVM三种类加载器-？" class="headerlink" title="问：JVM三种类加载器 ？"></a><strong>问：JVM三种类加载器 ？</strong></h4><p>（1）：启动类加载器（home） 加载jvm核心类库，如java.lang.*等</p>
<p>（2）：扩展类加载器（ext）， 父加载器为启动类加载器，从jre/lib/ext下加载类库</p>
<p>（3）：应用程序类加载器（用户classpath路径） 父加载器为扩展类加载器，从环境变量中加载类</p>
<h4 id="问：双亲委派机制-？"><a href="#问：双亲委派机制-？" class="headerlink" title="问：双亲委派机制 ？"></a><strong>问：双亲委派机制 ？</strong></h4><p>（1）：类加载器收到类加载的请求</p>
<p>（2）：把这个请求委托给父加载器去完成，一直向上委托，直到启动类加载器</p>
<p>（3）：启动器加载器检查能不能加载，能就加载（结束）；否则，抛出异常，通知子加载器进行加载</p>
<p>（4）：保障类的唯一性和安全性以及保证JDK核心类的优先加载</p>
<h4 id="问：双亲委派模型有啥作用-？"><a href="#问：双亲委派模型有啥作用-？" class="headerlink" title="问：双亲委派模型有啥作用 ？"></a><strong>问：双亲委派模型有啥作用 ？</strong></h4><ul>
<li><p>保证java基础类在不同的环境还是同一个Class对象，避免出现了自定义类覆盖基础类的情况，导致出现安全问题。</p>
</li>
<li><p>还可以避免类的重复加载。</p>
</li>
</ul>
<h4 id="问：如何打破双亲委派模型-？"><a href="#问：如何打破双亲委派模型-？" class="headerlink" title="问：如何打破双亲委派模型 ？"></a><strong>问：如何打破双亲委派模型 ？</strong></h4><p>（1）：自定义类加载器，继承ClassLoader类重写loadClass方法；</p>
<p>（2）：SPI</p>
<h4 id="问：tomcat是如何打破双亲委派模型-？"><a href="#问：tomcat是如何打破双亲委派模型-？" class="headerlink" title="问：tomcat是如何打破双亲委派模型 ？"></a><strong>问：tomcat是如何打破双亲委派模型 ？</strong></h4><p>tomcat有着特殊性，它需要容纳多个应用，需要做到应用级别的隔离，而且需要减少重复性加载，所以划分为：/common 容器和应用共享的类信息，/server容器本身的类信息，/share应用通用的类信息,/WEB-INF/lib应用级别的类信息。整体可以分为：boostrapClassLoader-&gt;ExtensionClassLoader-&gt;ApplicationClassLoader-&gt;CommonClassLoader-&gt;CatalinaClassLoader（容器本身的加载器）/ShareClassLoader（共享的）-&gt;WebAppClassLoader。虽然第一眼是满足双亲委派模型的，但是不是的，因为双亲委派模型是要先提交给父类装载，而tomcat是优先判断是否是自己负责的文件位置，进行加载的。</p>
<h4 id="问：SPI：-（Service-Provider-interface）-？"><a href="#问：SPI：-（Service-Provider-interface）-？" class="headerlink" title="问：SPI： （Service Provider interface） ？"></a><strong>问：SPI： （Service Provider interface） ？</strong></h4><p>（1）：服务提供接口（服务发现机制）：</p>
<p>（2）：通过加载ClassPath下META_INF/services，自动加载文件里所定义的类</p>
<p>（3）：通过<code>ServiceLoader.load/Service.providers</code>方法通过反射拿到实现类的实例</p>
<h4 id="问：SPI应用-？"><a href="#问：SPI应用-？" class="headerlink" title="问：SPI应用 ？"></a><strong>问：SPI应用 ？</strong></h4><p>（1）：应用于JDBC获取数据库驱动连接过程就是应用这一机制</p>
<p>（2）：apache最早提供的common-logging只有接口.没有实现..发现日志的提供商通过SPI来具体找到日志提供商实现类</p>
<h4 id="问：双亲委派机制缺陷-？"><a href="#问：双亲委派机制缺陷-？" class="headerlink" title="问：双亲委派机制缺陷 ？"></a><strong>问：双亲委派机制缺陷 ？</strong></h4><p>（1）：双亲委派核心是越基础的类由越上层的加载器进行加载， 基础的类总是作为被调用代码调用的API，无法实现基础类调用用户的代码….</p>
<p>（2）：JNDI服务它的代码由启动类加载器去加载，但是他需要调独立厂商实现的应用程序，如何解决? 线程上下文件类加载器（Thread Context ClassLoader）， JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI，JDBC</p>
<h4 id="问：说下类加载的过程？"><a href="#问：说下类加载的过程？" class="headerlink" title="问：说下类加载的过程？"></a><strong>问：说下类加载的过程？</strong></h4><h4 id="问：什么时候需要自定义类加载器？"><a href="#问：什么时候需要自定义类加载器？" class="headerlink" title="问：什么时候需要自定义类加载器？"></a><strong>问：什么时候需要自定义类加载器？</strong></h4><h4 id="问：Class-forName-是否会初始化类？"><a href="#问：Class-forName-是否会初始化类？" class="headerlink" title="问：Class.forName 是否会初始化类？"></a><strong>问：Class.forName 是否会初始化类？</strong></h4><p>这里我智障了，振振有词地说说不会初始化</p>
<h4 id="问：static-块会执行几次？怎么让它执行第二次？"><a href="#问：static-块会执行几次？怎么让它执行第二次？" class="headerlink" title="问：static 块会执行几次？怎么让它执行第二次？"></a><strong>问：static 块会执行几次？怎么让它执行第二次？</strong></h4><h4 id="问：类加载的过程，以及双亲委派机制、自定义类加载器-？"><a href="#问：类加载的过程，以及双亲委派机制、自定义类加载器-？" class="headerlink" title="问：类加载的过程，以及双亲委派机制、自定义类加载器 ？"></a><strong>问：类加载的过程，以及双亲委派机制、自定义类加载器 ？</strong></h4><h4 id="问：Java为什么要设计双亲委派模型？"><a href="#问：Java为什么要设计双亲委派模型？" class="headerlink" title="问：Java为什么要设计双亲委派模型？"></a><strong>问：Java为什么要设计双亲委派模型？</strong></h4><hr>
<h2 id="第五节-调优"><a href="#第五节-调优" class="headerlink" title="第五节 调优"></a><strong>第五节 调优</strong></h2><h4 id="问：Java内存泄漏问题如何进行定位？"><a href="#问：Java内存泄漏问题如何进行定位？" class="headerlink" title="问：Java内存泄漏问题如何进行定位？"></a><strong>问：Java内存泄漏问题如何进行定位？</strong></h4><p>通过一些JDK提供的命令行工具，如jmap、jstack等，通过jmap获取堆转储快照，dump文件，通过jstack获取线程快照，查看线程堆栈</p>
<h4 id="问：StackOverflow异常有没有遇到过？一般你猜测会在什么情况下被触发？"><a href="#问：StackOverflow异常有没有遇到过？一般你猜测会在什么情况下被触发？" class="headerlink" title="问：StackOverflow异常有没有遇到过？一般你猜测会在什么情况下被触发？"></a><strong>问：StackOverflow异常有没有遇到过？一般你猜测会在什么情况下被触发？</strong></h4><h4 id="问：常用的-JVM-调优参数-？"><a href="#问：常用的-JVM-调优参数-？" class="headerlink" title="问：常用的 JVM 调优参数 ？"></a><strong>问：常用的 JVM 调优参数 ？</strong></h4><h4 id="问：当出现了内存泄漏或内存溢出，怎么排错-？"><a href="#问：当出现了内存泄漏或内存溢出，怎么排错-？" class="headerlink" title="问：当出现了内存泄漏或内存溢出，怎么排错 ？"></a><strong>问：当出现了内存泄漏或内存溢出，怎么排错 ？</strong></h4><h4 id="问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行"><a href="#问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行" class="headerlink" title="问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行"></a><strong>问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行</strong></h4><hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/138951555">后端面试的所有知识点</a></p>
</blockquote>
<p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019102401.html" title="面试整理——JVM">http://linyishui.top/2019102401.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019102301.html" rel="prev" title="面试整理——Java网络编程">
                  <i class="fa fa-chevron-left"></i> 面试整理——Java网络编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019102501.html" rel="next" title="面试整理——算法">
                  面试整理——算法 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">45:48</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
