<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的Web服务器相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——Web服务器">
<meta property="og:url" content="http://linyishui.top/2019102301.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的Web服务器相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9ia1PiaAebibic1kIQRQnolZP4VUTVPANfubOBauaCwojzIASDTN1PicDLDQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9QBiaYbbpYkbbggCsWMZKCgq4a6CEyqphbJNpyEttUFZ31eBVQYku5jw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9nibibaAG7E8iamNdSTRHrmnZab2JHmVtxAfusRLqTnY7WqeI4OE1qAzUA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9jG8fTmek0NEj1jtJ9LhEm9E3ulyiaXf5VQPzVONUUJckXRJibl6oxTWg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9MJZDq4icN3wpB5958kX7nduc2FvQBwHOrmicZjwQMLNRNEJicObNXOILQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp91rCkp1ftMaINAYJFmrQD3icJTicnjh7IQic1q5BOiazOgJQNIuSiacgziacA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9CXKbfIqhSSjLUJJxBcTvwSeLOD8UfbpX1OPGXlReABrZ79cticvgx3A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9ribZhTJF1icxGNmHAY8d6VDMZHQOwMBbstfib1F5gqYEeQia82DUPZVsicA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9ajSHIczOCHMVMAM8lRxLznMGQmPicC6icbZM3vMOichknZ5Ah7iaorMbyw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp97mfZagvPVrRWyKxS6hrXWgTNaY7cZBsxwkDmU8qPLHciacw4IQ0DwSQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9TpbI5sEhBpdOPsnllcdIHYQV7MqBhjUiaRHG2OaRaYicF9AsibwZicgCAg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9uzE5OxgB9HykbTic2lZrWaicMvJVIdkcydOGw2AEBfLwUf96iaBd2fw6g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9bkdgbic4BrNBaMKdsXHOoKddIB2xVicibSX9YhOgr0cibRVEz9oabFF6LQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9YDwOOiaiamhR9HAy2mibZ90wK7ttIRxaJGDuall9Hd8sec8UD05NlZgAA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp954rkXagMlB19vGSykdVouKvB4GLabjMBtDoH5Ed0R39QvznMN9d4zA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9SxrV2VNcSZH2mbA0feSa2htcurRUGCvIYJRbMUJHRYarDcjYYVG9ZQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp95d2jLgCo0U3tXG3swHLb47RQDTHcTuSiaHia1nEYy0tShytZGHvdlc4Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9viadrB4oMpBKjQu0ZTI7Mt6iblhQAtNiaH5yBywPgicnr2Viarq6t8rS6Ww/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9VqkNzvAE5yCHzGtJSQFBbiaib6uxrAznsxugc4ibAt35ic3msH1wj6nKHA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9J8eF6LTUFValXbyalsMaTudKGFyegiaXyibhR3JfkeicnGibrvpA4nGxXg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9IRHA7LbeicoJzfBo7deJPrUDtsK8icJCtibkicRQ8ff2SgrBgJ9jmGb0xQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9pg8wNgnUPYOozx49Syrlx2gdFJ4VpJ00nBzu5ZoticoWww2gFDsbVnw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9kXMuhwBqoq4Vic5Kb3ds312a5MnhZmnbgtiavPEMxs4EzrP2Z3IJj7rw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp92PH2lCbsrbKqqibVQokpIsjj7mk86hLLe6xHjicAgJ6uvibpU6A7CThOw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9uANjLzcicxHnCEMt1SicJMiaj0CpibAGPpz7icwTicVD45sowEj6B9qe3lzg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9gV53SnMjcjfarBcJxiaoe8LJRibnC2UiacichrYiavLldLq8ORSQiaCQxUow/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9E2t34XsSASSk3BIlGz1seqqbIOG6Qn6iboovT1tUvGMmzR1TAoKicORQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9mXIlGiavpL0k5FQEMnb2yVespr0M0HKwJO5OLWkAotlCTafOqjwdiczg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9ImfiavF7Ph2Qnl45zmMB4K1SNWYIFEjcgbTkkm0QBWxWCTdgdX08RVg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9hBE1pNZibiccgksjZQPJ6r4icmQg2UZ5HhaZqqtm0c4TVeYcbyHGQfA1g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9rMpZVEHKFYInR7tp0xLYeKBAapRxEyqnu7ATRFjQKEttibWq2rH5KWg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9A8yeZ2dmTSh1c2yBWYglf3dCrs85rpWRAdK4PsehsILpblOKn1mrXA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9oS9ynMmfdHamXP5W0mdm4xC8ciab8czDb9d8duuExPFvRBicQfJxA8yQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp94qtMU0SIvubLYLlvU6wZ7trrTwBAww4Tvu2f3D3scPXxJpiavHhGiaicg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9PqwwzCVFe0xJVia9H67M3UtaKpvsCibXicxkWOkaZ0LLiclgr4PRRYoyPg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9FqJk0NokHcTknRNNMwjSbqMzwAdumicenlr4Ryu9qFOQRqO1e6ChWlA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9H6HicPjmFic76tHcgH5KJiaz9gUqdr3hKOu4jDl7yUQ4u4yIiaFuRdgAhg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9BVs37QobONOMtibqHZW3KlBcor5p0X4794nh8bxBuT334ib4FOPIbZag/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp97chMqfFEsRT56N9U4icdBVOCa6NlHvyIYO8QAT8fsJibmULLaJxOGwBg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9lEFOickV7bcng5QU7yS69iarLpK4vzibLNA7b1ovCqN3ny5oicuLqicPCGQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9UgRz9sCRUBwPdX3daapUKcmXJKtAJq3XZCBYQMibSkDDPYW7SISh2gQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9YX1yQgh6J3ViblQDibgdeKnJM92XJiayfslodmvmZD1zeRpOhexkicotvw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9fzY5WMcsyjRoChafKiaictShic6pJ0GibpznCAhfgy7C2NbKLw38Mx3jwA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9R4Aia1BpauRv48DqrhyxQWoBxNO8vMibpRteek0cdVMYJlExCS654dicg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9J10QoaGrLFP1za0xXPManFpxkwz2RzbPfpsLGW3APspOLSYFLlicb1A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9r03uG30R4ISa9eFdlHZfeZgTzA3vr4fQVs3p1fDdvOwicQfCGD410yw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9yyfMIAxIXEk53paL6pmyO3ia0X3icYFM4C45mhhNhw5BibRG3v4m3gecw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9SHOATpwjU3Iw5ia0pmyLooWD8mvt44Y1iaWMxFE9eLsDZkFkwDUkmGsA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9QqT0y93trNibuQIfk26Jib0HMvO28jh0NqibjcHfLzxHUu8iaBD34oqoKw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9MOfAuOTyV5lXIMutGK3gE2TK6L4GDyLaZIv6LjchtMDfUxvYBYdQ4g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="article:published_time" content="2019-10-23T08:06:22.000Z">
<meta property="article:modified_time" content="2024-08-16T08:23:42.042Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9ia1PiaAebibic1kIQRQnolZP4VUTVPANfubOBauaCwojzIASDTN1PicDLDQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">


<link rel="canonical" href="http://linyishui.top/2019102301.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019102301.html","path":"2019102301.html","title":"面试整理——Web服务器"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——Web服务器 | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">Web服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80"><span class="nav-text">一.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-Netty"><span class="nav-text">二. Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ANIO"><span class="nav-text">问：NIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFNetty%EF%BC%9F"><span class="nav-text">问：什么是Netty？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ANetty%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="nav-text">问：Netty的执行流程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ANetty%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-text">问：Netty的核心组件？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"><span class="nav-text">Netty 源码阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty-Server-%E4%BB%A3%E7%A0%81"><span class="nav-text">Netty - Server 代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty-Client-%E4%BB%A3%E7%A0%81"><span class="nav-text">Netty - Client 代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioEventLoopGroup-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90"><span class="nav-text">NioEventLoopGroup 初始化分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ServerBootstrap%E4%B8%8E-ServerBootstrap-%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E5%88%86%E6%9E%90"><span class="nav-text">ServerBootstrap与 ServerBootstrap 属性配置分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-bind-%E6%96%B9%E6%B3%95-ServerBootstrap-bind-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-text">服务端 bind 方法 ServerBootstrap.bind() 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Tag-0%EF%BC%9AChannelPromise-%E4%B8%8E-ChannelFuture"><span class="nav-text">补充 Tag 0：ChannelPromise 与 ChannelFuture</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tag-1-%EF%BC%9AinitAndRegister-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B9%B6%E6%B3%A8%E5%86%8C-Channel"><span class="nav-text">Tag 1 ：initAndRegister() 初始化并注册 Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-1-channelFactory-newChannel-%E5%88%9B%E5%BB%BA-Channel"><span class="nav-text">Tag 1.1  channelFactory.newChannel()  创建 Channel</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-2-init-channel-%E5%88%9D%E5%A7%8B%E5%8C%96-Channel"><span class="nav-text">Tag 1.2  init(channel)  初始化 Channel</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-3-config-group-register-channel-%E5%B0%86channel%E6%B3%A8%E5%86%8C%E5%88%B0selector"><span class="nav-text">Tag 1.3  config().group().register(channel)  将channel注册到selector</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-3-1-register0-promise"><span class="nav-text">Tag 1.3.1  register0(promise)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-3-2-eventLoop-excute-%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90"><span class="nav-text">Tag 1.3.2  eventLoop.excute() 执行分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-3-3-eventLoop-excute-%E7%9A%84-run-%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90"><span class="nav-text">Tag 1.3.3  eventLoop.excute() 的 run 方法执行分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-3-3-1%EF%BC%9AselectStrategy-calculateStrategy"><span class="nav-text">Tag 1.3.3.1：selectStrategy.calculateStrategy</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-3-3-2-%EF%BC%9Aswitch-case"><span class="nav-text">Tag 1.3.3.2 ：switch - case</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-3-3-3-%EF%BC%9AprocessSelectedKeys"><span class="nav-text">Tag 1.3.3.3 ：processSelectedKeys()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-3-3-4-%EF%BC%9ArunAllTasks"><span class="nav-text">Tag 1.3.3.4 ：runAllTasks()</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tag-2-doBind0-%E7%BB%91%E5%AE%9A%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-text">Tag 2  doBind0()  绑定端口号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Client-%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90"><span class="nav-text">Client 端启动分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bootstrap-connect-%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-text">Bootstrap.connect() 分析：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tag-1%EF%BC%9AinitAndRegister-%E5%88%86%E6%9E%90"><span class="nav-text">Tag 1：initAndRegister() 分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-1-newChannel-%E5%88%86%E6%9E%90"><span class="nav-text">Tag 1.1 newChannel() 分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-2-init-channel-%E5%88%86%E6%9E%90"><span class="nav-text">Tag 1.2  init(channel) 分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Tag-1-3-register-channel-%E5%88%86%E6%9E%90"><span class="nav-text">Tag 1.3  register(channel)  分析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tag-2%EF%BC%9AdoResolveAndConnect0-%E5%88%86%E6%9E%90"><span class="nav-text">Tag 2：doResolveAndConnect0 分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pipeline"><span class="nav-text">Pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Pipeline-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">Pipeline 的创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ChannelInitializer-%E5%A4%84%E7%90%86%E5%99%A8%E8%8A%82%E7%82%B9"><span class="nav-text">ChannelInitializer 处理器节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hanndler-%E6%B7%BB%E5%8A%A0%E5%88%B0-Pipeline"><span class="nav-text">Hanndler 添加到 Pipeline</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tag-Handler-1-%EF%BC%9AnewContext"><span class="nav-text">Tag Handler 1 ：newContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tag-Handler-2-%EF%BC%9AaddLast0"><span class="nav-text">Tag Handler 2 ：addLast0.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tag-Handler-3-callHandlerCallbackLater-callHandlerAdded0"><span class="nav-text">Tag Handler 3  callHandlerCallbackLater&#x2F;callHandlerAdded0</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pipeline-%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E4%BC%A0%E9%80%92%E4%B8%8E%E5%A4%84%E7%90%86"><span class="nav-text">Pipeline 中消息的传递与处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InboundHandler-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">InboundHandler 执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OutboundHandler-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">OutboundHandler 执行流程</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019102301.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——Web服务器
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-23 16:06:22" itemprop="dateCreated datePublished" datetime="2019-10-23T16:06:22+08:00">2019-10-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-08-16 16:23:42" itemprop="dateModified" datetime="2024-08-16T16:23:42+08:00">2024-08-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>91k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:22</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的Web服务器相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h1><p>Netty，Mina，Akka，Undertow</p>
<h2 id="一"><a href="#一" class="headerlink" title="一."></a>一.</h2><h2 id="二-Netty"><a href="#二-Netty" class="headerlink" title="二. Netty"></a>二. Netty</h2><h4 id="问：NIO"><a href="#问：NIO" class="headerlink" title="问：NIO"></a>问：NIO</h4><p>  <a href="../2019102002.html" title="Title">面试整理——Java基础</a> </p>
<h4 id="问：什么是Netty？"><a href="#问：什么是Netty？" class="headerlink" title="问：什么是Netty？"></a>问：什么是Netty？</h4><p>Netty 是一个基于 Java 的异步事件驱动的网络应用框架，简化和简化了网络编程。</p>
<p>Netty 采用了非阻塞的 I/O（NIO）模型，能够处理大量并发连接，性能非常出色。相对于传统的阻塞 I/O（BIO）模型，Netty 可以更高效地利用系统资源，减少线程数量和上下文切换的开销。</p>
<p>除了常见的 TCP、UDP 以外，Netty 还支持多种高层协议，如 HTTP、WebSocket、SSL/TLS 等，开发者可以根据需求选择合适的协议实现。</p>
<h4 id="问：Netty的执行流程？"><a href="#问：Netty的执行流程？" class="headerlink" title="问：Netty的执行流程？"></a>问：Netty的执行流程？</h4><ol>
<li>Server启动，Netty从ParentGroup中选出一个NioEventLoop对指定的port进行监听。</li>
<li>Client启动，Netty从EventLoopGroup中选出一个NioEventLoop对连接Server并处理Server发送来的数据。</li>
<li>Client连接Server的port，创建Channel。</li>
<li>Netty从ChildGroup中选出一个NioEventLoop与该channel绑定，用于处理该Channel中所有的操作。</li>
<li>Client通过Channel向Server发送数据包。</li>
<li>Pipeline中的处理器一次对Channel中的数据包进行处理。</li>
<li>Server如需向Client发送数据。则需将数据经过Pipeline中的处理器处理形成ByteBuf数据包进行传输。</li>
<li>Server将数据包通过Channel发送给Client。</li>
<li>Pipeline中的处理器一次对Channel中的数据包进行处理。</li>
</ol>
<h4 id="问：Netty的核心组件？"><a href="#问：Netty的核心组件？" class="headerlink" title="问：Netty的核心组件？"></a>问：Netty的核心组件？</h4><ol>
<li><strong>Channel</strong>：Channel是 Java NIO 的一个基本构造。可以看作是传入或传出数据的载体。它可以被打开或关闭，连接或者断开连接。</li>
<li><strong>EventLoop</strong>与<strong>EventLoopGroup</strong><ul>
<li>EventLoop 定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件，在内部，将会为每个Channel分配一个EventLoop。</li>
<li>EventLoopGroup 是一个 EventLoop 池，包含很多的 EventLoop。</li>
<li>Netty 为每个 Channel 分配了一个 EventLoop，用于处理用户连接请求、对用户请求的处理等所有事件。EventLoop 本身只是一个线程驱动，在其生命周期内只会绑定一个线程，让该线程处理一个 Channel 的所有 IO 事件。</li>
<li>一个 Channel 一旦与一个 EventLoop 相绑定，那么在 Channel 的整个生命周期内是不能改变的。一个 EventLoop 可以与多个 Channel 绑定。即 Channel 与 EventLoop 的关系是 n:1，而 EventLoop 与线程的关系是 1:1。</li>
</ul>
</li>
<li><strong>ServerBootstrap</strong>与<strong>Bootstrap</strong><ul>
<li>Bootstarp 和 ServerBootstrap 被称为引导类，指对应用程序进行配置，并使他运行起来的过程。Netty处理引导的方式是使你的应用程序和网络层相隔离。</li>
<li>Bootstrap 是客户端的引导类，Bootstrap 在调用 bind()（连接UDP）和 connect()（连接TCP）方法时，会新创建一个 Channel，仅创建一个单独的、没有父 Channel 的 Channel 来实现所有的网络交换。</li>
<li>ServerBootstrap 是服务端的引导类，ServerBootstarp 在调用 bind() 方法时会创建一个 ServerChannel 来接受来自客户端的连接，并且该 ServerChannel 管理了多个子 Channel 用于同客户端之间的通信。</li>
</ul>
</li>
<li><strong>ChannelHandler</strong>与<strong>ChannelPipeline</strong><ul>
<li>ChannelHandler 是对 Channel 中数据的处理器，这些处理器可以是系统本身定义好的编解码器，也可以是用户自定义的。这些处理器会被统一添加到一个 ChannelPipeline 的对象中，然后按照添加的顺序对 Channel 中的数据进行依次处理。</li>
</ul>
</li>
<li><strong>ChannelFuture</strong><ul>
<li>Netty 中所有的 I/O 操作都是异步的，即操作不会立即得到返回结果，所以 Netty 中定义了一个 ChannelFuture 对象作为这个异步操作的“代言人”，表示异步操作本身。如果想获取到该异步操作的返回值，可以通过该异步操作对象的addListener() 方法为该异步操作添加监 NIO 网络编程框架 Netty 听器，为其注册回调：当结果出来后马上调用执行。</li>
<li>Netty 的异步编程模型都是建立在 Future 与回调概念之上的。</li>
</ul>
</li>
</ol>
<h3 id="Netty-源码阅读"><a href="#Netty-源码阅读" class="headerlink" title="Netty 源码阅读"></a>Netty 源码阅读</h3><h4 id="Netty-Server-代码"><a href="#Netty-Server-代码" class="headerlink" title="Netty - Server 代码"></a>Netty - Server 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup parentGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup childGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(parentGroup, childGroup)</span><br><span class="line">                     .channel(NioServerSocketChannel.class)</span><br><span class="line">                     .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> SomeSocketServerHandler());</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = bootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parentGroup.shutdownGracefully();</span><br><span class="line">            childGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Server 端 Handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSocketServerHandler</span></span></span><br><span class="line"><span class="class">                       <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Client Address ====== &quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;from server:&quot;</span> + UUID.randomUUID());</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Netty-Client-代码"><a href="#Netty-Client-代码" class="headerlink" title="Netty - Client 代码"></a>Netty - Client 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> DemoSocketClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(eventLoopGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                eventLoopGroup.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Client 端  Handler ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSocketClientHandler</span></span></span><br><span class="line"><span class="class">               <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;from client: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;from client：begin talking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NioEventLoopGroup-初始化分析"><a href="#NioEventLoopGroup-初始化分析" class="headerlink" title="NioEventLoopGroup 初始化分析"></a>NioEventLoopGroup 初始化分析</h3><p>首先根据 Server 服务端代码，分析 NioEventLoopGroup 的初始化过程。而在分析 NioEventLoopGroup 之前，有必要简单的说一说 NioEventLoopGroup 与 NioEventLoop ，方便后续源码的理解。</p>
<p>NioEventLoop 源码分析前了解：</p>
<p><strong>NioEventLoop 的继承体系</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9ia1PiaAebibic1kIQRQnolZP4VUTVPANfubOBauaCwojzIASDTN1PicDLDQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>从 NioEventLoop 的继承体系中可以看到，NioEventLoop  本身就是一个 Executor，并且还是一个 单线程的 Executor。Executor  必然拥有一个 <code>execute(Runnable command)</code> 的实现方法，而 NioEventLoop 的 <code>execute()</code> 实现方法在其父类  SingleThreadEventExecutor 中，找到具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (removeTask(task)) &#123;</span><br><span class="line">                    reject = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">                <span class="comment">// The task queue does not support removal so the best thing we can do is to just move on and</span></span><br><span class="line">                <span class="comment">// hope we will be able to pick-up the task before its completely terminated.</span></span><br><span class="line">                <span class="comment">// In worst case we will log on termination.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reject) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里不细说，但是贴出这段代码主要为了引出 <code>startThread();</code> 这句代码，在跟这句代码会发现，它最终调用了 NioEventLoop 的一个成员 Executor 执行了当前成员的 <code>execute()</code> 方法。对应的成员 <code>io.netty.util.concurrent.SingleThreadEventExecutor#executor</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9QBiaYbbpYkbbggCsWMZKCgq4a6CEyqphbJNpyEttUFZ31eBVQYku5jw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>而 executor 成员的初始化也是在当前代码执行时创建的匿名 Executor ，也就是执行到即新建并且执行当前 匿名 <code>executr()</code> 方法。</p>
<p><strong>总结：</strong></p>
<ol>
<li>NioEventLoop 本身就是一个 Executor。</li>
<li>NioEventLoop 内部封装这一个新的线程 Executor 成员。</li>
<li>NioEventLoop 有两个 <code>execute</code> 方法，除了本身的 <code>execute()</code> 方法对应的还有成员属性 Executor  对应的 <code>execute()</code> 方法。</li>
</ol>
<p><strong>备注：</strong> 因为这里出现了四个 Executor，为了区分，我们给其新的名称：</p>
<blockquote>
<p>NioEventLoop 本身 Executor：<strong>NioEventLoop</strong></p>
<p>NioEventLoop 的成员 Executor：<strong>子 Executor</strong></p>
<p>NioEventLoopGroup 本身 Executor ：<strong>NioEventLoopGroup</strong></p>
<p>NioEventLoopGroup 的构造参数 Executor ：<strong>总Executor</strong></p>
</blockquote>
<p><strong>NioEventLoopGroup 的继承体系</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9nibibaAG7E8iamNdSTRHrmnZab2JHmVtxAfusRLqTnY7WqeI4OE1qAzUA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>看到继承体系可以直接知道 NioEventLoopGroup 也是一个 Executor，并且是一个线程池的 Executor，所以他也有 <code>execute()</code> 方法。对应的实现再其父类之中：<code>io.netty.util.concurrent.AbstractEventExecutorGroup#execute</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9jG8fTmek0NEj1jtJ9LhEm9E3ulyiaXf5VQPzVONUUJckXRJibl6oxTWg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>而这里还需要说到的一点是：在 NioEventLoopGroup  的构造中，再其父类 MultithreadEventExecutorGroup 的构造再次引入了一个新的 Executor，</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9MJZDq4icN3wpB5958kX7nduc2FvQBwHOrmicZjwQMLNRNEJicObNXOILQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>之所以这里提到这个 Executor，是因为这个 Executor 是对应的 <code>execute()</code> 就是在 NioEventLoop 中的成员 Executor 的 <code>execute()</code> 执行时调用的。也就是下面对应的代码调用。<code>io.netty.util.internal.ThreadExecutorMap#apply(java.util.concurrent.Executor, io.netty.util.concurrent.EventExecutor)</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp91rCkp1ftMaINAYJFmrQD3icJTicnjh7IQic1q5BOiazOgJQNIuSiacgziacA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>到这如果不明白，没关系，因为只是为了引入 NioEventLoopGroup 和 NioEventLoop 的对应的两个 Executor，和两个 Executor 对应的两个 <code>execute()</code> 方法。这个后面还会有详细分析。</p>
<p><strong>总结：</strong></p>
<ol>
<li>NioEventLoopGroup 是一个线程池线程 Executor。</li>
<li>NioEventLoopGroup 也封装了一个线程 Executor。</li>
<li>NioEventLoopGroup 也有两个 <code>execute()</code>方法。</li>
</ol>
<p>NioEventLoopGroup 初始化代码分析：</p>
<p>上面说了基本的了解内容，下面具体分析，从 NioEventLoopGroup 的初始化进入源码分析。</p>
<p>入口我们直接找 NioEventLoopGroup 的无参构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个参数是这个group所包含的executor</span></span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第三个参数是provider，其用于提供selector及selectable的channel，</span></span><br><span class="line">    <span class="comment">// 这个provider是当前JVM中唯一的一个单例的provider</span></span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第四个参数是一个选择策略工厂实例</span></span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第三个参数是选择器工厂实例</span></span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>跟到此，可以发现无参构造的基本参数被初始化， <code>nThreads ：DEFAULT_EVENT_LOOP_THREADS//默认当前CPU逻辑核心数的两倍</code>，<code>selectorProvide:SelectorProvider.provider()//当前JVM中唯一的一个单例的provider</code>，<code>SelectStrategyFactory:DefaultSelectStrategyFactory.INSTANCE//默认选择策略工厂实例</code>，<code>chooserFactory:DefaultEventExecutorChooserFactory.INSTANCE//选择器工厂实例</code>。到这里只是基本的初始化参数，重点方法为<code>MultithreadEventExecutorGroup</code> 的构造方法。下面重点分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个executor是group所包含的executor，其将来会为其所包含的每个eventLoop创建一个线程</span></span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建eventLoop</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在创建这些eventLoop过程中，只要有一个创建失败，则关闭之前所有已经创建好的eventLoop</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">// 关闭之前所有已经创建好的eventLoop</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 终止所有eventLoop上所执行的任务</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    EventExecutor e = children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个选择器</span></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>根据无参构造直接往下跟，可以看到核心部分在最后一个父类的构造里。也就是 <code>io.netty.util.concurrent.MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, java.util.concurrent.Executor, io.netty.util.concurrent.EventExecutorChooserFactory, java.lang.Object...)</code>。</p>
<p>再这里完成整个 NioEventLoopGroup 的实例初始化，这里分析下，然后再画个图回顾下。</p>
<p>初始化构造参数中的 Executor 参数，当其为空时，将其初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br></pre></td></tr></table></figure>



<p>首先 <code>newDefaultThreadFactory())</code> 创建默认的线程工厂，有兴趣可以跟进去看看。然后再创建<code>ThreadPerTaskExecutor</code>线程 Executor 对象。（PS：这里创建的 Executor 就是 NioEventLoopGroup 内的 Executor 对象，并不是当前 NioEventLoopGroup  自身，可以称其为 <strong>总 Executor</strong>）。</p>
<p>然后可以看到这里创建了一个 children 数组，根据需要创建的线程数创建对应数量的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br></pre></td></tr></table></figure>



<p>因为每个 NioEventLoopGroup 都是 NioEventLoop 的集合，所以这里的 children 数组就是当前 NioEventLoopGroup 的 NioEventLoop。所以 NioEventLoop 的创建的实在 NioEventLoopGroup 初始化的时候。下面看 NioEventLoop 的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐个创建nioEventLoop实例</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建eventLoop</span></span><br><span class="line">        children[i] = newChild(executor, args);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 在创建这些eventLoop过程中，只要有一个创建失败，则关闭之前所有已经创建好的eventLoop</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 闭之前所有已经创建好的eventLoop</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                children[j].shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 终止所有eventLoop上所执行的任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                EventExecutor e = children[j];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                        e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                    <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>先整体看这段 NioEventLoop 的创建代码，可以看到整个过程中存在一个成功标志，catch 每个 NioEventLoop 创建完成过程，如果发生异常则将所有已经创建的 NioEventLoop 关闭。重点的代码也就在 NioEventLoop 的创建了。所以我们继续跟：<code>children[i] = newChild(executor, args);</code>往下走，直接找到 <code>io.netty.channel.nio.NioEventLoopGroup#newChild</code> ，因为当前是 NioEventLoopGroup 的创建，所以知道找到子类的 <code>newChild</code> 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">            ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>又将之前合并的 args 参数强转回来，继续跟进 NioEventLoop 构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="comment">// 创建一个selector的二元组</span></span><br><span class="line">    <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们先整体看下，将之前的默认参数初始化到 NioEventLoop 属性中。其中有两处：<code>openSelector()</code> 和 <code>super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler)</code>。这里先看父类构造：</p>
<p>往下跟，直接就是 SingleThreadEventLoop -&gt; SingleThreadEventExecutor 的初始化，这些也可以在 NioEventLoop 的继承体系可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.SingleThreadEventLoop#SingleThreadEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                RejectedExecutionHandler rejectedExecutionHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);</span><br><span class="line">    <span class="comment">// 创建一个收尾队列</span></span><br><span class="line">    tailTasks = newTaskQueue(maxPendingTasks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// io.netty.util.concurrent.SingleThreadEventExecutor#SingleThreadEventExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    RejectedExecutionHandler rejectedHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="comment">// 这是当前NioEventLoop所包含的executor</span></span><br><span class="line">    <span class="keyword">this</span>.executor = ThreadExecutorMap.apply(executor, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建一个任务队列</span></span><br><span class="line">    taskQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</span><br><span class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">&quot;rejectedHandler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里首先创建的是 SingleThreadEventExecutor ，这里重点需要关注的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.executor = ThreadExecutorMap.apply(executor, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>



<p>这里<code>this</code> 是 NioEventLoop ，所以<code>this.executor</code>就是前面说的 NioEventLoop 里的 Executor，这里我们先称为 <strong>子 Executor</strong>（子：对应的就是 NioEventLoop ，前面说的 总：对应的是 NioEventLoopGroup ）。</p>
<p>而这里  <strong>子 Executor</strong> 的初始化是由一个 <code>executor</code> 参数的，这个就是前面 NioEventLoopGroup 构造方法一直带入的 <strong>总 Executor</strong>。那我们继续往下跟，看看这个<strong>子 Executor</strong> 是如何完成的初始化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Executor <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Executor executor, <span class="keyword">final</span> EventExecutor eventExecutor)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(executor, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(eventExecutor, <span class="string">&quot;eventExecutor&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里创建的executor是子executor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">        <span class="comment">// 这个execute()是子executor的execute()</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable command)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里调用了NioEventLoopGroup所包含的executor的execute()</span></span><br><span class="line">            <span class="comment">// 即调用了“总的executor”的execute()</span></span><br><span class="line">            executor.execute(apply(command, eventExecutor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码细看就会明白，这里创建的 <strong>子 Executor</strong>的创建也就是一个线程的创建，但是重点却在这个线程 Executor 的 <code>execute()</code>方法实现，只做了一件事情：就是调用 传入的 <strong>总 Executor</strong> 的 <code>execute()</code>方法。所以这里 <strong>子 Executor</strong> 做的事情就是调用 <strong>总 Executor</strong> 的 <code>execute()</code>。不要觉得这里绕，因为这还只是初始化，后面这里执行会更绕。[手动捂脸哭]</p>
<p>其实这里的 <code>apply(command, eventExecutor)</code>，这里再执行 <strong>总 Executor</strong> 的 <code>execute()</code> 时还是会记录当前正在执行的线程，并且再执行完成时将当前记录值删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Runnable command, <span class="keyword">final</span> EventExecutor eventExecutor)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(command, <span class="string">&quot;command&quot;</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(eventExecutor, <span class="string">&quot;eventExecutor&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            setCurrentEventExecutor(eventExecutor);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                command.run();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                setCurrentEventExecutor(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里再 NioEventLoop 的属性 Executor 创建完成时，又去创建了一个普通任务队列<code>taskQueue = newTaskQueue(this.maxPendingTasks);</code>并且还创建了一个收尾任务队列<code>tailTasks = newTaskQueue(maxPendingTasks);</code>。这几个队列后面会说到。这里继续跟  NioEventLoop 主流程初始化。</p>
<p>到这我们再回去看看 <code>openSelector()</code>，这里我们要先知道 SelectorTuple ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorTuple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector unwrappedSelector;  <span class="comment">// NIO原生selector</span></span><br><span class="line">    <span class="keyword">final</span> Selector selector;  <span class="comment">// 优化过的selector</span></span><br><span class="line"></span><br><span class="line">    SelectorTuple(Selector unwrappedSelector) &#123;</span><br><span class="line">        <span class="keyword">this</span>.unwrappedSelector = unwrappedSelector;</span><br><span class="line">        <span class="keyword">this</span>.selector = unwrappedSelector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;</span><br><span class="line">        <span class="keyword">this</span>.unwrappedSelector = unwrappedSelector;</span><br><span class="line">        <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SelectorTuple 只是一个包含两个 Selector 的内部类，用于封装优化前后的 Selector。而 <code>openSelector()</code> 方法就是为了返回 Selector 并且根据配置判断是否需要优化当前 Selector 。下面看具体代码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9CXKbfIqhSSjLUJJxBcTvwSeLOD8UfbpX1OPGXlReABrZ79cticvgx3A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>而具体的优化过程有兴趣的可以自己去看看，这里只要知道，若是禁用了优化则 SelectorTuple 的优化后的 Selector 和为优化的 Selector 均为 Nio 原生的 Selector。</p>
<p>而这<code>io.netty.util.concurrent.MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, java.util.concurrent.Executor, io.netty.util.concurrent.EventExecutorChooserFactory, java.lang.Object...)</code>后面还有在 NioEventLoop 数组创建完成后，还有选择器创建和关闭监听器绑定等，感兴趣可以自己看看，这里不再介绍。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9ribZhTJF1icxGNmHAY8d6VDMZHQOwMBbstfib1F5gqYEeQia82DUPZVsicA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>到这一个 NioEventLoop 的创建过程的代码也全部看完了。我想如果只看这个肯定还是有点懵，源码这个东西需要自己跟进去去看，debug 一点点的跟，跟着运行的代码去想为何这么实现，不过这里我也画个图，让大家更直观的了解到 NioEventLoopGroup 的创建流程以及主要操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9ajSHIczOCHMVMAM8lRxLznMGQmPicC6icbZM3vMOichknZ5Ah7iaorMbyw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我想大家结合这个图，再结合上面的分析过程，最好可以自己找到源码，跟一遍，应该可以理解 NioEvnetLoopGroup 的创建。</p>
<h4 id="ServerBootstrap与-ServerBootstrap-属性配置分析"><a href="#ServerBootstrap与-ServerBootstrap-属性配置分析" class="headerlink" title="ServerBootstrap与 ServerBootstrap 属性配置分析"></a>ServerBootstrap与 ServerBootstrap 属性配置分析</h4><p>继承体系：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp97mfZagvPVrRWyKxS6hrXWgTNaY7cZBsxwkDmU8qPLHciacw4IQ0DwSQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>入口代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"><span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">// (非必备)打印日志</span></span><br><span class="line">    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">    <span class="comment">// 4.指定 IO 模型</span></span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ChannelPipeline p = ch.pipeline();</span><br><span class="line">            <span class="comment">//5.可以自定义客户端消息的业务处理逻辑</span></span><br><span class="line">            p.addLast(<span class="keyword">new</span> HelloServerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">bootstrap.group(eventLoopGroup)</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> SomeSocketClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<p>ServerBootstrap与 Bootstrap 都是启动配置类，唯一不同的是，ServerBootstrap是服务端的启动配置类，Bootstrap  则是客户端的启动配置类，主要用于绑定我们创建的 EventLoopGroup，指定 Channel 的类型以及绑定 Channel 处理器等操作，主要做的都是给 ServerBootstrap与 Bootstrap  的属性赋值操作，所以称其为配置类。可以进入 <code>group()</code> 方法里看一眼：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">if</span> (childGroup == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其他的方法也是一样，感兴趣可以自己进去看看。这里只是初始化，都是为了后面的操作做准备。</p>
<h4 id="服务端-bind-方法-ServerBootstrap-bind-源码解析"><a href="#服务端-bind-方法-ServerBootstrap-bind-源码解析" class="headerlink" title="服务端 bind 方法 ServerBootstrap.bind() 源码解析"></a>服务端 bind 方法 ServerBootstrap.bind() 源码解析</h4><p>这里我们从这里进入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.bind(port).sync();</span><br></pre></td></tr></table></figure>



<p>直接从 <code>bind()</code>方法跟进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.bootstrap.AbstractBootstrap#bind(int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续跟进</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 验证group与channelFactory是否为null</span></span><br><span class="line">    validate(); </span><br><span class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;localAddress&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里是一处重点逻辑</span></span><br><span class="line">    <span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里显示校验了 Bootstrap 的 group 与 channelFactory 是否绑定成功。然后继续跟进 <code>doBind()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建、初始化channel，并将其注册到selector，返回一个异步结果</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="comment">// 从异步结果中获取channel</span></span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="comment">// 若异步操作执行过程中出现了异常，则直接返回异步对象（直接结束）</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异步操作完成的情况（可能是正常结束，或发生异常，或任务取消，这些情况都属于有结果的情况）</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        <span class="comment">// 绑定指定的端口</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 处理异步操作尚未有结果的情况</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        <span class="comment">// 为异步操作添加监听</span></span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="comment">// 若异步操作具有了结果（即完成），则触发该方法的执行</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123; <span class="comment">// 异步操作执行过程中出现了问题</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 异步操作正常结果</span></span><br><span class="line">                    promise.registered();</span><br><span class="line">                    <span class="comment">// 绑定指定的端口</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先再这里，我们先把这个方法整体的逻辑搞清楚，然后再再去研究他的每一步具体的操作，画个图，先理解这个方法做了什么：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9TpbI5sEhBpdOPsnllcdIHYQV7MqBhjUiaRHG2OaRaYicF9AsibwZicgCAg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以在图中结合代码，找到整个 <code>dobind()</code> 的大局处理思路，然后呢，到这里我们还有很多重点细节需要继续跟进，也就是图中标记的 Tag 1、Tag 2。为了方便后面跟进去代码之后方便回来，这里以此标记，然后下面在具体分析 Tag 标记的源码：</p>
<blockquote>
<p><strong>补充 Tag 0 ：</strong></p>
<p>ChannelPromise 与 ChannelFuture 了解。</p>
<p><strong>Tag 1 ：</strong></p>
<p>异步创建、初始化channel，并将其注册到selector</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">final ChannelFuture regFuture</span> = initAndRegister();</span><br></pre></td></tr></table></figure>

<p><strong>Tag 2 ：</strong></p>
<p>绑定指定的端口号：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span><span class="constructor">Bind0(<span class="params">regFuture</span>, <span class="params">channel</span>, <span class="params">localAddress</span>, <span class="params">promise</span>)</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="补充-Tag-0：ChannelPromise-与-ChannelFuture"><a href="#补充-Tag-0：ChannelPromise-与-ChannelFuture" class="headerlink" title="补充 Tag 0：ChannelPromise 与 ChannelFuture"></a>补充 Tag 0：ChannelPromise 与 ChannelFuture</h5><p>ChannelPromise 是一个特殊的 ChannelFuture，是一个可修改的 ChannelFuture。内部提供了修改当前 Future 状态的方法。在 ChannelFuture 的基础上实现了设置最终状态的修改方法。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9uzE5OxgB9HykbTic2lZrWaicMvJVIdkcydOGw2AEBfLwUf96iaBd2fw6g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>而 ChannelFuture 只可以查询当前异步操作的结果，不可以修改当前异步结果的 Future 。这里需要知道的就是 ChannelPromise 可以修改当前异步结果的状态，并且在修改状态是会触发监听器。在 <code>doBind</code> 方法中主要用于在处理异步执行一直未结束的的操作，将异步结果存在异常的时，将异常赋值给 ChannelPromise 并返回。</p>
<h5 id="Tag-1-：initAndRegister-初始化并注册-Channel"><a href="#Tag-1-：initAndRegister-初始化并注册-Channel" class="headerlink" title="Tag 1 ：initAndRegister() 初始化并注册 Channel"></a>Tag 1 ：initAndRegister() 初始化并注册 Channel</h5><p>先找到代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建channel</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 初始化channel</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将channel注册到selector</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>嗯？！代码意一看，咋就这么点，也就做了三件事，可是这三件事做的每一个都不是一句代码的可以完成的。这里我们一个一个分析，除了这三件事情，其他的也就是异常后的处理逻辑，所以主流程就是下面的三句代码，也为了跟进继续打上标记吧：</p>
<blockquote>
<p><strong>Tag 1.1  创建channel</strong>channel = channelFactory.newChannel();</p>
<p><strong>Tag 1.2 初始化channel</strong>init(channel);</p>
<p><strong>Tag 1.3  将channel注册到selector</strong>ChannelFuture regFuture = config().group().register(channel);</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9bkdgbic4BrNBaMKdsXHOoKddIB2xVicibSX9YhOgr0cibRVEz9oabFF6LQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>针对这三处，还是要一处一处分析。</p>
<h6 id="Tag-1-1-channelFactory-newChannel-创建-Channel"><a href="#Tag-1-1-channelFactory-newChannel-创建-Channel" class="headerlink" title="Tag 1.1  channelFactory.newChannel()  创建 Channel"></a>Tag 1.1  channelFactory.newChannel()  创建 Channel</h6><p>找到对应的代码：<code>io.netty.channel.ReflectiveChannelFactory#newChannel</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用无参构造器创建channel</span></span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里为什么直接找到 ReflectiveChannelFactory ，需要提一下，在分析 ServerBootstrap与 Bootstrap 启动配置类的时候，设置 channel 的方法，跟进去可以找到针对属性 channelFactory 的赋值代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;channelClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到这里 new 的就是 ReflectiveChannelFactory 工厂类，然后再看 ReflectiveChannelFactory 的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(clazz, <span class="string">&quot;clazz&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将NioServerSocketChannel的无参构造器初始化到constructor</span></span><br><span class="line">        <span class="keyword">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) +</span><br><span class="line">                                           <span class="string">&quot; does not have a public non-arg constructor&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看到的是 ReflectiveChannelFactory 在创建时初始化了 constructor 属性，将传入的 channel 类 clazz 中获取构造赋值给了 ReflectiveChannelFactory 反射工厂的 constructor 属性。</p>
<p>而我们再 Server  端传入的 channel 类为<code>NioServerSocketChannel.class</code> ，所以上面看的 <code>constructor.newInstance();</code> 对应的也就是 NioServerSocketChannel 的无参构造。这样我们就继续跟进 NioServerSocketChannel ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NIO中的provider，其用于创建selector与channel。并且是单例的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DEFAULT_SELECTOR_PROVIDER 静态变量</span></span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>继续跟进 <code>newSocket()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="comment">// 创建NIO原生的channel =&gt; ServerSocketChannel</span></span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">            <span class="string">&quot;Failed to open a server socket.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>就是返回了一个 Java NIO 原生的 Channel，最后将 NIO 原生的Channel 包装成 NioServerSocketChannel，继续跟进 <code>this(newSocket(DEFAULT_SELECTOR_PROVIDER))</code> 找到有参构造具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：父channel</span></span><br><span class="line">    <span class="comment">// 参数2：NIO原生channel</span></span><br><span class="line">    <span class="comment">// 参数3：指定当前channel所关注的事件为  接受连接</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="comment">// 用于对channel进行配置的属性集合</span></span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里主要做了两件事情，1. 调用父类构造，2. 对 channel 进行配置属性集合。</p>
<p>这里先说下 new NioServerSocketChannelConfig()，这部操作就是给当前 Channel 的 config 进行赋值，用来保存当前 Channel 的属性配置的集合。好了，这个说了我们继续跟主线：<code>super(null, channel, SelectionKey.OP_ACCEPT)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.nio.AbstractNioMessageChannel#AbstractNioMessageChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioMessageChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, readInterestOp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// io.netty.channel.nio.AbstractNioChannel#AbstractNioChannel</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// 这里的this.ch为NIO原生channel</span></span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// NIO，非阻塞</span></span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                    <span class="string">&quot;Failed to close a partially initialized socket.&quot;</span>, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Failed to enter non-blocking mode.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>直接找到 AbstractNioChannel 父类构造，这也第一步也是调用父类构造 <code>super(parent);</code> 先记着，先看除了调用父类构造还做了什么事情：</p>
<blockquote>
<ol>
<li>调用父类构造 super(parent);</li>
<li>将前面创建的原生 Channel 复制给属性保存 this.ch = ch;</li>
<li>当前 channel 的关注事件属性赋值 this.readInterestOp = readInterestOp;  //  SelectionKey.OP_ACCEPT 接受事件</li>
<li>将 NIO 原生 Channel 设置为非阻塞 ch.configureBlocking(false);</li>
</ol>
</blockquote>
<p>在 AbstractNioChannel  构造中就做了这么四件事情，主要需要说的还是其调用父类构造又做了什么事情，找到代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.AbstractChannel#AbstractChannel(io.netty.channel.Channel)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="comment">// 为channel生成id，由五部分构成</span></span><br><span class="line">    id = newId();</span><br><span class="line">    <span class="comment">// 生成一个底层操作对象unsafe</span></span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    <span class="comment">// 创建与这个channel相绑定的channelPipeline</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 AbstractChannel 构造中主要做了三件事：</p>
<blockquote>
<ol>
<li>为当前 Channel 生成 id  <code>newId()</code>，感兴趣可以跟进去看看。</li>
<li>生成一个底层操作对象 unsafe，用于 I/O 线程调用传输时使用，用户代码无法调用。<code>newUnsafe()</code></li>
<li>创建与这个channel相绑定的channelPipeline，这也是一个重点操作，不过在这里先不展开细说，后面会单独细跟 channelPipeline 的代码。</li>
</ol>
</blockquote>
<p>所以到此 **Tag 1 : initAndRegister()  ** 中的 **Tag 1.1 newChannel() ** 创建 Channel 才算跟完。针对 <strong>Tag 1.1 newChannel()</strong> 我们也画图简图整理下思路：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9YDwOOiaiamhR9HAy2mibZ90wK7ttIRxaJGDuall9Hd8sec8UD05NlZgAA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>根据图，在结合上面代码的分析，最好自己再可以跟一遍代码，我想这一块的理解还是没什么问题的。到这也只是创建了 Channel。<strong>Tag 1.1 的 Channel 创建</strong>结束，接着跟进 <strong>Tag 1.2 init(channel)</strong>.</p>
<h6 id="Tag-1-2-init-channel-初始化-Channel"><a href="#Tag-1-2-init-channel-初始化-Channel" class="headerlink" title="Tag 1.2  init(channel)  初始化 Channel"></a>Tag 1.2  init(channel)  初始化 Channel</h6><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp954rkXagMlB19vGSykdVouKvB4GLabjMBtDoH5Ed0R39QvznMN9d4zA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里我们是从 ServerBootstrap 中的doBind 进入的，所以这里直接找到 <code>io.netty.bootstrap.ServerBootstrap#init</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取serverBootstrap中的options属性</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="comment">// 将options属性设置到channel</span></span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取serverBootstrap中的attrs属性</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">        <span class="comment">// 遍历attrs属性</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            <span class="comment">// 将当前遍历的attr初始化到channel</span></span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取channel的pipeline</span></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将serverBootstrap中所有以child开头的属性写入到局部变量，</span></span><br><span class="line">    <span class="comment">// 然后将它们初始化到childChannel中</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 将ServerBootstrapAcceptor处理器添加到pipeline</span></span><br><span class="line">                    <span class="comment">// ServerBootstrapAcceptor处理器用于接收ServerBootstrap中的属性值，</span></span><br><span class="line">                    <span class="comment">// 我们通常称其为连接处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里做的事情还是很多的，基本操作我在上面注释上也标注出来，还有一些需要继续跟下去的主要操作，还是先标记 <strong>Tag</strong> 然后继续跟下去。这里说一下这里的 options 与 attrs 属性的赋值，其实就是讲我们 ServerBootstrap 与  Bootstrap 在调用 <code>doBind()</code> 之前通过  <code>option()</code> 与 <code>attr()</code> 设置的参数值，其中 options  属性设置到了 Channel 的 config 属性中，attrs 是直接被设置在了 Channel 上的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9SxrV2VNcSZH2mbA0feSa2htcurRUGCvIYJRbMUJHRYarDcjYYVG9ZQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在设置完 options 属性与 attrs 属性时，接着获取了当前 channel 的 pipeline，接下来还是获取我们在 <code>doBind()</code> 之前设置的属性值，以 child 开头的方法 <code>childOption()</code> 与 <code>childAttr()</code> 设置的属性值。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp95d2jLgCo0U3tXG3swHLb47RQDTHcTuSiaHia1nEYy0tShytZGHvdlc4Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里使用局部变量记录了所有 Child 相关的值 <code>currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs</code> 主要用于初始化 childChannel 的属性，<code>new ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs))</code> 主要是创建 连接处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 将ServerBootstrapAcceptor处理器添加到pipeline</span></span><br><span class="line">                    <span class="comment">// ServerBootstrapAcceptor处理器用于接收ServerBootstrap中的属性值，</span></span><br><span class="line">                    <span class="comment">// 我们通常称其为连接处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先这里想做的事情是：将当前 channel 的 pipeline 中绑定一个初始化处理器 ChannelInitializer ，因为是抽象类，所以需要匿名实现 initChannel方法。而这些主要的操作是处理 childGroup 里面的 channel 的初始化操作。这里我只想主要讲一下这个连接处理器 ServerBootstrapAcceptor 主要做了什么，其他的具体会在后面的 handler 和 pipeline 的时候细说。</p>
<p><strong>补充：</strong>这里因为 ServerBootstrap 服务端是对用的有两个 EventLoopGroup，在服务端，parentGroup 是用于接收客户端的连接，在 parentGroup 接收到连接之后是将只是将当前转给了 childGroup去处理后续操作，而 childGroup 是用来专门处理连接后的操作的，不关心 channel 的连接任务。<strong>这个其实就是 Netty-Server 的 Reactor 线程池模型的处理逻辑。</strong></p>
</blockquote>
<p>这里主要往下说一下这个连接处理器：ServerBootstrapAcceptor 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrapAcceptor(</span><br><span class="line">    <span class="keyword">final</span> Channel channel, EventLoopGroup childGroup, ChannelHandler childHandler,</span><br><span class="line">    Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) &#123;</span><br><span class="line">    <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">    <span class="keyword">this</span>.childHandler = childHandler;</span><br><span class="line">    <span class="keyword">this</span>.childOptions = childOptions;</span><br><span class="line">    <span class="keyword">this</span>.childAttrs = childAttrs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/1328</span></span><br><span class="line">    enableAutoReadTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            channel.config().setAutoRead(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ServerBootstrapAcceptor  构造只是将 ServerBootstrap 中配置的 Child 属性设置保存下来。而这里一直说这是连接处理器，是因为当客户端连接发送到服务端时，这个处理器会接收客户端的连接并处理。主要是处理方法是 channelRead 中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// msg为客户端发送来的数据，其为NioSocketChannel，即子channel，childChannel</span></span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将来自于ServerBootstrap的child开头属性初始化到childChannel中（childHandler、childOptions、childAttrs）</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将childChannel注册到selector 需要注意的是，这里的selector与父channel所注册的selector不是同一个</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里主要就做了两件事情：</p>
<blockquote>
<ol>
<li>初始化 childChannel</li>
<li>将成功从 client 连接过来的 channel 注册到 selector 上。</li>
</ol>
</blockquote>
<p>这里一直说子channel，就是因为这里注册的是两个 EventLoopGroup，在 Server 端的处理上 netty 线程模型采用“服务端监听线程”和“IO线程”分离的方式。所以这里 <code>channelRead</code> 方法就是在 client 端请求连接到 server 端时，用于将当前连接的 IO 线程绑定到 childChannel 同时注册到 ChildGroup 中的 Selector 中。线程，模型可以参考下面的图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9viadrB4oMpBKjQu0ZTI7Mt6iblhQAtNiaH5yBywPgicnr2Viarq6t8rS6Ww/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>好了，到这里 **Tag 1.2 initChannel ** 代码也分析完了，有些关于 pipeline 、handler、selector 的部分没有细说因为后面会单独说，在这里没有直接展开。</p>
<p>这里也画个图：到时候将这些图在整合到一起，现在是的分析过程就像是化整为零，最后在整合到一起化零为整。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9VqkNzvAE5yCHzGtJSQFBbiaib6uxrAznsxugc4ibAt35ic3msH1wj6nKHA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里除了 init(channel) 方法之外，还主要说了下 ServerBootstrapAcceptor 连接处理器。其实主要是 netty-server 的线程模型与代码的结合理解。</p>
<h6 id="Tag-1-3-config-group-register-channel-将channel注册到selector"><a href="#Tag-1-3-config-group-register-channel-将channel注册到selector" class="headerlink" title="Tag 1.3  config().group().register(channel)  将channel注册到selector"></a>Tag 1.3  config().group().register(channel)  将channel注册到selector</h6><p>channle 注册到 Selector 的代码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">config().group().register(channel);</span><br></pre></td></tr></table></figure>



<p>config().group() ：这里就是 Bootstrap 的 EventLoopGroup，而这里是 Server 端的 ServerBootstrap 所以这个其实就是 parentGroup。那这里我们需要找到 register 的方法实现：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9J8eF6LTUFValXbyalsMaTudKGFyegiaXyibhR3JfkeicnGibrvpA4nGxXg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里因为 group 是 NioEventLoopGroup，根据 NioEventLoopGroup 的继承体系就可以直接找到 实现 <code>io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel)</code>。因为只有 MultithreadEventLoopGroup 在其继承体系中。所以找到代码我们继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next() 从eventLoop数组中选择一个eventLoop</span></span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里需要了解下 <code>next()</code> 方法，因为我们现在是 eventLoopGroup <code>next()</code> 就是从当前 group 中获取一个 EventLoop，然后这里在继续跟进需要找 EventLoop 继承体系中实现 register 方法的类：<code>SingleThreadEventLoop</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9IRHA7LbeicoJzfBo7deJPrUDtsK8icJCtibkicRQ8ff2SgrBgJ9jmGb0xQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 ChannelPromise 然后注册</span></span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----&gt; 这里继续调用 unsafe 的 register</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里调用的 unsafe 的 register 方法，在初始化 eventLoop 的时候说过这个 unsafe 的初始化。是我们直接跟进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">io.netty.channel.AbstractChannel.AbstractUnsafe#register</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对异常情况的处理</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;eventLoop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registered to an event loop already&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">            <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel与eventLoop的绑定就发生在这里，</span></span><br><span class="line">    <span class="comment">// 需要注意，这里的eventLoop还没有绑定线程，因为这个线程还没有创建</span></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="comment">// 判断当前线程与eventLoop所绑定线程是否是同一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行当前线程所绑定的eventLoop的execute(), 这个execute()会将参数任务写入到任务队列，并创建启动新的线程</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                <span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AbstractUnsafe#register:</p>
<ol>
<li>首先判断当前操作是否存在异常情况。</li>
<li>将 eventLoop 保存到 channel 的 eventLoop 的属性中（channel 与 eventLoop 的绑定），注意：这里的 eventLoop 里面还没有绑定 thread。</li>
<li>判断 EventLoop 的 thread 是否是当前线程：eventLoop.inEventLoop()。这里断点看一下，初始化的时候这里 eventLoop 中的 thread = null。所以这里返回 false。</li>
<li>执行当前线程绑定的 eventLoop 的 excute() 方法。执行传入的 runnable ，主要是做的是将参数任务写入到任务队列，并创建启动新的线程</li>
<li>runnable 中的 run 方法实现：register0(promise);</li>
</ol>
<p>这里标记三个 <strong>Tag</strong></p>
<p><strong>Tag 1.3.1  register0(promise)</strong> 也就是上面的第 5 步。</p>
<p><strong>Tag 1.3.2  eventLoop.excute() 执行分析</strong> 也就是上面的第 4 步。</p>
<p>**Tag 1.3.3  eventLoop.excute() 的 run 方法执行分析 ** 也就是 <strong>Tag 1.3.2</strong> 最后执行起来的 run 方法</p>
</blockquote>
<h6 id="Tag-1-3-1-register0-promise"><a href="#Tag-1-3-1-register0-promise" class="headerlink" title="Tag 1.3.1  register0(promise)"></a><strong>Tag 1.3.1  register0(promise)</strong></h6><p>直接跟进 <code>register0(promise);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();  <span class="comment">// 绑定</span></span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里其他操作感兴趣的自己可以进去看看，这边我们主要看 register 流程，直接找 <code>doRegister();</code> 的绑定代码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9pg8wNgnUPYOozx49Syrlx2gdFJ4VpJ00nBzu5ZoticoWww2gFDsbVnw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在这里进行了注册，将NIO原生channel注册到了NIO原生selector</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里就是 channel 注册 Selector 的代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionKey = java<span class="constructor">Channel()</span>.register(event<span class="constructor">Loop()</span>.unwrapped<span class="constructor">Selector()</span>, <span class="number">0</span>, this)</span><br></pre></td></tr></table></figure>

<ol>
<li>javaChannel()  ：这里获取原生的 Nio Channel，跟进去可以找到这里返回的是  AbstractNioChannel#ch 的 channel。在前面 NioEventGroup 初始化的时候说过这个 NIO Channel 的初始化的过程。</li>
<li>然后调用  NIO Channel  的 Regsiter 方法</li>
<li>Regsiter 方法中首先传入的是 unwrappedSelector 前面初始化的 selector 数组。第二个参数 0 ，就是当前监听的的事件， 0  表示不关注任何事件。为什么这里子 Channel 注册的是不关注任何事件？在前面看到的 Channel 注册一个指定的关注事件：<code>SelectionKey.OP_ACCEPT</code> 连接事件，那个 channel 是 Netty 封装的 channel，哪里监听了连接事件之后，只要关注客户端的连接，当 netty 封装的 channel 获取到连接就绪的 channel 的时候就可以拿到当前 channel 需要注册事件了，然后这个时候就可以指定 原生 NIO channel 的需要关注的事件。所以这里默认不关注任何事件就是为后续修改其需要关注指定类型的就绪事件。</li>
</ol>
</blockquote>
<p>到这里 <code>register0</code> 的方法说完。前面还有 EventLoop 的线程 thread 的事情没有说明白，也就是  eventLoop 的 excute() 方法执行过程做了什么，返回去找到代码：<code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p>
<h6 id="Tag-1-3-2-eventLoop-excute-执行分析"><a href="#Tag-1-3-2-eventLoop-excute-执行分析" class="headerlink" title="Tag 1.3.2  eventLoop.excute() 执行分析"></a>Tag 1.3.2  eventLoop.excute() 执行分析</h6><p>前面还有 EventLoop 的线程 thread 的事情没有说明白，也就是  eventLoop 的 excute() 方法执行过程做了什么，返回去找到代码：<code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刚刚往里面跟的是 register0 现在再说一下 execute </span></span><br><span class="line">eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>往下跟，找到 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code>， eventLoop 的父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前线程与eventLoop所绑定线程是否是同一个</span></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="comment">// 将任务添加到任务队列</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        <span class="comment">// 创建并启动一个线程</span></span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (removeTask(task)) &#123;</span><br><span class="line">                    reject = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reject) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先这个参数：**Runnable task ** 其实就是刚刚我们跟过的方法 <code>register0</code>.</p>
<ol>
<li>首先判断当前 inEventLoop();  当前线程是否是 EventLoop 中的 thtrad。这里还是 false。</li>
<li>将任务添加到任务队列。跟下去可以找到 <code>taskQueue.offer(task)</code> ，这里的 taskQueue 任务队列就在跟创建 eventLoop 时 newChild 中初始化创建的.</li>
</ol>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9kXMuhwBqoq4Vic5Kb3ds312a5MnhZmnbgtiavPEMxs4EzrP2Z3IJj7rw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<ol>
<li>inEventLoop = false。首先做的是：<code>startThread</code>.</li>
</ol>
</blockquote>
<p>继续跟进：<code>startThread()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若当前eventLoop所绑定线程尚未启动</span></span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建并启动一个线程</span></span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                STATE_UPDATER.set(<span class="keyword">this</span>, ST_NOT_STARTED);</span><br><span class="line">                PlatformDependent.throwException(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先判断当前 eventLoop 所绑定线程尚未启动，然后使用 CAS 修改当前线程的启动状态 ，修改成功则执行 <code>doStartThread()</code>创建并启动一个线程，继续跟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 调用NioEventLoop所包含的executor的execute()</span></span><br><span class="line">    <span class="comment">// 这个execute()会创建并启动一个线程</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行了一个不会停止的for，用于完成任务队列中的任务</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 省略......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里调用了 NioEventLoop 所包含的 executor 的 execute() 方法，也就是创建线程的逻辑，后面的具体执行逻辑，下一步部分具体看。传入了一个 Runnable。主要是执行了一个 <code>SingleThreadEventExecutor.this.run();</code> 线程，用于完成任务队列的任务。后面说。这里主要说一下这个 <code>executor.execute()</code>执行的过程。</p>
<p>这里跟进下面代码可以找到之前 <strong>子 Executor</strong> 的初始化创建的匿名内部类：<code>io.netty.util.internal.ThreadExecutorMap#apply</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Executor <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Executor executor, <span class="keyword">final</span> EventExecutor eventExecutor)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(executor, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(eventExecutor, <span class="string">&quot;eventExecutor&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable command)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里调用了NioEventLoopGroup所包含的executor的execute()</span></span><br><span class="line">            executor.execute(apply(command, eventExecutor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以 execute 方法执行的是这里的 <code>execute</code>方法：<code>executor.execute(apply(command, eventExecutor));</code></p>
<p>而在 ThreadExecutorMap 这里的 executor 之前在 NioEventLoopGroup 初始化的时候说了，这个 executor  是 NioEventLoopGroup 初始化过成功构造方法创建的 <strong>总 executor</strong>。然后 apply 方法又将传入的 runnable 包装成了一个新的 Runnable 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Runnable command, <span class="keyword">final</span> EventExecutor eventExecutor)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(command, <span class="string">&quot;command&quot;</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(eventExecutor, <span class="string">&quot;eventExecutor&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 做了线程隔离</span></span><br><span class="line">            setCurrentEventExecutor(eventExecutor);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                command.run();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                setCurrentEventExecutor(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>只是在执行 command 之前做了异步线程隔离的操作。所以到这里就是  <strong>总 executor</strong> 执行了传入了新包装的 runnable。然后我们继续跟进这里的 <code>executor.execute(apply(command, eventExecutor));</code> execute 方法。这里需要找到实现方法在这里：<code>io.netty.util.concurrent.ThreadPerTaskExecutor#execute</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并启动一个线程</span></span><br><span class="line">    threadFactory.newThread(command).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>threadFactory 也是之前 NioEventLoopGroup 初始化的线程工厂。这里主要用到这个 <strong>总 executor</strong> 里面的线程工厂来创建线程来着。而这里的 command 就是 apply() 返回的 runnable，也就是包装后的 doStartThread 中的匿名内部类 runnable。所以这里的线程 <code>newThread(command).start()</code> 的 start 就执行了commnnd 的 run 方法。最后就执行到 doStartThread 的里面的 run 方法。</p>
<p>所以到这里 EventLoop 中的 thread 的创建并且启动就都这里处理完成了。</p>
<p>这里也画个图说下这个调用过程：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp92PH2lCbsrbKqqibVQokpIsjj7mk86hLLe6xHjicAgJ6uvibpU6A7CThOw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>到这里我们的 eventLoop.excute() 中的创建线程并启动的流程看完了，那下面我们要单独说一下这个线程启动之后执行的 run 方法做了什么。主要就是详细说下 <code>threadFactory.newThread(command).start();</code> 这个线程启动执行执行的 run 代码的解析。</p>
<h6 id="Tag-1-3-3-eventLoop-excute-的-run-方法执行分析"><a href="#Tag-1-3-3-eventLoop-excute-的-run-方法执行分析" class="headerlink" title="Tag 1.3.3  eventLoop.excute() 的 run 方法执行分析"></a>Tag 1.3.3  eventLoop.excute() 的 run 方法执行分析</h6><p>入口还是从 <code>eventLoop.excute()</code> 中进去，也就是 eventLoop 的 run 方法执行分析，找到里面的匿名内部类的 runnable 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  对应的代码位置 io.netty.channel.AbstractChannel.AbstractUnsafe#register</span></span><br><span class="line">eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         register0(promise);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>



<p>跟进 execute() 找到 <code>startThread();</code> 在直接跟进 <code>doStartThread()</code>找到下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 调用NioEventLoop所包含的executor的execute() 这个execute()会创建并启动一个线程</span></span><br><span class="line">       executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               thread = Thread.currentThread();</span><br><span class="line">               <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                   thread.interrupt();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">               updateLastExecutionTime();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 执行了一个不会停止的for，用于完成任务队列中的任务</span></span><br><span class="line">                   SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                   success = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">// 省略。。。</span></span><br></pre></td></tr></table></figure>



<p>这段代码上面都跟过，这里就跳过直接找我们要看的代码：<code>SingleThreadEventExecutor.this.run();</code> 这里执行了一个无限循环的代码，用来一直完成任务队列中的任务：这找到实现代码 eventLoop 中的 run() ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 选择就绪的channel</span></span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.CONTINUE:    <span class="comment">// NioEventLoop不支持</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:  <span class="comment">// NioEventLoop不支持</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.SELECT:  <span class="comment">// SELECT = -1 能走到这里，说明当前任务队列中没有任务</span></span><br><span class="line">                        <span class="comment">// 进行阻塞式选择</span></span><br><span class="line">                        select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">                        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                            selector.wakeup();</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                rebuildSelector0();</span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 该变量用于设置“处理就绪channel的IO所使用的时间”与“处理任务队列中任务使用时间”的比例 该值为整型，不大于100</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 记录处理就绪channel的IO开始执行的时间点</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理就绪channel的IO</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 计算出处理就绪channel的IO所使用的时长</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    <span class="comment">// 执行任务队列中的任务</span></span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先我们整体上看一下这个方法。</p>
<ol>
<li>selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())</li>
<li>switch - case</li>
<li>processSelectedKeys()</li>
<li>runAllTasks()</li>
</ol>
<p><strong>Tag 1.3.3.1</strong>：selectStrategy.calculateStrategy</p>
<p><strong>Tag 1.3.3.2</strong> ：switch - case</p>
<p><strong>Tag 1.3.3.3</strong> ：processSelectedKeys()</p>
<p><strong>Tag 1.3.3.4</strong> ：runAllTasks()</p>
</blockquote>
<h6 id="Tag-1-3-3-1：selectStrategy-calculateStrategy"><a href="#Tag-1-3-3-1：selectStrategy-calculateStrategy" class="headerlink" title="Tag 1.3.3.1：selectStrategy.calculateStrategy"></a><strong>Tag 1.3.3.1</strong>：selectStrategy.calculateStrategy</h6><p>首先找到代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line"></span><br><span class="line"><span class="comment">// hasTasks  tailTasks 收尾任务队列</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hasTasks() || !tailTasks.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// super.hasTasks()   taskQueue 普通任务队列</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> !taskQueue.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先看到 <code>hasTask</code> : 返回当前任务队列和收尾队列是否有任务。<code>selectNowSupplier</code> : 匿名内部类<code>io.netty.util.IntSupplier</code></p>
<p>继续跟进：calculateStrategy：<code>io.netty.channel.DefaultSelectStrategy#calculateStrategy</code> 初始化的默认选择器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SelectStrategy.SELECT = -1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里就是如果存在任务则走选择器 <code>selectSupplier.get()</code> 否则直接返回 <code>-1:SELECT</code> 。</p>
<p>继续跟 get 的任务选择逻辑：selectSupplier : NioEventLoop 中的内部类 IntSupplier</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> selectNow();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// io.netty.channel.nio.NioEventLoop#selectNow</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> selector.selectNow();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// restore wakeup state if needed</span></span><br><span class="line">        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>selector.selectNow() : 方法为 NIO 的非阻塞选择，返回就绪的 channel 的数量，可以为 0。</p>
<p>补充：Selector 的阻塞选择和非阻塞选择的区别就是，非阻塞选则在当前 select 方法执行时判断循环判断所有的 channel 是否就绪并返回所有的就绪数量，而阻塞式选择则是阻塞指定时间直至阻塞时间内获取到就绪 channel 或者阻塞时间超时时立刻返回。</p>
</li>
<li><p>wakenUp.get() ：返回当前线程是否被阻塞，没有被阻塞时返回 true，当前线程被阻塞返回 false。</p>
</li>
<li><p>selector.wakeup() ：当前线程如果被阻塞，则立刻返回 selector 结果，即唤醒当前线程。</p>
</li>
</ol>
<p>这是 selectNow() 方法执行的结果，是一个必然大于等于 0 的结果。</p>
</blockquote>
<p>所以返回 <code>calculateStrategy</code> 方法：如果任务队列存在任务，则通过 Selector 执行非阻塞选择返回就绪的 channel 数量，如果不存在任务，则直接返回 -1。</p>
<h6 id="Tag-1-3-3-2-：switch-case"><a href="#Tag-1-3-3-2-：switch-case" class="headerlink" title="Tag 1.3.3.2 ：switch - case"></a><strong>Tag 1.3.3.2</strong> ：switch - case</h6><p>现在在返回去看 switch - case 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">    <span class="keyword">case</span> SelectStrategy.CONTINUE:    <span class="comment">// -2 NioEventLoop不支持 </span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:  <span class="comment">// -3 NioEventLoop不支持</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">case</span> SelectStrategy.SELECT:  <span class="comment">// -1 能走到这里，说明当前任务队列中没有任务</span></span><br><span class="line">        <span class="comment">// 进行阻塞式选择</span></span><br><span class="line">        select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为再 <code>selectStrategy.calculateStrategy</code> 方法中，不可能返回 -2 和 -3。所以 case 的结果只可能走到  SelectStrategy.SELECT 或者直接 default。而只有当所有任务队列中都没有任务的时候才会返回 -1。也就意味着当任务队列中没有任务时也会景行一次阻塞式选择，通过 <code>wakenUp.getAndSet(false)</code> 方法将当前线程设置为阻塞状态。然后就阻塞式 select。</p>
</blockquote>
<p>这里我们具体去看看这 select 阻塞选择的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 计数器：用于记录空轮询导致CPU占用率飙升，select()提前结束的次数（其值大于1时）</span></span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取当前时间，也就是for循环第一次开始执行的时间点</span></span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">// delayNanos() 表示定时任务队列中第一个定时任务还有多久就到开始执行的时间了</span></span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 处理小于0.5毫秒的任务</span></span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 该条件为true，表示具有立即需要执行的定时任务</span></span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;  <span class="comment">// 只有第一次for循环才会执行下面的“非阻塞选择”</span></span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line">            <span class="comment">// 若有就绪的channel了，则直接结束</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若当前线程被中断</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前时间</span></span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="comment">// 下面的式子等价于：  time - currentTimeNanos &gt;= timeoutMillis</span></span><br><span class="line">            <span class="comment">// 若下面的条件成立，则说明select()是在指定的阻塞时间过期后才跳出的，即正常结束的</span></span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                <span class="comment">// timeoutMillis elapsed without anything selected.</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                       selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                selector = selectRebuildSelector(selectCnt);  <span class="comment">// 重构selector</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本轮for循环结束时间点，同时也是下一轮for循环的开始时间点</span></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个方法直接画图解释把：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9uANjLzcicxHnCEMt1SicJMiaj0CpibAGPpz7icwTicVD45sowEj6B9qe3lzg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>而在 switch-case 唯一的代码逻辑也就是在任务队列中没有任务时执行的阻塞 select，而在其他的任何情况下或者阻塞选择存在就绪 channel 或者任务队列新增任务之后都会跳出 switch - case，执行后续逻辑。</p>
<h6 id="Tag-1-3-3-3-：processSelectedKeys"><a href="#Tag-1-3-3-3-：processSelectedKeys" class="headerlink" title="Tag 1.3.3.3 ：processSelectedKeys()"></a>Tag 1.3.3.3 ：processSelectedKeys()</h6><p>首先我要说的时这个 <code>processSelectedKeys</code> 方法时处理就绪的 channel 的 IO，而代码逻辑走到这里其实并不一定就有已经就绪的 channel，因为看了上面的逻辑会发现代码任务处理为先，而存在任务就会走到这里逻辑，虽然在走到这里之前也执行了 select 的 channel 但是也都是去查看一遍是否存在就绪 channel，所以这里看下面的逻辑需要先有这个理解，最后我们再具体看 <code>processSelectedKeys</code> 代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio; <span class="comment">// 默认值 50</span></span><br><span class="line"><span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        processSelectedKeys();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">        runAllTasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 记录处理就绪channel的IO开始执行的时间点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理就绪channel的IO</span></span><br><span class="line">        processSelectedKeys();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 计算出处理就绪channel的IO所使用的时长</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">        <span class="comment">// 执行任务队列中的任务</span></span><br><span class="line">        runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段代码的整体逻辑再我们看完 runAllTasks 之后再分析，这里存在一个 io 处理与 task 处理的时间分配逻辑。后面再看，这里继续跟进 <code>processSelectedKeys</code></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void process<span class="constructor">SelectedKeys()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断channel的selectedKeys是否是优化过的</span></span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != null) &#123;</span><br><span class="line">        process<span class="constructor">SelectedKeysOptimized()</span>;  <span class="comment">// 优化处理方式</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process<span class="constructor">SelectedKeysPlain(<span class="params">selector</span>.<span class="params">selectedKeys</span>()</span>);  <span class="comment">// 普通处理方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里，代码有限判断了当前是否启用的 selectedKey 的优化，再 NioEventLoopGroup 的时候说过，优化就是将selectedKeys 的 set 集合转换成了数组，而再这里也可以得到验证，<code>selectedKeys</code>直接产看这个属性就可以看到，这里不进去看了，感兴趣进去看看。然后针对优化和非优化的处理唯一的区别就是处理的 <code>selectedKeys</code>对象是数组还是集合。这里直接分析 <code>processSelectedKeysOptimized</code> 方法，<code>processSelectedKeysPlain</code> 方法可以自己看，一样的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="comment">// 从数组中取出一个元素</span></span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">     <span class="comment">// 移除已经取出的 SelectionKey，使 GC 可以处理到已经关闭的 channel</span></span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取selectionKey的附件，该附件中可以存放任意数据，不过这里存放的是NIO原生channel</span></span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);  <span class="comment">// 处理就绪事件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task); <span class="comment">// 这里是测试代码。跟进去可以看到实现方法是测试类</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 省略......</span></span><br></pre></td></tr></table></figure>



<p>这里就是直接轮询 selectedKeys 的集合，每取出一个 selectKey 都会在原数组中移除当前元素，就是为了当 channel 关闭后， GC 可以释放当前 channel 占用的内存。</p>
<p>然后获取 selectKey 中保存的 Nio 原生的 channel，处理就绪后逻辑：<code>processSelectedKey</code> 继续跟进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="comment">// 处理selectionKey失效的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        <span class="keyword">final</span> EventLoop eventLoop;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop = ch.eventLoop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop != <span class="keyword">this</span> || eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">  <span class="comment">// 判断当前 channnel 就绪的事件类型</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取当前selectionKey的interestOps</span></span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            <span class="comment">// 先将SelectionKey.OP_CONNECT按位取或，再与ops进行按位与</span></span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            <span class="comment">// 将修改过的ops再写入到selectionsKey中</span></span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            <span class="comment">// 连接server</span></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理写就绪的情况</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 强制刷新（将user buffer中的数据写入到网关缓存）</span></span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// readyOps为0表示当前没有任何channel就绪</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将网卡缓存中的数据写入到user buffer</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段逻辑就是处理就绪 channel 的 IO 事件的逻辑。</p>
<ol>
<li><p>判断当前 SelectionKey 是否有效。失效结束处理并关闭资源。</p>
</li>
<li><p>判断当前 channel 的关注事件，针对处理：获取 SelectionKey 的 readyOps。这里的判断逻辑都是使用高效的位运算。readyOps 为当前 SelectionKey 的就绪的事件类型。</p>
</li>
<li><p>(readyOps &amp; SelectionKey.OP_CONNECT) != 0 ：连接就绪事件</p>
<p>这个事件在 server 端不会关注，只有 client 用来连接 server 时才会关注连接就绪事件。</p>
<p>连接就绪后，获取当前 SelectionKey 的 interestOps 值，将当前 interestOps 值修改后，调用底层 unsafe 连接server</p>
</li>
<li><p>(readyOps &amp; SelectionKey.OP_WRITE) != 0 ：写就绪事件</p>
<p>当前 channel 关注的是写就绪事件，此时写操作已经就绪，所以直接调用unsafe将数据写入的网卡缓存。</p>
</li>
<li><p>(readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0 ：当前channel 关注的是读就绪事件，或者前面因为有新增任务而触发的就绪 channel 处理逻辑，只有因为任务触发的情况下 readyOps  才可能会是 0 ，readyOps  = 0 意味着没有就绪 channel。</p>
<p>直接调用 unsafe 继续读操作，将网卡缓存的数据读取到用户空间。如果是 readyOps = 0 的情况相当于网卡缓存并没有就绪数据，则时进行的读操作不会读取到数据。</p>
</li>
</ol>
</blockquote>
<p>这就是完整的 IO 处理逻辑，主要根据当前 channel 关注的事件进行相应的 unsafe 操作。</p>
<h6 id="Tag-1-3-3-4-：runAllTasks"><a href="#Tag-1-3-3-4-：runAllTasks" class="headerlink" title="Tag 1.3.3.4 ：runAllTasks()"></a><strong>Tag 1.3.3.4</strong> ：runAllTasks()</h6><p>下面我们在看下 <code>runAllTask</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从定时任务队列中取出所有当前马上就要到期的定时任务放入到任务队列</span></span><br><span class="line">    fetchFromScheduledTaskQueue();</span><br><span class="line">    <span class="comment">// 从任务队列中取出一个任务</span></span><br><span class="line">    Runnable task = pollTask();</span><br><span class="line">    <span class="comment">// 若该任务为空，则说明任务队列中已经没有任务了，此时就可以执行收尾任务了</span></span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行收尾队列中的收尾任务</span></span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">long</span> runTasks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        safeExecute(task);</span><br><span class="line">        runTasks ++;</span><br><span class="line">        <span class="comment">// 每64个任务查看一次超时</span></span><br><span class="line">        <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从任务队列中再取出一个任务</span></span><br><span class="line">        task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end-for</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理收尾队列中的任务</span></span><br><span class="line">    afterRunningAllTasks();</span><br><span class="line">    <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>画图理解一下这个方法：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9gV53SnMjcjfarBcJxiaoe8LJRibnC2UiacichrYiavLldLq8ORSQiaCQxUow/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里面有几个方法大家感兴趣可以进去看看：这部分逻辑不复杂，大家可以自己研究下。</p>
<blockquote>
<ol>
<li><p>fetchFromScheduledTaskQueue()</p>
<p>io.netty.util.concurrent.SingleThreadEventExecutor#fetchFromScheduledTaskQueue</p>
<p>从定时任务队列中取出所有当前马上就要到期的定时任务放入到任务队列</p>
</li>
<li><p>pollTask()</p>
<p>io.netty.util.concurrent.SingleThreadEventExecutor#pollTask</p>
<p>从任务队列中取出一个任务</p>
</li>
<li><p>afterRunningAllTasks()</p>
<p>io.netty.util.concurrent.SingleThreadEventExecutor#afterRunningAllTasks</p>
<p>执行收尾任务队列中的所有收尾任务</p>
</li>
<li><p>safeExecute(task)</p>
<p>io.netty.util.concurrent.AbstractEventExecutor#safeExecute</p>
<p>执行任务</p>
</li>
</ol>
</blockquote>
<p>到此我们的 channel 的 initAndRegister 介绍完成，并且介绍了 channel 就绪后的执行方法 eventLoop 的 execute 调用的 run 方法的逻辑。其实 run 方法不是说注册初始化的时候就调用的，而是通过任务或者就绪 channel 触发的，只是注册时候说到这个代码就直接跟完这个逻辑，让大家也好理解一点。</p>
<h5 id="Tag-2-doBind0-绑定端口号"><a href="#Tag-2-doBind0-绑定端口号" class="headerlink" title="Tag 2  doBind0()  绑定端口号"></a>Tag 2  doBind0()  绑定端口号</h5><p>先看一下面需要跟踪的代码在哪里，上面饶了一个圈，现在回来先看看回到哪里，不然都不知道自己是谁，自己在哪。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9E2t34XsSASSk3BIlGz1seqqbIOG6Qn6iboovT1tUvGMmzR1TAoKicORQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9mXIlGiavpL0k5FQEMnb2yVespr0M0HKwJO5OLWkAotlCTafOqjwdiczg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>找到 <code>doBind0</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;  <span class="comment">// 只有当channel初始化注册成功后，才会进行绑定</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果初始化失败，则直接返回失败，我们这里跟正确逻辑，直接跟 <code>channel.bind</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里不多少直接进去，继续探索：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一样。继续探索：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    。。。。</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_BIND);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeBind(localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeBind(localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, promise, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里涉及到 pipeline 的逻辑后面细说，这里我们直接去看看一下 bind 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyOutboundHandlerException(t, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里找到 bind 实现：<code>io.netty.channel.DefaultChannelPipeline.HeadContext#bind</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>继续跟进：<code>unsafe.bind</code> : <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前channel是否被激活。注意，现在还没有被激活，所以其值为false</span></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 绑定</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();  <span class="comment">// 触发重写的channelActivate方法的执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最终找到 AbstractUnsafe 中找到最终调用的 doBind 方法，在调用前又获取了当前 channel 是否被激活，若已经激活则触发 pipeline 的 <code>fireChannelActive</code> 方法执行。这个都在 pipeline 再具体细说。当 channel 没有被激活时才去调用 NIO 原生的channel 进行绑定。代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>javaChannel()</code> 即获取 NIO 原生 channel 的方法，再获取到 NIO 原生 channel 之后调用 bind 方法完成绑定。</p>
<p>绑定 <code>bind</code> 方法我们就先初步了解最终怎么完成绑定的，要清楚到最后完成 bind 的依然是 NIO 的 channel。关于 pipeline 也是 netty 的一块重点，后面我们再细说。</p>
<p>这边完整的 server 启动初始化到启动的代码我们跟完了，现在可以类比这再把 client 的代码跟一遍，不过现在再看 client 的代码，会有很多不同的理解出来也应该会有很多原来如此的理解吧。</p>
<h4 id="Client-端启动分析"><a href="#Client-端启动分析" class="headerlink" title="Client 端启动分析"></a>Client 端启动分析</h4><p>上面我们跟完了 Server 端的代码初始化到启动分析，下面我们在跟下 Client 端的代码，这两部分有重复代码有相同的逻辑也有不同的地方。从启动类就可以看到他们是有区别的，但是上面理解了在看下面这个会容易很多。第一步找到代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    bootstrap.group(eventLoopGroup)</span><br><span class="line">        .channel(NioSocketChannel.class)</span><br><span class="line">        .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> SomeSocketClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    ChannelFuture future = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>).sync();</span><br><span class="line">    future.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(eventLoopGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        eventLoopGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>创建  NioEventLoopGroup，这个因为和 Server 端是一样的，所以这里不在分析。</li>
<li>初始化 Bootstrap 启动配置类，配置启动参数，这个在上面 Server 端的 Bind 方法分析的时候，也有看到都是在哪里使用这个配置的属性的。这里也不细说。</li>
<li>客户端启动，也就是：<code>bootstrap.connect</code>，这里就是与 Server 端的主要区别。在 Server 端是启动一个服务端服务，使用的是 bind 绑定当前机器的端口，对外暴露服务，而在 Client 端就是主动去连接 Server 端，与服务器建立连接。所以这里是 connect。这里我们主要跟进去看看这个方法</li>
</ol>
</blockquote>
<h5 id="Bootstrap-connect-分析："><a href="#Bootstrap-connect-分析：" class="headerlink" title="Bootstrap.connect() 分析："></a>Bootstrap.connect() 分析：</h5><p>先找到 Bootstrap 的代码，跟进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connect(InetSocketAddress.createUnresolved(inetHost, inetPort));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;remoteAddress&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证bootstrap的group、channelFactory与handler是否为空</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="comment">// 解析并连接地址</span></span><br><span class="line">    <span class="keyword">return</span> doResolveAndConnect(remoteAddress, config.localAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>InetSocketAddress.createUnresolved</code> 将输入的连接地址和端口号保存创建创建 InetSocketAddress 对象返回。</p>
<p><code>validate()</code> 方法主要校验 bootstrap 的必须配置是否为空：group、channelFactory与handler是否为空。</p>
<p>然后调用 <code>doResolveAndConnect</code> 方法建立连接</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建、初始化并注册channel</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="comment">// 若channel注册完毕</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!regFuture.isSuccess()) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析并连接server端地址</span></span><br><span class="line">        <span class="keyword">return</span> doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    doResolveAndConnect0(channel, remoteAddress, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码我想你看到之后应该很眼熟，这里如果抛开 <code>doResolveAndConnect0</code> 方法不看，其他的逻辑可以说是与 Server 端的 bind 方法跟进去看到的是一样的。首先通过异步的方式初始化并注册 channel，然后获取异步结果，判断是否异常，处理异常情况。没有异常，判断当前异步方法是否结束，如果结束根据结束的状态处理结束的逻辑，因为结束可以是正常也可以是异常结束。如果是异步结果一直没有结果，那就建立监听，监听异步结果返回时，触发最终逻辑。</p>
<p>这里我们也会将当前方法跟进去说一遍，但是只会细说与 Server 端不同的地方。</p>
<p>按照 Server 端的介绍模式，这里分成三段详细介绍</p>
<p><strong>Tag 1：initAndRegister();</strong></p>
<p><strong>Tag 2：doResolveAndConnect0(channel, remoteAddress, localAddress, promise);</strong></p>
</blockquote>
<h5 id="Tag-1：initAndRegister-分析"><a href="#Tag-1：initAndRegister-分析" class="headerlink" title="Tag 1：initAndRegister() 分析"></a>Tag 1：initAndRegister() 分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建channel</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 初始化channel</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span></span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将channel注册到selector</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里调用的 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code> 的方法与 Server 端调用的完全一样。我们h还是把当前方法分成三部分然后一个一个细说：</p>
<p><strong>Tag 1.1：channelFactory.newChannel();</strong></p>
<p><strong>Tag 1.2：init(channel);</strong></p>
<p><strong>Tag 1.3：config().group().register(channel);</strong></p>
</blockquote>
<h6 id="Tag-1-1-newChannel-分析"><a href="#Tag-1-1-newChannel-分析" class="headerlink" title="Tag 1.1 newChannel() 分析"></a>Tag 1.1 newChannel() 分析</h6><blockquote>
<p>首先在这里不一样的是 Bootstrap 的启动配置类传入的 channel  是 <code>.channel(NioSocketChannel.class)</code>。而在 Server 端传入的 <code>NioServerSoucketChannel</code> 。</p>
<p>所以在 Client 端 channelFactory 调用的则是 NioSocketChannel 的无参构造来初始化创建 channel。所以这里直接找到 NioSocketChannel 的构造方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DEFAULT_SELECTOR_PROVIDER：全局唯一的provider，通过它可以创建出selector与channel</span></span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_SELECTOR_PROVIDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续跟进 this</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(newSocket(provider));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这里调用了 newSocket(provider) 方法。主要是创建了原生的 SocketChannel ，<code>provider.openSocketChannel()</code> 。初始化 Nio 原生的 channel 之后，就是创建 Netty 包装的 channel 的过程了。</p>
</blockquote>
<p>继续往后跟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, socket);</span><br><span class="line">    config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里的 <code>new NioSocketChannelConfig(this, socket.socket())</code> 与 Server 端一样，此处就不再跟。我们直接跟 super(parent, socket) ：点击去找到 <code>io.netty.channel.nio.AbstractNioByteChannel#AbstractNioByteChannel</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第三个参数： 指定关注事件为读事件 OP_READ</span></span><br><span class="line">    <span class="keyword">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里就出现了与 Server 端不一样的地方了。不知道大家还记得在 Server 端创建 channel 的时候，指定的关注事件是什么，直接贴上代码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9ImfiavF7Ph2Qnl45zmMB4K1SNWYIFEjcgbTkkm0QBWxWCTdgdX08RVg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当时跟 Server 端注册 channel 时关注就的是 OP_ACCEPT，而在 Client 端创建的 channel 变成了关注的事件为 OP_READ 事件，因为当 Client 连接 Server 完成时，会由 Server 端通知 Client 端连接成功，所以此时 Client 直接注册 OP_READ 使事件来监听来自 Server 的返回。</p>
<p>然后下面的 super 的代码与 server 端的是同一个父类 <code>io.netty.channel.nio.AbstractNioChannel#AbstractNioChannel</code> 。所以后面的代码是与 Server 端一样。如果忘了可以往上翻翻，找到 Server 端的 newChannel 方法就可以看到。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9hBE1pNZibiccgksjZQPJ6r4icmQg2UZ5HhaZqqtm0c4TVeYcbyHGQfA1g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h6 id="Tag-1-2-init-channel-分析"><a href="#Tag-1-2-init-channel-分析" class="headerlink" title="Tag 1.2  init(channel) 分析"></a>Tag 1.2  init(channel) 分析</h6><p>上面跟完了 client 端的 channel  创建，接着就是看 channel 的初始化。同样是先找到代码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9rMpZVEHKFYInR7tp0xLYeKBAapRxEyqnu7ATRFjQKEttibWq2rH5KWg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>因为这是 Client，启动类是 Bootstrap。所以找到对应方法：这也是与 Server 端的区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    <span class="comment">// 将bootstrap中创建的ChannelInitializer处理器添加到pipeline</span></span><br><span class="line">    p.addLast(config.handler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将bootstrap中的options初始化到channel</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将bootstrap中的attrs初始化到channel</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            channel.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里可以明显看到与 Server 端的 init 方法相比，做的事情要少很多。首先将 Bootstrap 配置传入的 handler  添加到 channel 的 pipeline 中 <code>p.addLast(config.handler());</code>。然后将 bootstrap 中配置的 attr 和 options 的属性值初始化到 channel 中。</p>
</blockquote>
<p>这里稍微比较下 Client 端和 Server 端的 init 方法区别：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9A8yeZ2dmTSh1c2yBWYglf3dCrs85rpWRAdK4PsehsILpblOKn1mrXA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以看到当时再 Server 端我们不仅处理了 ParentGroup 的属性初始化，还初始化了以 Child 开头的 ChildGroup 的属性初始化，而再 Server 端是获取 pipeline 将传入的 childHandler 再次注册成一个新的 hanndler 然后添加到当前的 pipeline 中。再 Clinet 端则是直接将配置类传入的 handler 添加到 pipeline。这就是两边主要的区别，也就是因为 Server 传入的是两个 NioEventLoopGrou 才有的处理逻辑上的区别。也就是Server 端使用的是 Reactor 线程池模型，而Client 使用的 Reactor 模型。</p>
<p>Netty-Client 端的 Reactor 模型：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9oS9ynMmfdHamXP5W0mdm4xC8ciab8czDb9d8duuExPFvRBicQfJxA8yQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所以因为选择模型的区别，再处理逻辑上也有区别。</p>
<h6 id="Tag-1-3-register-channel-分析"><a href="#Tag-1-3-register-channel-分析" class="headerlink" title="Tag 1.3  register(channel)  分析"></a>Tag 1.3  register(channel)  分析</h6><p>这部分就完全与 Server 端一致，所以这里也不再啰嗦。不明白的可以直接翻到前面就可以看到。不在赘述。</p>
<h5 id="Tag-2：doResolveAndConnect0-分析"><a href="#Tag-2：doResolveAndConnect0-分析" class="headerlink" title="Tag 2：doResolveAndConnect0 分析"></a>Tag 2：doResolveAndConnect0 分析</h5><p>上面 Client 端的 channel 初始化与注册也看了一遍。下面我们继续看 <code>doResolveAndConnect0</code> 方法：<code>io.netty.bootstrap.Bootstrap#doResolveAndConnect0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doResolveAndConnect0</span><span class="params">(<span class="keyword">final</span> Channel channel, SocketAddress remoteAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> EventLoop eventLoop = channel.eventLoop();</span><br><span class="line">        <span class="comment">// 创建一个地址解析器，其中包含一个地址格式匹配器</span></span><br><span class="line">        <span class="keyword">final</span> AddressResolver&lt;SocketAddress&gt; resolver = <span class="keyword">this</span>.resolver.getResolver(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若解析器不支持该地址 或 该地址已经解析过了，则直接对该地址进行连接，</span></span><br><span class="line">        <span class="comment">// 返回可修改的promise，即成功了就成功，失败了则promise中有失败信息</span></span><br><span class="line">        <span class="keyword">if</span> (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) &#123;</span><br><span class="line">            doConnect(remoteAddress, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以异步方式解析server地址</span></span><br><span class="line">        <span class="keyword">final</span> Future&lt;SocketAddress&gt; resolveFuture = resolver.resolve(remoteAddress);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resolveFuture.isDone()) &#123;  <span class="comment">// 处理解析完成的情况（成功或异常）</span></span><br><span class="line">            <span class="keyword">final</span> Throwable resolveFailureCause = resolveFuture.cause();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resolveFailureCause != <span class="keyword">null</span>) &#123;  <span class="comment">// 若异步解析中出现了问题，则直接关闭channel</span></span><br><span class="line">                channel.close();</span><br><span class="line">                promise.setFailure(resolveFailureCause);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 处理异步解析成功的情况</span></span><br><span class="line">                <span class="comment">// resolveFuture.getNow() 从异步对象中获取解析结果，即解析过的地址</span></span><br><span class="line">                doConnect(resolveFuture.getNow(), localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resolveFuture.addListener(<span class="keyword">new</span> FutureListener&lt;SocketAddress&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;SocketAddress&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (future.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                    promise.setFailure(future.cause());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    doConnect(future.getNow(), localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">        promise.tryFailure(cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>doResolveAndConnect0</code> 方法我们直接画个图看下逻辑流程，具体的需要我们细看的时 <code>doConnect</code> 的连接方法。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp94qtMU0SIvubLYLlvU6wZ7trrTwBAww4Tvu2f3D3scPXxJpiavHhGiaicg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>下面我们继续跟 doConnect 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise connectPromise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Channel channel = connectPromise.channel();</span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">                channel.connect(remoteAddress, connectPromise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.connect(remoteAddress, localAddress, connectPromise);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 为promise添加一个异常监听器。连接过程发生异常，则关闭channel</span></span><br><span class="line">            connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里获取 channel 中绑定的 EventLoop 调用 execute 方法，上面关于 channel 的注册绑定流程大家还有印象没？这里调用的代码就是下面这段：<code>SingleThreadEventExecutor#execute</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9PqwwzCVFe0xJVia9H67M3UtaKpvsCibXicxkWOkaZ0LLiclgr4PRRYoyPg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>做的事情就是添加任务，因为当前的线程就是 eventLoop ，所以 !inEventLoop == false。在这里的逻辑只是添加任务。上面在介绍的 channel 绑定注册时候走的逻辑还有启动线程，在这里连接的时候相当于线程已经启动，这里只是添加任务，最后任务会在前面介绍的 run 方法里面执行（<strong>Tag 1.3.3  eventLoop.excute() 的 run 方法执行分析</strong>）。</p>
<p>这里就直接看这个匿名内部内的方法，继续跟 connect 方法：<code>io.netty.channel.AbstractChannel#connect(java.net.SocketAddress, java.net.SocketAddress, io.netty.channel.ChannelPromise)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过 pipeline 进行连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>pipeline 获取为节点进行调用连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;remoteAddress&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// cancelled</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找要处理该请求的处理器节点</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_CONNECT);</span><br><span class="line">    <span class="comment">// 获取处理器节点的executor</span></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeConnect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeConnect(remoteAddress, localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, promise, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里首先 <code>findContextOutbound</code> 找到处理器节点，后面说。然后获取处理器的 EventExecutor。执行 invokeConnect。这里主要看 <code>invokeConnect</code> 连接处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;  <span class="comment">// 判断该处理器节点中对应的处理器是否已经添加</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelOutboundHandler) handler()).connect(<span class="keyword">this</span>, remoteAddress, localAddress, promise);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyOutboundHandlerException(t, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>直接继续跟<code>connect</code> 方法，这里找到的是匿名内部内 HeadContext：<code>io.netty.channel.DefaultChannelPipeline.HeadContext#connect</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">    SocketAddress remoteAddress, SocketAddress localAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连接</span></span><br><span class="line">    unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>获取到底层 unsafe 对象进行连接：<code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Already a connect in process.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionPendingException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">        <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;  <span class="comment">// 连接            </span></span><br><span class="line">            <span class="comment">// 省略+......</span></span><br></pre></td></tr></table></figure>



<p>这里进行连接，找到 <code>doConnect</code> 连接方法：<code>io.netty.channel.socket.nio.NioSocketChannel#doConnect</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doBind0(localAddress);  <span class="comment">// 将localAddress绑定到channel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 连接server地址，若本次连接成功，则成功；若不成功，则当前channel的连接就绪</span></span><br><span class="line">        <span class="keyword">boolean</span> connected = SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">        <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">            <span class="comment">// 指定其关注的事件为  连接就绪</span></span><br><span class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> connected;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>doBind0(localAddress)</code> 将Client 端指定的端口号绑定到 channel，localAddress 为配置类设置的 Client 端口号。</p>
<p>然后进行连接，这里首先在执行时直接进行连接，如果第一次连接成功则直接返回成功，如果失败，注册 Selector 事件 OP_CONNECT ，即将当前 channel 修改为连接就绪，后续执行到 run 方法时就会再次执行连接，直到连接成功，结束当前连接就绪。</p>
<p>到这就是整个 Client 的启动。整体看下来可以类比 Server 端，大体流程还是差不多的。学就完了。</p>
<h4 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h4><p>前面说了那么学完，大家对于 Netty 执行流程，Server 端和 Client 端的启动，大家都有了很深的认识，前面也留了很大一块关于 Netty 服务启动之后的处理过程，这部分也就是前面没有说的 Pipeline 的部分知识点。下面我们就重点说说 Pipeline 。</p>
<h5 id="Pipeline-的创建"><a href="#Pipeline-的创建" class="headerlink" title="Pipeline 的创建"></a>Pipeline 的创建</h5><p>先找到代码，Pipeline 的创建其实在前面也有看到，这个入口就在Server 端和 Client 端启动的时创建 Channel 的时候。找到代码：<code>io.netty.channel.AbstractChannel#AbstractChannel(io.netty.channel.Channel)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="comment">// 为channel生成id，由五部分构成</span></span><br><span class="line">    id = newId();</span><br><span class="line">    <span class="comment">// 生成一个底层操作对象unsafe</span></span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    <span class="comment">// 创建与这个channel相绑定的channelPipeline</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>newChannelPipeline()</code> 这个就是 Pipeline 的创建入口，跟进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到这里是直接创建了 <code>DefaultChannelPipeline</code>。直接找到构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建尾节点</span></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建头节点</span></span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将头尾节点连接</span></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>创建一个记录成功的 succeededFuture 。</li>
<li>创建一个记录异常的 voidPromise，在 <code>VoidChannelPromise</code> 方法中创建了一个异常监听器，触发重写的 <code>fireExceptionCaught(cause)</code> 的方法执行。</li>
<li>创建一个尾节点。</li>
<li>创建一个头节点。</li>
<li>将收尾节点关联起来。</li>
</ol>
</blockquote>
<p>这里我们去看看两个 TailContext 和 HeadContext。两个差不多，先看 <code>new TailContext(this);</code>.这里 TailContext 是一个内部类：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9FqJk0NokHcTknRNNMwjSbqMzwAdumicenlr4Ryu9qFOQRqO1e6ChWlA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>实现了 ChannelInboundHandler 处理器，是一个 InboundHandler。关于 InboundHandler 和 OutboundHandler 处理器下面单独说，这里不展开。只要知道 InboundHandler 的方法都是处理回调的方法。</p>
<p>这里还是看 TailContext 的构造方法。第一步调用了父类构造，然后修改节点的处理器状态，先进去看看修改节点处理器状态的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">setAddComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldState = handlerState; <span class="comment">// 获取处理器状态</span></span><br><span class="line">        <span class="keyword">if</span> (oldState == REMOVE_COMPLETE) &#123; <span class="comment">// 处理器状态为移除状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过CAS方式将处理器状态修改为 添加完毕</span></span><br><span class="line">        <span class="keyword">if</span> (HANDLER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldState, ADD_COMPLETE)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>就是通过 CAS 的方式将当前节点的处理器状态修改为添加完毕。然后我们再回去跟父类构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,</span><br><span class="line">                              String name, Class&lt;? extends ChannelHandler&gt; handlerClass) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="comment">// 每个处理器节点都会绑定一个executor</span></span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="comment">// 执行标记</span></span><br><span class="line">    <span class="keyword">this</span>.executionMask = mask(handlerClass);</span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里先是绑定 pipeline 和 executor，不过这里的 executor 传入是 null，每个处理器节点都会绑定一个 Ececutor ，如果当前处理器的 executor 为空则直接使用 channel 的 Executor 来执行当前处理器节点里的处理器方法。</p>
<p>这里我们跟进去看下 <code>mask(handlerClass)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mask</span><span class="params">(Class&lt;? extends ChannelHandler&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中尝试着获取标记</span></span><br><span class="line">    Map&lt;Class&lt;? extends ChannelHandler&gt;, Integer&gt; cache = MASKS.get();</span><br><span class="line">    Integer mask = cache.get(clazz);</span><br><span class="line">    <span class="keyword">if</span> (mask == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个标记</span></span><br><span class="line">        mask = mask0(clazz);</span><br><span class="line">        cache.put(clazz, mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到这个方法是一个静态的，首先从缓存中获取标记数据，获取不到为当前处理器类创建缓存标记：<code>mask0(clazz)</code>:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9H6HicPjmFic76tHcgH5KJiaz9gUqdr3hKOu4jDl7yUQ4u4yIiaFuRdgAhg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这是充分使用了<strong>二进制的开关的性质</strong>，这里方法的作用就是将所有的 InboundHandler 处理器和 OutboundHandler 处理器中定义的方法进行标记，如果其中的方法被实现了，并且方法中没有 <code>@Skip</code> 注解，则当前方法对应的二进制位的值是 1，当当前标记位等于 1 时，则标记当前方法时需要执行的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9BVs37QobONOMtibqHZW3KlBcor5p0X4794nh8bxBuT334ib4FOPIbZag/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>其实这里在 TailContext 和 HeadContext 中所有的标记位都是 1，因为 TailContext 和 HeadContext 分别都实现了 InboundHandler  和 OutboundHandler 接口中的接口。这里说这个主要因为这里在我们自定义的处理器时就会使用到。扎到一个自定义的处理器：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp97chMqfFEsRT56N9U4icdBVOCa6NlHvyIYO8QAT8fsJibmULLaJxOGwBg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们没有直接实现自 InboundHandler，而是直接继承了 ChannelInboundHandlerAdapter ，大家可以进去看看，在 ChannelInboundHandlerAdapter 中每一个实现方法上都有一个  <code>@Skip</code> 注解，而且它默认实现了所有的 InboundHandler 接口的方法，就是为了我们在定义自定义处理器减少一些默认实现的处理，而且为了性能在初始化时将所有的方法打上标记，保证只执行我们自己实现的方法，这就是这个标记的用处。这里 <code>mask</code> 处理的都是 InboundHandler  和 OutboundHandler 处理器中的接口方法。</p>
<p>好了到这里 TailContext 节点创建完成，我们接着看 HeadContext 节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点既是inbound处理器，也是outbound处理器</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">        HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">            <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, HeadContext.class);</span><br><span class="line">            unsafe = pipeline.channel().unsafe();</span><br><span class="line">            setAddComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 。。。。</span></span><br></pre></td></tr></table></figure>



<p>HeadContext  也是内部类，这里与 TailContext 不同的是，HeadContext  同时实现了 InboundHandler  和 OutboundHandler。并且创建了一个用于底层 IO 处理的 unsafe 对象。到这里 Pipeline 的初始化创建看完了，可以看到 Pipeline 在 Channel 的创建的时初始化创建的。</p>
<p>下面说一下一个特殊的处理器，前面也是一直看到：<code>ChannelInitializer</code>处理器。</p>
<h5 id="ChannelInitializer-处理器节点"><a href="#ChannelInitializer-处理器节点" class="headerlink" title="ChannelInitializer 处理器节点"></a>ChannelInitializer 处理器节点</h5><p>先看下类图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9lEFOickV7bcng5QU7yS69iarLpK4vzibLNA7b1ovCqN3ny5oicuLqicPCGQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>ChannelInitializer 继承于 ChannelInboundHandler 接口，是一个抽象类，定义了一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>



<p>以 Server 端为例，我们在使用 ChannelInitializer 时都需要实现 <code>initChannel</code> 方法：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9UgRz9sCRUBwPdX3daapUKcmXJKtAJq3XZCBYQMibSkDDPYW7SISh2gQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在 ServerBootstrap 中 <code>io.netty.bootstrap.ServerBootstrap#init</code> 方法中可以找到代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        ChannelHandler handler = config.handler();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pipeline.addLast(handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>负责在 accept 新连接的 Channel 的 pipeline 被添加了一个 ChannelInitializer，由于此时这个 Channel 还没有被注册到EventLoop，于是在 addLast 方法的调用链中，会给 pipeline 添加一个 <code>PendingHandlerAddedTask</code> ，其目的是在 Channel被注册到 EventLoop 的时候，触发一个回调事件然后在 <code>AbstractBootstrap.initAndRegister()</code> 方法中，这个Channel会被注册到 ParentEventLoopGoup，接着会被注册到 ParentEventLoopGoup 中的某一个具体的 EventLoop 然后在AbstractChannel.register0() 方法中，之前注册的 PendingHandlerAddedTask 会被调用，经过一系列调用之后，最终 <code>ChannelInitializer.handleAdded()</code> 方法会被触发。所以我们进去看 <code>ChannelInitializer.handleAdded()</code> 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前处理器所封装的处理器节点被添加到pipeline后就会触发该方法的执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;  <span class="comment">// 若channel已经完成了注册</span></span><br><span class="line">        <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">            <span class="comment">// 将当前处理器节点从initMap集合中删除</span></span><br><span class="line">            removeState(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到 ChannelInitializer 的方法触发时必须在 Channel 注册完成之后，然后开始执行 initChannel 方法，在初始化操作完成之后又将当前处理器节点从 initMap 集合中移除。现在先看看 initChannel 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前处理器节点添加到initMap集合中</span></span><br><span class="line">    <span class="keyword">if</span> (initMap.add(ctx)) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用重写的initChannel()</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 立即将该处理器节点从pipeline上删除</span></span><br><span class="line">            ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">            <span class="comment">// 查找在pipeline中是否存在当前处理器</span></span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将当前处理器节点从pipeline中删除</span></span><br><span class="line">                pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 <code>initChannel</code> 方法中，先将当前处理器节点添加到 initMap 中，然后调用抽象方法 <code>initChannel</code> ，由此调用到抽象类的实现方法，也就是在前面 Server 端代码中我们初始化 childHandler 时添加的实现方法，不过 ChannelInitializer 在 Netty 自己的代码中也有多处使用，上面说的 Server 端启动初始化的时候在 init 方法中也就有使用。不过我们自己定义的可以回顾一下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9YX1yQgh6J3ViblQDibgdeKnJM92XJiayfslodmvmZD1zeRpOhexkicotvw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在 Server 端 ServerBootstrap 中我们使用 ChannelInitializer 给 pipeline 中添加处理器节点。</p>
<p>再回到 <code>initChannel</code> 方法。继续看再其执行完重新的 <code>initChannel</code> 方法之后必然执行 finally 的代码，首先获取当前Pipeline，<code>pipeline.context(this)</code> 从 Pieline 查找但其处理器节点是否存在。存在然后 <code>pipeline.remove(this)</code> 将其从当前 Pipeline 中移除。</p>
<p>感兴趣可以看下，<code>pipeline.context</code> 方法和 <code>pipeline.remove</code> 方法，因为 Pipeline 中的处理器节点 时链表形式保存的，所以在这两个方法方法的处理就是链表的查找和删除。</p>
<p>看到这里可以发现 ChannelInitializer 的主要目的是为程序员提供了一个简单的工具，用于在某个 Channel 注册到EventLoop 后，对这个 Channel 执行一些初始化操作。ChannelInitializer 虽然会在一开始会被注册到 Channel 相关的pipeline 里，但是在初始化完成之后，ChannelInitializer 会将自己从pipeline中移除，不会影响后续的操作。刚刚看到的 <code>pipeline.remove</code> 就是将当前处理器节点从 pipeline 移除的方法，而在执行完 <code>initChannel</code> 方法后，在 <code>handlerAdded</code> 方法中又将添加到 <code>initMap</code> 中的处理器节点也移除了。</p>
<h5 id="Hanndler-添加到-Pipeline"><a href="#Hanndler-添加到-Pipeline" class="headerlink" title="Hanndler 添加到 Pipeline"></a>Hanndler 添加到 Pipeline</h5><p>上面说了 ChannelInitializer  处理器节点，看到我们在重写 initChannel 方法时调用的都有 pipeline 新增处理器方法，也就是 <code>addLast</code> 方法，这里我们详细看看 addLast 怎么将处理器添加到 pipeline 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.netty.channel.DefaultChannelPipeline#addLast(io.netty.channel.ChannelHandler...)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数为group，其值默认为null</span></span><br><span class="line">    <span class="keyword">return</span> addLast(<span class="keyword">null</span>, handlers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>前面说过，每个 Pipeline 都有一个 EventLoop 绑定，这里添加方法默认传入一个 EventLoopGroup 参数，不过这里传了空；继续往下跟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;handlers&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有handlers，逐个添加到pipeline</span></span><br><span class="line">    <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addLast(executor, <span class="keyword">null</span>, h);<span class="comment">// 这里第二个参数是处理器name</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>遍历传入参数，将 Handler 循环添加到 Pipeline 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 检测处理器是否被多次添加</span></span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将处理器包装为一个节点 filterName() 获取到节点的名称</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新的节点添加到pipeline</span></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取新建节点绑定的eventLoop</span></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="comment">// 若该eventLoop绑定的线程与当前线程不是同一个，则执行下面的代码</span></span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若该eventLoop绑定的线程与当前线程是同一个线程，</span></span><br><span class="line">    <span class="comment">// 则调用重写的handlerAdded()方法</span></span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>校验当前处理器是否被多次添加，没有被 @Sharable 注解标注的处理器只可以被添加一次。</li>
<li>将处理器包装一个新的节点 <code>newContext(group, filterName(name, handler), handler)</code></li>
<li>将新的节点添加到 Pipeline 中。<code>addLast0(newCtx)</code></li>
<li>判断 channel 没有注册，处理异常情况。<code>callHandlerCallbackLater(newCtx, true)</code></li>
<li>获取新节点的 EventLoop ，判断是否是当前线程，如果不是当前线程执行 <code>callHandlerAddedInEventLoop(newCtx, executor)</code></li>
<li>新节点的 EventLoop 是当前线程执行 <code>callHandlerAdded0(newCtx)</code></li>
</ol>
<p>这里我们标记几个需要往下细跟的代码：</p>
<p><strong>Tag Handler 1 ：newContext</strong></p>
<p><strong>Tag Handler 2 ：addLast0</strong></p>
<p><strong>Tag Handler 3  callHandlerCallbackLater/callHandlerAdded0</strong></p>
</blockquote>
<h5 id="Tag-Handler-1-：newContext"><a href="#Tag-Handler-1-：newContext" class="headerlink" title="Tag Handler 1 ：newContext"></a>Tag Handler 1 ：newContext</h5><p>这里处理还是比较复杂，我们具体进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// childExecutor() 获取与当前处理器节点相绑定的eventLoop</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group), name, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先这里我们传入的 group 是 null ，前面一直没有传，这里调用 <code>childExecutor(group)</code> 直接跟进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> EventExecutor <span class="title">childExecutor</span><span class="params">(EventExecutorGroup group)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若group为null，则与该节点绑定的eventLoop为null</span></span><br><span class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Boolean pinEventExecutor = channel.config().getOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP);</span><br><span class="line">    <span class="keyword">if</span> (pinEventExecutor != <span class="keyword">null</span> &amp;&amp; !pinEventExecutor) &#123;</span><br><span class="line">        <span class="keyword">return</span> group.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;EventExecutorGroup, EventExecutor&gt; childExecutors = <span class="keyword">this</span>.childExecutors;</span><br><span class="line">    <span class="keyword">if</span> (childExecutors == <span class="keyword">null</span>) &#123;</span><br><span class="line">        childExecutors = <span class="keyword">this</span>.childExecutors = <span class="keyword">new</span> IdentityHashMap&lt;EventExecutorGroup, EventExecutor&gt;(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    EventExecutor childExecutor = childExecutors.get(group);</span><br><span class="line">    <span class="keyword">if</span> (childExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        childExecutor = group.next();</span><br><span class="line">        childExecutors.put(group, childExecutor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> childExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其实在我们没有指定 Group 的时候，这里代码是被直接返回了出去，下面执行逻辑就没有执行，而此时节点的 EventLoop 是在 <code>EventExecutor executor = newCtx.executor();</code> 中绑定的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> channel().eventLoop();  <span class="comment">// 获取到channel所绑定的eventLoop</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在新节点获取当前节点绑定的 Executor 时如果未绑定，则直接获取当前 Channle 的 eventLoop 。这里再回去看 <code>childExecutor</code> 方法，如果要走到下面逻辑则需要到添加 Handler 时传入一个 EventLoopGroup：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9fzY5WMcsyjRoChafKiaictShic6pJ0GibpznCAhfgy7C2NbKLw38Mx3jwA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>好了，这样我们的 Group 就不为 null。继续看 childExecutor 下面的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> EventExecutor <span class="title">childExecutor</span><span class="params">(EventExecutorGroup group)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean pinEventExecutor = channel.config().getOption(ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP);</span><br><span class="line">    <span class="keyword">if</span> (pinEventExecutor != <span class="keyword">null</span> &amp;&amp; !pinEventExecutor) &#123;</span><br><span class="line">        <span class="comment">// 轮询获取 eventLoop</span></span><br><span class="line">        <span class="keyword">return</span> group.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;EventExecutorGroup, EventExecutor&gt; childExecutors = <span class="keyword">this</span>.childExecutors;</span><br><span class="line">    <span class="keyword">if</span> (childExecutors == <span class="keyword">null</span>) &#123;</span><br><span class="line">        childExecutors = <span class="keyword">this</span>.childExecutors = <span class="keyword">new</span> IdentityHashMap&lt;EventExecutorGroup, EventExecutor&gt;(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventExecutor childExecutor = childExecutors.get(group);</span><br><span class="line">    <span class="keyword">if</span> (childExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        childExecutor = group.next();</span><br><span class="line">        childExecutors.put(group, childExecutor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> childExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>获取 channel 的 option 配置的 <code>SINGLE_EVENTEXECUTOR_PER_GROUP</code> 值。用来配置当前处理器节点是否绑定使用同一个 EventLoop。不为空并且是 False : 则表示一个group中的每一个处理器都会分配一个 eventLoop，调用 EventLoopGroup 的 <code>next</code> 方法，而 <code>next</code> 是轮询的方式从 Group 中选取 EventLoop。</li>
<li>没有配置使用同一个 eventLoop 则先获取缓存中保存的 EventLoopGroup 对应的 eventLoop，如果缓存中存在则直接返回，如果缓存中不存在则从 EventLoopGroup 获取一个 eventLoop，保存到缓存中并返回。</li>
</ol>
</blockquote>
<p>这就是创建处理器节点中绑定 EventLoop 的方法。所以到这可以看到处理器节点的 EventLoop 可以指定，不指定则直接使用当前 channel 的 EventLoop 。拿到 EventLoop  之后则直接创建处理器节点 <code>new DefaultChannelHandlerContext</code></p>
<h5 id="Tag-Handler-2-：addLast0"><a href="#Tag-Handler-2-：addLast0" class="headerlink" title="Tag Handler 2 ：addLast0."></a>Tag Handler 2 ：addLast0.</h5><p>这里直接找到代码跟进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这就是一个链表操作，先获取到当前 Pipeline 的 TailContext 节点，因为这里是我们从 <code>addLast</code> 方法跟进来的，所以这里是添加在尾节点前，也就是末尾添加。同样类比其他的 Handler 添加方法 <code>addBefore</code>。这里获取到 Tail 节点，将链表收尾关联到新的节点上，完成链表的新增即完成新节点添加。</p>
<h5 id="Tag-Handler-3-callHandlerCallbackLater-callHandlerAdded0"><a href="#Tag-Handler-3-callHandlerCallbackLater-callHandlerAdded0" class="headerlink" title="Tag Handler 3  callHandlerCallbackLater/callHandlerAdded0"></a>Tag Handler 3  callHandlerCallbackLater/callHandlerAdded0</h5><p>直接跟 <code>callHandlerCallbackLater</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAddedInEventLoop</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext newCtx, EventExecutor executor)</span> </span>&#123;</span><br><span class="line">    newCtx.setAddPending(); <span class="comment">// 将当前节点状态设置成处理中，等待 callHandlerAdded0 执行完成</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            callHandlerAdded0(newCtx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到这个方法也是调用的 <code>callHandlerAdded0</code> 方法，只不过因为当前节点绑定的 EventLoop 不是当前执行线程，所以需要通过 EventLoop 创建一个新的任务，由任务来完成 <code>callHandlerAdded0</code> 方法的执行，而是当前线程则直接执行 <code>callHandlerAdded0</code> 方法。继续看 <code>callHandlerAdded0</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ctx.callHandlerAdded();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            remove0(ctx);</span><br><span class="line">            ctx.callHandlerRemoved();</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Failed to remove a handler: &quot;</span> + ctx.name(), t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">            fireExceptionCaught(<span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line">                ctx.handler().getClass().getName() +</span><br><span class="line">                <span class="string">&quot;.handlerAdded() has thrown an exception; removed.&quot;</span>, t));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireExceptionCaught(<span class="keyword">new</span> ChannelPipelineException(</span><br><span class="line">                ctx.handler().getClass().getName() +</span><br><span class="line">                <span class="string">&quot;.handlerAdded() has thrown an exception; also failed to remove.&quot;</span>, t));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里直接调用当前处理器的 <code>callHandlerAdded</code> 方法，如果异常则将资源移除。进到 <code>callHandlerAdded</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">callHandlerAdded</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (setAddComplete()) &#123; <span class="comment">// CAS 方式将处理器状态修改为 添加完毕 ADD_COMPLETE</span></span><br><span class="line">        handler().handlerAdded(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>先通过 CAS 修改处理器状态为添加完成，状态修改成功则调用处理器的添加方法完成处理器添加。</p>
<p>到这里处理器的添加完成。添加处理器方法画个图再回顾一下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9R4Aia1BpauRv48DqrhyxQWoBxNO8vMibpRteek0cdVMYJlExCS654dicg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>说到这里，pipeline 的初始化到 Pipeline 中添加 Handler 。那到这里我们在整体的理解下 Pipeline：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9J10QoaGrLFP1za0xXPManFpxkwz2RzbPfpsLGW3APspOLSYFLlicb1A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>现在在结合这个图去理解一下 Pipeline 的创建和添加的过程应该心里面会有点不一样认知。当然说到这里还是没有说到 Pipeline 的执行顺序，下面我们从 InboundHandler 处理器和 OutboundHandler 处理器来说 Pipeline 的执行过程。</p>
<h4 id="Pipeline-中消息的传递与处理"><a href="#Pipeline-中消息的传递与处理" class="headerlink" title="Pipeline 中消息的传递与处理"></a>Pipeline 中消息的传递与处理</h4><p>要说 Pipeline 的中的消息处理，首先还是先说下我们的 Handler，因为 Pipeline 中的消息都是由每一个处理器来完成处理的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9r03uG30R4ISa9eFdlHZfeZgTzA3vr4fQVs3p1fDdvOwicQfCGD410yw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>ChannelHandler 是 handler 的顶级接口，我们所有的处理器都实现自该接口，当前接口只定义了两个方法：<code>hanndlerAdded</code> 和 <code>handlerRemoved</code>，用于当前处理器被从 Pipeline 中添加或移除时调用的方法，还有一个过时的处理异常的方法：<code>exceptionCaught</code>。</p>
<p>再说 ChannelHandler  两个子类接口：<code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code> 这两个接口将处理器方法定义成了两类，<code>ChannelInboundHandler</code> 定义了所有的用于处理回调的方法，都是需要出动触发的方法。<code>ChannelOutboundHandler</code> 定义的所有的用于主动调用的处理器方法，需要主动调用。</p>
<p>而 <code>ChannelHandlerAdapter</code> 则是处理器适配器顶级抽象类，用于定义处理器适配器的规范。</p>
<p><code>ChannelInboundHandlerAdapter</code> 和 <code>ChannelOutboundHandlerAdapter</code> 处理器适配器中它帮我们默认实现了所有的 handler 的方法，并且每个方法上面都标记了 <code>@Skip</code> 注解，在前面也看到，被标记 <code>@Skip</code> 注解的 Handler 方法会被标记，不会被 Handler 执行，这让我们再使用适配器之定义处理器时只要重写我们关心方法即可，重写的方法不会标记 <code>@Skip</code> 。</p>
<p>还有一个重要的类需要说下：<code>ChannelHandlerContext</code>，上下文对象，每个 Handler 每个方法都需要传递上下文对象，再 Pipeline 中处理器的调用就是通过 <code>ChannelHandlerContext</code> 上下文对象完成执行链的调用，也可以用来保存上下文数据。</p>
<p>下面就说重点，Pipeline 中 handler 的执行过程。先定义一个处理器：</p>
<blockquote>
<ol>
<li>InboundHandler1</li>
</ol>
<p>只实现 <code>channelRead</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;InboundHandler1 进入 &quot;</span> + msg);</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">    System.out.println(<span class="string">&quot;InboundHandler1 退出 &quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>InboundHandler2</li>
</ol>
<p>只实现 <code>channelRead</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;InboundHandler2 进入 &quot;</span> + msg);</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">    System.out.println(<span class="string">&quot;InboundHandler2 退出 &quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>InboundHandler3</li>
</ol>
<p>只实现 <code>channelRead</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;InboundHandler3 进入 &quot;</span> + msg);</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">    System.out.println(<span class="string">&quot;InboundHandler3 退出 &quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>OutboundHandler1</li>
</ol>
<p>只实现 <code>write</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;OutboundHandler1 进入 &quot;</span> + msg);</span><br><span class="line">    ctx.write(msg, promise);</span><br><span class="line">    System.out.println(<span class="string">&quot;OutboundHandler1 退出 &quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>OutboundHandler2</li>
</ol>
<p>只实现 <code>write</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;OutboundHandler2 进入 &quot;</span> + msg);</span><br><span class="line">    ctx.write(msg, promise);</span><br><span class="line">    System.out.println(<span class="string">&quot;OutboundHandler2 退出 &quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>OutboundHandler3</li>
</ol>
<p>只实现 <code>write</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;OutboundHandler3 进入 &quot;</span> + msg);</span><br><span class="line">    ctx.write(msg, promise);</span><br><span class="line">    System.out.println(<span class="string">&quot;OutboundHandler3 退出 &quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="InboundHandler-执行流程"><a href="#InboundHandler-执行流程" class="headerlink" title="InboundHandler 执行流程"></a>InboundHandler 执行流程</h4><p>添加三个 <code>InboundHandler</code>处理器，添加顺序为：</p>
<p><strong>InboundHandler1  -&gt;  InboundHandler2 -&gt;  InboundHandler3</strong></p>
<p>添加完成后 Pipeline 如图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9yyfMIAxIXEk53paL6pmyO3ia0X3icYFM4C45mhhNhw5BibRG3v4m3gecw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>此时请求过，Handler 在 Pipeline 的执行流程：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9SHOATpwjU3Iw5ia0pmyLooWD8mvt44Y1iaWMxFE9eLsDZkFkwDUkmGsA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当 client 请求到 Server 并写入数据时，触发 Server 端 Head 节点的 <code>channelRead</code> 方法，此时调用链开始执行，Head 节点执行 <code>channelRead</code> 方法调用 <code>fireChannelRead</code> 触发 next 节点的 <code>channelRead</code> 方法执行，不过这里会先判断 next 节点的方法标记也就是 mask 是否标记当前 Handler  是否需要执行 <code>channelRead</code> 方法，如果重写则调用，否则继续找 next 的 next 节点。举个栗子：如果 handler2 没有重写 <code>channelRead</code> 方法，则调用会变成这样：</p>
<p><strong>Head -&gt; handler1 -&gt; handler3 -&gt; Tail</strong>。</p>
<p>所以 Pipeline 的处理器执行是由 Head 节点开始，由 Head 触发 Inbound 方法，完成调用链执行。</p>
<p>这里我们可以找到执行调用的代码，先看 Head 节点的 channelRead 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelRead(msg);  <span class="comment">// 准备调用其下一个节点的channelRead()</span></span><br><span class="line">&#125;</span><br><span class="line">ctx.fireChannelRead(msg)` 进去看看如果调用下一个节点：`io.netty.channel.AbstractChannelHandlerContext#<span class="function">fireChannelRead</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里通过 findContextInbound 方法获取下一个节点，传入的参数 <code>MASK_CHANNEL_READ</code> 用来判断当前处理器的 <code>channelRead</code> 方法是否被标记需要执行。进入 findContextInbound 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>获取当前节点的 Next 节点，判断 Next 节点的 channelRead 方法是否需要执行，不需要则继续获取下一个，知道获取到 Tail 节点，因为 Tail 实现了所有的 InboundHandler 处理器方法。</p>
<p>然后执行 invokeChannelRead 方法，触发 Next 节点的 channelRead 的执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>直接找到  invokeChannelRead 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>invokeHandler()</code> 方法判断当前处理器状态是否完成，然后调用下一个节点的 channelRead 方法。</p>
<p>Inbound 执行过程的代码以 channelRead 为例就说到这，然后现在看着代码再结合上面的图大家应该很清楚整个执行的流程。</p>
<h4 id="OutboundHandler-执行流程"><a href="#OutboundHandler-执行流程" class="headerlink" title="OutboundHandler 执行流程"></a>OutboundHandler 执行流程</h4><p>OutboundHandler  与 InboundHandler 不一样，因为 OutboundHandler  的方法是需要我们自己调用，而不像 InboundHandler  处理器的方法是触发调用。所以在这种情况下，如果我们只添加 OutboundHandler  处理器的话，当 Client 发起请求也不会触发 OutboundHandler  的方法执行。因此我们加一个 InboundHandler 方法，用来触发 OutboundHandler 的执行。</p>
<p>定义 WriteInboundHandler ：重写 <code>channelRead</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;WriteInboundHandler  进入 &quot;</span> + msg);</span><br><span class="line">    ctx.channel().write(<span class="string">&quot;我是 Server。&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;InboundHWriteInboundHandler andler3 退出 &quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里在 WriteInboundHandler 中我们获取到 Channel，然后通过 Channel 将消息写回 Clinet 端。</p>
<p>Hanndler 添加顺序：<strong>WriteInboundHandler  -&gt; OutboundHandler1 -&gt; OutboundHandler2 -&gt; OutboundHandler3</strong></p>
<p>添加完成后 Pipeline 如图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9QqT0y93trNibuQIfk26Jib0HMvO28jh0NqibjcHfLzxHUu8iaBD34oqoKw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>而此时 client 请求到 Server 并写入数据时，一样是先触发 Head 节点的 channelRead 方法。执行流程如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1Fpx7bubp6WLdlCN7ERvRXSp9MOfAuOTyV5lXIMutGK3gE2TK6L4GDyLaZIv6LjchtMDfUxvYBYdQ4g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>Outbound 的处理流程与 Inbound 的流程是相反的，在 Inbound 中处理是获取 next 节点执行，而在 Outbound 节点中获取的确是 prev 节点的重写方法执行。所以这里的执行顺序会变成跟添加顺序相反的顺序执行。</p>
<blockquote>
<p>这里首先请求进入 Server 触发 Head 节点的 channelRead 方法执行，然后再获取下一个重写了 channelRead 方法的 Inbound 处理器，找到 WirteHandler 处理器，在 WirteHandler 处理器中掉用 Channel 的 writeAndFlush 方法，找到Tail 节点实现方法，调用了 Write 方法，然后获取 Prev 节点中重写了 write 方法的处理器，找到 Outbound3，然后依次调用 Outbound2 的 write 方法和 Outbound1 的 write 方法，执行完成依次返回。</p>
</blockquote>
<p>这里我们可以找到执行调用的代码：</p>
<p>先看 Inbound 处理器执行调用的触发过程，从 <code>ctx.channel().write</code> 的方法进入，找到 <code>io.netty.channel.DefaultChannelPipeline#write(java.lang.Object)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.write(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到在 Channel 中的 Write 方法直接找到 Tail 调用其重写的 Write 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> write(msg, newPromise());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>往下跟 write 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">                <span class="comment">// cancelled</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查找下一个节点(prev)</span></span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(flush ?</span><br><span class="line">                (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line">        <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">        EventExecutor executor = next.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                next.invokeWriteAndFlush(m, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next.invokeWrite(m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> AbstractWriteTask task;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!safeExecute(executor, task, promise, m)) &#123;</span><br><span class="line">                task.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到这里先通过 <code>findContextOutbound</code> 方法获取下一个节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里我们可以看到，Outbound 的获取顺序是获取的 prev ，并且判断该 handler 中当前方法是否标记需要执行。</p>
<p>获取到下一个节点之后在 wirte 方法中通过 <code>next.invokeWrite</code> 方法完成执行器链调用。当然如果我们一个 OutboundHandler 都没有定义的话，<code>findContextOutbound</code> 方法最终会获取到 Head 节点，然后执行 Head 节点 write 方法，因为我们在前面看到 HeadContext 节点同时实现了 Inboundhandler 和 OutboundHandler。这里我们去看一下 Head 节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    unsafe.write(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最终在 HeadContext 中完成底层 unsafe 的 write 操作。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019102301.html" title="面试整理——Web服务器">http://linyishui.top/2019102301.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019102201.html" rel="prev" title="面试整理——Java并发编程">
                  <i class="fa fa-chevron-left"></i> 面试整理——Java并发编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019102401.html" rel="next" title="面试整理——JVM">
                  面试整理——JVM <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
