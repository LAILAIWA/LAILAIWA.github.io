---
title: 算法复习 (二) 查找-上篇
date: 2018-09-25 15:39:46
tags: [algorithm,search]
description: 查找上篇包括：顺序查找，二分查找，二叉查找树等内容
categories: 技术文档
photos: 
    - "https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/tinapouty_2___BfVFfHaHi54___.jpg"
---
{% aplayer "PneumaticTokyo" "EnV" 
"https://music-1258215793.cos.ap-shanghai.myqcloud.com/EnV%20-%20PneumaticTokyo.mp3" "http://p1.music.126.net/4F_X5wv5cA-VTQtEzGjoNQ==/7724069186278104.jpg" "autoplay" %}

*查找上篇包括：顺序查找，二分查找，二叉查找树*

# **基础定义**

## **符号表**

**定义：**

存储要查找的信息的某种数据结构，通过三种经典的数据类型可以实现高效的符号表：二叉查找树，红黑树，散列表。

**特点：**

键唯一，显式非空，值隐式非空（方便延时删除），可重复。

**符号表的删除操作：**

* 延时删除：将键对应的值置空，在某个时刻删除所有空值键，put( key, null)。
* 及时删除：立刻删除指定的键，delete(key)。

为了保证任意时刻值都不为空，一般只采用及时删除。

# **无序链表的顺序查找**

**顺序查找-SequentialSearchST-代码：**

[顺序查找-SequentialSearchST](https://github.com/LAILAIWA/AlgorithmTraining/blob/master/src/search/SequentialSearchST.java "Title")

**结点结构：**

```
private Node first;//链表首结点
private class Node{//定义链表结点
    Key key;
    Value val;
    Node next;
    public Node(Key key,Value val,Node next){
        this.key = key;
        this.val = val;
        this.next = next;
    }
}
```

**增删查等操作实现：**

```
public Value get(Key key){//查找给定的键，返回相关联的值
    for(Node x = first;x != null;x = x.next)
        if(key.equals(x.key))
            return x.val;
    return null;//未命中
}

public void put(Key key,Value val){
    //查找给定的键，找到则更新，否则在表中新建结点，保证Key唯一
    for(Node x = first;x != null;x = x.next) {
        if (key.equals(x.key)) {//命中，更新
            x.val = val;
            return;
        }
    }
    first = new Node(key,val,first);//未命中，新建结点
}

public int size(){//返回链表大小
    int count = 0;
    for(Node x = first;x != null;x = x.next)
        count++;
    return count;
}

public Node delete(Key key){//删除链表结点
    Node lastNode = null;//上个结点
    Node node = null;//删除结点
    for(Node x = first;x != null;x = x.next){
        if(key.equals(x.key)){//命中
            node = x;
            if(lastNode != null){//若上个结点不为空，连接上个结点和后个结点
                lastNode.next = node.next;
            }else {//若上个结点为空，后个结点为首节点
                first = x.next;
            }
            return node;
        }
        lastNode = x;
    }
    return null;//未找到Key
}

@SuppressWarnings("unchecked")
public Key[] keys(){//返回链表的键数组
    Key[] keys = (Key[])new Comparable[size()];
    int count = 0;
    for(Node x = first;x != null;x = x.next)
        keys[count] = x.key;
    return keys;
}
```

**分析：**
对于有N对键值的基于无序链表的符号表，未命中的查找和插入操作都需要N次比较。向一个空表中插入N个不同的键需要N^2/2次比较。

# **基于有序数组的二分查找**

**二分查找-BinarySearchST-代码：**

[二分查找-BinarySearchST](https://github.com/LAILAIWA/AlgorithmTraining/blob/master/src/search/BinarySearchST.java "Title")

**结构：**

```
private Key[] keys;
private Value[] vals;
private int N;
public BinarySearchST(int capacity){//构造器中初始化数组
    keys = (Key[]) new Comparable[capacity];
    vals = (Value[]) new Object[capacity];
}
```

**增删查等操作实现：**

```
public int size(){
    return N;
}

public Value get(Key key){//有Key则返回val，无则返回null，判断key是否相等，是根据其compareTo方法
    if(isEmpty()) return null;
    //二分查找获取key下标，未查到返回0或N，查到
    int i = rank(key);
    if(i < N && keys[i].compareTo(key) == 0)
        return vals[i];
    else
        return null;
}

public boolean isEmpty(){
    return N == 0;
}

public int rank(Key key){//二分查找，未查询到返回0或N，查到则返回下标
    //使用有序数组是为了根据索引减少每次查找所需要的比较次数
    int lo = 0,hi = N - 1;
    while (lo <= hi){
        int mid = lo + (hi - lo) / 2;
        int cmp = key.compareTo(keys[mid]);
        if(cmp < 0) hi = mid - 1;
        else if(cmp > 0) lo = mid + 1;
        else return mid;
    }
    return lo;
}

public void put(Key key, Value val){
    //查找键，找到则更新值，找不到新增元素
    int i = rank(key);
    if(i < N && keys[i].compareTo(key) == 0){
        vals[i] = val;
        return;
    }
    //扩展数组
    for(int j = N;j > i;i--){
        keys[j] = keys[j-1];
        vals[j] = vals[j-1];
    }
    keys[i] = key;
    vals[i]= val;
    N++;
}

public Value delete(Key key){//删除Key以及对应val
    if(isEmpty()) return null;
    int i = rank(key);
    if(i < N && keys[i].compareTo(key) == 0){//命中
        //分别从键数组和值数组中删除
        Value value = vals[i];
        //覆盖前个元素
        for(int n = i;n < N-1;n++){
            keys[n] = keys[n+1];
            vals[n] = vals[n+1];
        }
        //复制数组
        Key[] newKeys =(Key[]) new Comparable[N-1];
        Value[] newVals = (Value[]) new Object[N-1];
        for(int m = 0;m < N-1;m++){
            newKeys[m] = keys[m];
            newVals[m] = vals[m];
        }
        keys = newKeys;
        vals = newVals;
        return value;
    }
    else
        return null;
}

public Key min(){
    return keys[0];
}

public Key max(){
    return keys[N-1];
}

public Key select(int index){
    return keys[index];
}

//大于等于key的最小键
public Key ceiling(Key key){
    int i = rank(key);
    return keys[i];
}

//小于等于key的最大键
public Key floor(Key key){
    int i = rank(key);
    return keys[i];
}

public Iterable<Key> keys(Key lo,Key hi){
    MyQueue<Key> q = new MyQueue<Key>();
    for(int i = rank(lo);i < rank(hi);i++)
        q.enqueue(keys[i]);
    if(contains(hi))
        q.enqueue(keys[rank(hi)]);
    return q;
}

public boolean contains(Key key){
    if(isEmpty()) return false;
    //二分查找获取key下标，未查到返回0或N，查到
    int i = rank(key);
    if(i < N && keys[i].compareTo(key) == 0)
        return true;
    else
        return false;
}
```

**分析：**
对于有N个键的有序数组，最多需要lgN+1次比较。
二分查找减少了比较的次数，但无法减少运行所需的时间。因为在键是随机排列的情况下， 构造一个基于有序数组的符号表所需要访问数组的次数是数组长度的平方级别。
向大小为N的有序数组插入一个新的元素在最坏的情况下需要访问2N次数组，因此向一个空表中插入N个不同的键需要访问N^2次数组。


**BinarySearchST的操作的成本：**

<!-- <style>
table th:nth-of-type(1) {
    width: 90px;
}
table th:nth-of-type(2) {
    width: 180px;
}
</style> -->

|方法	|运行所需时间的增长数量级|
|------|:------:|
|put()|	N|
|get()|	logN|
|delete()|	N|
|contains()|	logN|
|size()|	1|
|min()|	1|
|max()|	1|
|floor()|	logN|
|ceiling()|	logN|
|rank()|	logN|
|select()|	1|
|deleteMin()|	N|
|deleteMax()|	1|

二分查找的put和delete等方法有些过慢，不过相较SequentialSearchST顺序查找，BinarySearchST二分查找的比较次数(包含访问数组的次数)要少很多

# **两者的比较**
{% raw %}
<table border="1" style="margin-top:10">
    <tr>
        <td rowspan="2" align="center">算法(数据结构)</td> 
        <td colspan="2" align="center">最坏情况的成本<br>(N次插入后)</td> 
        <td colspan="2" align="center">平均情况的成本<br>(N次随机插入后)</td> 
        <td rowspan="2" align="center">是否高效的支持<br>有序性的相关操作</td> 
   </tr>
    <tr>
        <td align="center">查找</td>    
        <td align="center">插入</td>    
        <td align="center">查找</td>    
        <td align="center">插入</td>    
    </tr>
    <tr>
        <td align="center">顺序查找(无序链表)</td>   
        <td align="center">N</td> 
        <td align="center">N</td> 
        <td align="center">N/2</td> 
        <td align="center">N</td> 
        <td align="center">否</td>  
    </tr>
    <tr>
        <td align="center">二分查找(有序数组)</td>   
        <td align="center">lgN</td> 
        <td align="center">2N</td> 
        <td align="center">lgN</td> 
        <td align="center">N</td> 
        <td align="center">是</td>  
    </tr>
</table>
{% endraw %}

**目标：**
同时保证查找和插入操作都是对数级别的算法和数据结构

# **符号表的各种实现的优缺点**

|使用的数据结构|实现|优点|缺点|
|------|------|------|------|
|链表-顺序查找|	SequentialSearchST|	适用于小型问题|	对于大型符号表很慢|
|有序数组-二分查找|	BinarySearchST|	最优的查找效率和空间需求<br>能够进行有序性相关的操作|	插入操作很慢|
|二叉查找树|BST	|实现简单<br>能够进行有序性相关的操作|没有性能上界的保证<br>链接需要额外的空间|
|平衡二叉查找树	|RedBlackBST|最优的查找和插入效率<br>能够进行有序性相关的操作|	链接需要额外的空间|
|散列表|SeparateChainHashST<br>LinearProbingHashST|	能够快速的查找和<br>插入常见类型的数据|需要计算每种类型的数据的散列<br>无法进行有序性相关的操作<br>链接和空结点需要额外的空间|

# **二叉查找树 BST**

## **新的符号表结构：**
二叉查找树，结合了链表的插入灵活性和有序数组查找的高效性

**结点：**
有一个父结点，两个左右子结点，一个键值对，键之间有顺序之分方便高效查找
```
private Node root; //二叉查找树的根节点
private class Node{
    private Key key;
    private Value value;
    private Node left,right;
    private int N; //以该结点为根的子树的结点总数

    public Node(Key key,Value value,int N){
        this.key = key;
        this.value = value;
        this.N = N;
    }
}
```

**二叉查找树-BST-代码：**

[二叉查找树-BST](https://github.com/LAILAIWA/AlgorithmTraining/blob/master/src/search/BST.java "Title")


## **二叉查找树的查找递归算法：**
如果树是空的，则查找未命中。
如果被查找的键和根结点的键相等，查找命中。
否则就递归的在适当的子树中继续查找，若被查找的键较小就查左子树，若较大则查右子树，若遍历结束仍未查到则未命中。

**分析：**
使用二叉查找树算法的运行时间取决于树的形状，树的形状又取决于键被插入的先后顺序。
最好的情况下，含有N个结点的二叉树是完全平衡的，每条空链接和根结点的距离都是lgN。
最坏清空，搜索路径上有N个结点，一直在树的一边。
对于分析角度，二叉查找树和快速排序很像，树的根结点就是快排的第一个切分元素，左边都比它小，右边都比它大，对于所有子树都适用。
在由N个随机数构成的二叉查找树中，查找命中平均所需的比较次数为2lnN（约1.39lgN），插入操作和查找未命中平均所需的比较次数为2lnN（约1.39lgN）。
```
public int size(){ return size(root); }

private int size(Node node){
    if(node == null) return 0;
    else return node.N;
}

public Value get(Key key){
    return get(root,key);
}

private Value get(Node x,Key key){
    //在以x为根节点的子树中查找并返回Key所对应的值
    //若找不到则返回null
    if(x == null) return null;
    int cmp = key.compareTo(x.key);
    if(cmp < 0) return get(x.left,key);
    else if(cmp > 0) return get(x.right,key);
    else return x.value;
}

public void put(Key key,Value value){
    //查找Key，找到则更新值，否则为它创建一个新的结点
    root = put(root,key,value);
}

private Node put(Node x,Key key,Value value){
    //如果Key存在于以x为根节点的子树中则更新它的值
    //否则将以key和val为键值对的新结点插入到该子树中
    if(x == null) return new Node(key,value,1);
    int cmp = key.compareTo(x.key);
    if(cmp < 0) x.left = put(x.left,key,value);
    else if(cmp > 0) x.right = put(x.right,key,value);
    else x.value = value;
    x.N = size(x.left) + size(x.right) + 1;
    return x;
}
```

## **二叉查找树的有序性相关的方法和删除操作**

保持键的有序性是二叉查找树被广泛使用的一个原因。

### **1.最大键和最小键**

若根结点左链接为空，则根结点是最小键，否则就是左子树的最小键，即递归实现。最大键就是右子树。
```
public Key min(){
    return min(root).key;
}

private Node min(Node x){
    if(x.left == null) return x;
    return min(x.left);
}

public Key max(){
    return max(root).key;
}

private Node max(Node x){
    if(x.right == null) return x;
    return max(x.right);
}
```
### **2.向上取整和向下取整**

  若给定键小于根结点的键，则floor一定在左子树中；若给定键大于根结点的键，只有当根结点右子树中存在小于等于Key的结点时，小于等于Key的最大键才出现于右子树，否则就是根结点。
```
public Key floor(Key key){//向下取整
    Node x = floor(root,key);
    if(x == null) return null;
    return x.key;
}

private Node floor(Node x,Key key){//向下取整
    if(x == null) return null;
    int cmp = key.compareTo(x.key);
    if(cmp == 0) return x;
    else if (cmp < 0) return floor(x.left,key);
    Node t = floor(x.right,key);
    if(t != null) return t;
    else return null;
}

public Key ceiling(Key key){//向上取整
    Node x = ceiling(root,key);
    if(x == null) return null;
    return x.key;
}

private Node ceiling(Node x,Key key){//向上取整
    if(x == null) return null;
    int cmp = key.compareTo(x.key);
    if(cmp == 0) return x;
    else if (cmp > 0) return ceiling(x.right,key);
    Node t = ceiling(x.left,key);
    if(t != null) return t;
    else return null;
}
```
### **3.选择操作**

假设需要寻找排名为k的键，若左子树中的结点数t大于k，继续在左子树中查找，若等于则返回根结点的键，若大于则在右子树中查找排名为k-t-1的键。
```
public Key select(int k){
    return select(root,k).key;
}

private Node select(Node x,int k){
    //返回排名为k的结点
    if(x == null) return null;
    int t = size(x.left);
    if(t > k) return select(x.left,k);
    else if(t > k) return select(x.right,k-t-1);
    else return x;
}
```

### **4.排名**

rank()是select()的逆方法，它会返回给定键的排名。实现方法和select()类似，给定键和根结点键相等返回左子树结点总数t，若给定键小于根结点则返回其在左子树中的排名，大于根结点则返回t+1+右子树中的排名
```
public int rank(Key key){
    return rank(key,root);
}

private int rank(Key key,Node x){
    //返回以x为根结点的子树中小于x.key的键的数量
    if(x == null) return 0;
    int cmp = key.compareTo(x.key);
    if(cmp < 0) return rank(key,x.left);
    else if(cmp > 0) return 1 + size(x.left) + rank(key,x.right);
    else return size(x.left);
}
```

### **5.删除最大键和最小键**

删除操作是二叉树最难实现的部分，删除最小键需要不断深入根结点的左子树直到遇到一个空链接，然后将指向当前结点的链接指向该结点的右子树（只需要在递归调用中返回它的右链接即可）。
```
public void deleteMin(){
    root = deleteMin(root);
}

private Node deleteMin(Node x){
    if(x.left == null) return x.right;
    x.left = deleteMin(x.left);
    x.N = size(x.left) + size(x.right) + 1;//?
    return x;
}

public void deleteMax(){
    root = deleteMax(root);
}

private Node deleteMax(Node x){
    if(x.right == null) return x.left;
    x.right = deleteMax(x.right);
    x.N = size(x.left) + size(x.right) + 1;//?
    return x;
}
```

### **6.删除操作**

删除一个没有或只有一个子结点的结点是上个所做操作，但删除操作通常是对有两个子结点的结点进行删除，如何处理两颗子树是一个问题。第一个方法：删除某结点x，将其后继结点填补它的位置，因为x有右子结点，所以后继结点就是右子树的最小结点，如此替换能保证树的有序性，因为x结点和其后继结点没有键关联，所以需要通过以下步骤完成替换流程：
 * 将指向将被删除结点的链接保存为t。
 * 将x指向它的后继结点min(t.right)。
 * 将x的右链接（原本指向一棵所有结点都大于x.key的二叉查找树）指向deleteMin(t.right)，即删除后所有结点仍大于x.key。
 * 将x的左链接设为t.left。
 * 更新链接和结点计数器。
```
public void delete(Key key){
    root = delete(root, key);
}

private Node delete(Node x,Key key){
    if(x == null) return null;
    int cmp = key.compareTo(x.key);
    if(cmp < 0) x.left = delete(x.left,key);
    else if(cmp > 0) x.right = delete(x.right,key);
    else{
        if(x.right == null) return x.left;
        if(x.left == null) return x.right;
        Node t = x;
        x = min(t.right);//?
        x.right = deleteMin(t.right);
        x.left = t.left;
    }
    x.N = size(x.left) + size(x.right) + 1;//?
    return x;
}
```

### **7.范围查找**

要返回给定范围内键的方法，需要参考中序遍历的方法，将所有落在给定范围内的键加入队列Queue中，跳过不可能含有所查找键的子树。

先序遍历：
中序遍历：
后序遍历：

```
public Iterable<Key> keys(){
    //二叉查找树范围查找
    return keys(min(),max());
}

public Iterable<Key> keys(Key lo,Key hi){
    MyQueue<Key> queue = new MyQueue<Key>();
    keys(root,queue,lo,hi);
    return queue;
}

private void keys(Node x,MyQueue<Key> queue,Key lo,Key hi){
    if(x == null) return;
    int cmplo = lo.compareTo(x.key);
    int cmphi = hi.compareTo(x.key);
    if(cmplo < 0) keys(x.left,queue,lo,hi);
    if(cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key);
    if(cmphi > 0) keys(x.right,queue,lo,hi);
}
```

### **8.性能分析**

(未完待续...)




