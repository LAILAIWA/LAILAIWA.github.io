---
title: Java反射
date: 2018-12-18 10:25:05
tags: [java]
description: 涉及内容：Java反射机制
categories: 技术文档
photos: 
    - "https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/instagram___BqJDbt-Afp8___.jpg"
---
{% aplayer "恋 Strings & Piano" "末廣健一郎" 
"https://music-1258215793.cos.ap-shanghai.myqcloud.com/%E6%9C%AB%E5%BB%A3%E5%81%A5%E4%B8%80%E9%83%8E%20-%20%E6%81%8B%20Strings%20%26%20Piano%20ver.%20%5BInstrumental%5D.mp3" "http://p1.music.126.net/b4jLpCyHqVpDO_7MzlUNuQ==/18558656766889374.jpg" "autoplay" %}

*参考博客：https://blog.csdn.net/xiaohanluo/article/details/52034127*

*因博客主未标明不可转载，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容*

## **反射和泛型**

### **定义**

&emsp;&emsp;能够在运行时分析类称为反射，如泛型类在编译后会比擦除，但通过反射可以获取泛型类的信息，反射会将.class类的信息映射为Class对象，通过Class对象的方法可以获得类的各种信息。

### **作用**
1. 在运行时分析类
2. 在运行时查看对象
3. 实现通用的数组操作代码
4. 利用Method对象

&emsp;&emsp;编写应用程序很少会使用反射，因为性能不好，而且破坏了类的封装，大部分场景并不会用到反射。反射常用于编写工具和框架，最近会在写一些导出各种格式工具时用到。

### **简要介绍**

>Java.lang.reflect包中提供了接口Type

* Class<T> 实现了Type接口
* TypeVariable，WildcardType，ParameterizedType，GenericArrayType等接口继承了Type，其中TypeVariable描述类型变量，如T extends Comparable<? super T>
* WildcardType描述通配符，如? super T
* ParameterizedType描述泛型类或接口类型，如Comparable<? super T>
* GenericArrayType描述泛型数组，如T[]

|类|	说明|
|:------:|------|
|Class|	在反射过程中表示内存中的一个Java类，Class可以表示类，接口，原始数据类型，数组等|
|Object	|Java中所有类的超类|
|Constructor|	封装了类的构造函数的属性信息，包括访问权限和动态调用信息|
|Field	|提供了类或接口的成员变量属性信息，包括访问权限和动态修改|
|Method|	提供了类或接口的方法属性信息，包括访问权限和动态调用信息|
|Modifier|	封装了修饰属性: public,protected,static,final,synchronized,abstract等|

**Class类**

&emsp;&emsp;在程序运行时，Java会为所有对象维护一个叫做运行时的类型标识。根据此信息可以跟踪到每个对象所属的类，JVM会使用这些信息执行相应的方法。保存这些信息的类叫Class，Object类中的getClass()方法会返回一个Class类型实例。Class对象记录对应特定类的属性，如getName()方法获取类的名字(forName()方法则根据类名获取Class对象)

### **编程测试**

以下代码接用<Java核心技术>相关章节思路，通过反射剖析输入类的各种信息，只涉及解析类：

```
public static void main(String[] args){
    String name;
    if(args.length > 0) name = args[0];
    else {
        try(Scanner in = new Scanner(System.in)){
            System.out.println("请输入class name: ");
            name = in.next();
        }
    }

    try{
        Class<?> cl = Class.forName(name);
        printClass(cl);
        System.out.println("Methods: ");
        for(Method method : cl.getDeclaredMethods())
            printMethod(method);
    }catch (ClassNotFoundException ex){
        ex.printStackTrace();
    }
}

//打印类信息
public static void printClass(Class<?> cl){
    System.out.println("Class<?>: " + cl);
    printTypes(cl.getTypeParameters(),"<",",",">",true);//若为泛型类型则获取泛型类型变量，否则返回长度0数组
    Type sc = cl.getGenericSuperclass();//获得被声明为这一类型的超类的泛型类型，若是Object，或不是类返回null
    if(sc != null){
        System.out.print(" extends ");
        printType(sc,false);
    }
    printTypes(cl.getGenericInterfaces(),"<",",",">",false);//获得被声明为这一类型的接口的泛型类型，若没有实现接口，返回长度0数组
    System.out.println();
}

//打印方法信息
public static void printMethod(Method method){
    String name = method.getName();
    System.out.print(Modifier.toString(method.getModifiers()));
    System.out.print(" ");
    printTypes(method.getTypeParameters(),"<",",",">",true);//若方法为泛型方法，则获得泛型变量，否则返回长度0数组

    printType(method.getGenericReturnType(),false);//获得此方法被声明的泛型返回类型
    System.out.print(" ");
    System.out.print(name);
    System.out.print("(");
    printTypes(method.getGenericParameterTypes(),"<",",",">",true);//获得此方法被声明的泛型参数类型，若无参数，则返回长度0数组
    System.out.print(")");
    System.out.println("");
}

//打印泛型类型信息
public static void printTypes(Type[] types,String pre,String sep,String suf,boolean isDefinition){
    if(pre.equals(" extends ") && Arrays.equals(types,new Type[]{Object.class})) return;
    if(types.length > 0) System.out.print(pre);
    for(int i = 0;i < types.length;i++){
        if(i > 0) System.out.print(sep);
        printType(types[i],isDefinition);
    }
    if(types.length > 0) System.out.print(suf);
}

//打印类型信息
public static void printType(Type type,boolean ifDefinition){
    if(type instanceof Class){
        Class<?> t = (Class<?>) type;
        System.out.print(t.getName());//获得类型变量名
    }else if(type instanceof TypeVariable){
        TypeVariable<?> t = (TypeVariable<?>) type;
        System.out.print(t.getName());
        if(ifDefinition)
            printTypes(t.getBounds()," extends "," & ","",false);//获得类型变量的子类限定
    }else if(type instanceof WildcardType){
        WildcardType t = (WildcardType) type;
        System.out.print("?");
        printTypes(t.getUpperBounds()," extends "," & ","",false);//获得这个类型变量的子类extends限定，否则0数组
        printTypes(t.getLowerBounds()," super "," & ","",false);//获得这个类型变量的超类super限定，否则0数组
    }else if(type instanceof ParameterizedType){
        ParameterizedType t = (ParameterizedType) type;
        Type owner = t.getOwnerType();//若是内部类型，返回其外部类型，若是顶级类型，返回null
        if(owner != null){
            printType(owner,false);
            System.out.print(".");
        }
        printType(t.getRawType(),false);//获得这个参数化类型的原始类型
        printTypes(t.getActualTypeArguments(),"<",",",">",false);//获得这个参数化类型声明时所使用的类型参数
    }else if(type instanceof GenericArrayType){
        GenericArrayType t = (GenericArrayType) type;
        System.out.print("");
        printType(t.getGenericComponentType(),ifDefinition);//获得声明该数组类型的泛型组件类型
        System.out.print("[]");
    }
}
```

结果输出：

```
请输入class name: 

java.lang.String

Class<?>: class java.lang.String
 extends java.lang.Object<java.io.Serializable,java.lang.Comparable<java.lang.String>,java.lang.CharSequence>
Methods: 
 [B value()
 byte coder()
public boolean equals(<java.lang.Object>)
public int length()
public java.lang.String toString()
public int hashCode()
public void getChars(<int,int,[C,int>)
public int compareTo(<java.lang.String>)
public volatile int compareTo(<java.lang.Object>)
public int indexOf(<java.lang.String,int>)
public int indexOf(<int>)
public int indexOf(<int,int>)
static int indexOf(<[B,byte,int,java.lang.String,int>)
public int indexOf(<java.lang.String>)
static void checkIndex(<int,int>)
public static java.lang.String valueOf(<int>)
public static java.lang.String valueOf(<char>)
public static java.lang.String valueOf(<boolean>)
public static java.lang.String valueOf(<long>)
public static java.lang.String valueOf(<float>)
public static java.lang.String valueOf(<double>)
public static java.lang.String valueOf(<java.lang.Object>)
public static java.lang.String valueOf(<[C>)
public static java.lang.String valueOf(<[C,int,int>)
private static java.lang.Void rangeCheck(<[C,int,int>)
public java.util.stream.IntStream codePoints()
public boolean isEmpty()
public char charAt(<int>)
public int codePointAt(<int>)
public int codePointBefore(<int>)
public int codePointCount(<int,int>)
public int offsetByCodePoints(<int,int>)
public void getBytes(<int,int,[B,int>)
 void getBytes(<[B,int,byte>)
public [B getBytes(<java.nio.charset.Charset>)
public [B getBytes()
public [B getBytes(<java.lang.String>)
public boolean contentEquals(<java.lang.StringBuffer>)
public boolean contentEquals(<java.lang.CharSequence>)
private boolean nonSyncContentEquals(<java.lang.AbstractStringBuilder>)
public boolean equalsIgnoreCase(<java.lang.String>)
public int compareToIgnoreCase(<java.lang.String>)
public boolean regionMatches(<boolean,int,java.lang.String,int,int>)
public boolean regionMatches(<int,java.lang.String,int,int>)
public boolean startsWith(<java.lang.String,int>)
public boolean startsWith(<java.lang.String>)
public boolean endsWith(<java.lang.String>)
static int lastIndexOf(<[B,byte,int,java.lang.String,int>)
public int lastIndexOf(<int,int>)
public int lastIndexOf(<java.lang.String>)
public int lastIndexOf(<java.lang.String,int>)
public int lastIndexOf(<int>)
public java.lang.String substring(<int,int>)
public java.lang.String substring(<int>)
public java.lang.CharSequence subSequence(<int,int>)
public java.lang.String concat(<java.lang.String>)
public java.lang.String replace(<java.lang.CharSequence,java.lang.CharSequence>)
public java.lang.String replace(<char,char>)
public boolean matches(<java.lang.String>)
public boolean contains(<java.lang.CharSequence>)
public java.lang.String replaceFirst(<java.lang.String,java.lang.String>)
public java.lang.String replaceAll(<java.lang.String,java.lang.String>)
public [Ljava.lang.String; split(<java.lang.String>)
public [Ljava.lang.String; split(<java.lang.String,int>)
public static transient java.lang.String join(<java.lang.CharSequence,[Ljava.lang.CharSequence;>)
public static java.lang.String join(<java.lang.CharSequence,java.lang.Iterable<? extends java.lang.CharSequence>>)
public java.lang.String toLowerCase()
public java.lang.String toLowerCase(<java.util.Locale>)
public java.lang.String toUpperCase(<java.util.Locale>)
public java.lang.String toUpperCase()
public java.lang.String trim()
public java.util.stream.IntStream chars()
public [C toCharArray()
public static transient java.lang.String format(<java.lang.String,[Ljava.lang.Object;>)
public static transient java.lang.String format(<java.util.Locale,java.lang.String,[Ljava.lang.Object;>)
public static java.lang.String copyValueOf(<[C,int,int>)
public static java.lang.String copyValueOf(<[C>)
public native java.lang.String intern()
private boolean isLatin1()
static void checkOffset(<int,int>)
static void checkBoundsOffCount(<int,int,int>)
static void checkBoundsBeginEnd(<int,int,int>)
static [B access$100(<java.lang.String>)
static boolean access$200(<java.lang.String>)
```

