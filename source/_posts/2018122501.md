---
title: Java字符串内存分配-字符串常量池
date: 2018-12-25 15:08:28
tags: [java,jvm]
description: 涉及内容：字符串常量池-常量池表，运行时常量池，字符串常量池
categories: 技术文档
photos: 
    - "https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/instagram___BrBmyx_h9yy___.jpg"
---
{% aplayer "卒业" "日之内エミ" 
"https://music-1258215793.cos.ap-shanghai.myqcloud.com/%E6%97%A5%E4%B9%8B%E5%86%85%E3%82%A8%E3%83%9F%20-%20%E5%8D%92%E4%B8%9A%20-Congratulations-%20feat.%20Lotus%20Juice.mp3" "http://p2.music.126.net/PuwYUPqHXg-0a5xVQtpbSQ==/711384023193256.jpg" "autoplay" %}

*参考博客：*
>https://blog.csdn.net/u010297957/article/details/50995869

*因博客主未标明不可转载，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容*

# **字符串常量池：**

## **简述**

**1.常量池表(constant_pool table)：**

&emsp;&emsp;存储Class文件中所有常量(包括字符串)的表，是文件中的结构化数据而不是运行时内容。

**2.运行时常量池(Runtime Constant pool)：**

&emsp;&emsp;JVM运行时方法区中的某部分，属于运行时内容。其数据大部分(除了常量池中内容，还可能有动态生成加入的内容)都是由常量池表转换而来，每一个Class文件都对应一个运行时常量池。

**3.字符串常量池(String pool)：**

&emsp;&emsp;字符串常量池和运行时常量池区别：
1. 字符串常量池是JVM共享，全局只有一个，运行时常量池每个类都有一个。
2. 字符串常量池只记录字符串对象，运行时常量池记录各种对象。

&emsp;&emsp;JVM规定进入字符串常量池的实例叫被驻留的字符串-interned string，各个JVM可能有不同的实现，HotSpot是设置一个哈希表来引用堆中的字符串实例，被引用就是被驻留。

&emsp;&emsp;字符串池在JDK1.7版本后存于Heap堆中，旧版本存于方法区中。

**4.享元模式**

&emsp;&emsp;字符串常量池涉及到一个设计模式：享元模式，即共享元素模式。

&emsp;&emsp;含义是：一个系统若有多处用到了同一元素，那么应该只定义存储一份，然后让所有地方引用此元素。

&emsp;&emsp;字符串String就是依照此模式设计，字符串常量池就是存储元素的地方。

## **代码测试**

### **假设main函数中声明了如下变量：**

```
int a = 1;
String b = "ori";
```

&emsp;&emsp;1和”ori”会经过编译后存入Class文件中的constant_pool table

&emsp;&emsp;当程序运行时，每个Class文件中的constant_pool table会被加载到JVM内存中的方法区内，存放在对应Class对象的Runtime Constant pool中。

&emsp;&emsp;若字符串未被包含在String pool中(如何判断?用equals来比较Runtime Constant pool的字符串和String pool中某一个是否相等)，会先在堆中根据String数据创建一个String对象，然后将String数据和对象引用在哈希表中关联起来，String数据是Key，而对象引用地址是值。（注意String数据表示String pool中”ori”，String对象表示堆中对象）

### **创建了多少对象？**

```
String s = new String("abc");
```

&emsp;&emsp;执行过程：

&emsp;&emsp;首先根据String数据去String pool中查找是否有相同字符串存在，若不存在就在String pool中创建数据，然后关键字new会在堆中新建对象，调用String构造器进行初始化，将引用地址赋值给变量s；

&emsp;&emsp;若存在就在堆中新建一个对象，不会再向String pool新建数据了，直接返回对象引用。
所以创建了2或1个对象。

### **判断输出结果？**

```
String s1 = "abc";
String s2 = new String("abc");
String s3 = "abc";
String s4 = "a" + "bc";
String s5 = new String("abc");
System.out.println(s1 == s2);
System.out.println(s1 == s3);
System.out.println(s1 == s4);
System.out.println(s2 == s5);
System.out.println(s1 == s1.intern());
```

&emsp;&emsp;结果：

```
false
true
true
false
true
```

&emsp;&emsp;解析：

* s1引用指向String pool中"abc"，s2因为new创建新对象，只要是new在堆中创建新对象，引用肯定是不同的。
* 是对同一String pool中字符串数据的引用，所以引用地址相同。
* 是对同一String pool中字符串数据的引用，所以引用地址相同。
* s2引用指向String pool中"abc"，s5因为new创建新对象，只要是new在堆中创建新对象，引用肯定是不同的。
* s1.intern()将String对象在运行期动态加入String pool并返回其引用，所以和s1是相同引用

