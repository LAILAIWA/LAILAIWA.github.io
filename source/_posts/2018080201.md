---
title: Java知识点总结 (一)
date: 2018-08-02 10:07:53
tags: [java]
categories: 技术文档
photos: 
    - "https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/alilouss_2___BYNkP89A-Tk___.jpg"
---
{% aplayer "Lemon" "米津玄師" 
"https://music-1258215793.cos.ap-shanghai.myqcloud.com/%E7%B1%B3%E6%B4%A5%E7%8E%84%E5%B8%AB%20-%20Lemon.mp3" "http://p1.music.126.net/r0TgUXBEEmMG48KSsEa_mg==/109951163143657970.jpg" "autoplay" %}

1. 什么是Java的字节码？
>程序的低级表示，能运行在java虚拟机，程序抽象为字节码能保证代码运行于各种设备之上

2. Java允许整形溢出并返回错误值，Java为什么不自动检查溢出
>之所以成为原始数据类型就是缺乏溢出检查，避免此类问题只要在合适的场景使用合适的数据类型，小于10位十进制的整型用int，大于则用long

3. double值初始化为无穷大
>DOUBLE.POSITIVE_INFINITY DOUBLE.NEGATIVE_INFINITY

4. 不同数据类型值相互比较？
>需要先进行类型转换，Java一般会在比较前自动转换

5. 1/0和1.0/0.0值分别是？
>除以零异常，无穷大

6. 负数的除法和求余
>除法会向零取整，求余则基于(a/b)*b + a%b = a，所以当a为14，b为-3，余数为2

7. &,|,^与&&,||
>&,|,^为整数位逻辑操作，如10|6 = 1010|110=1110=14，10^6=1100=12
后者是短路求值逻辑判断，从左向右一旦整个表达式已知则停止求值

8. for循环和while循环的区别
>主要是递增变量，while循环递增变量循环结束还是可以使用的，for循环则不行

9. 为什么数组起始索引是0不是1？
>源于机器语言，获取数组某元素的地址需要数组的起始地址加上元素的索引，若起始为1则每次都要减一

10. Java中一个静态方法可以将另一个静态方法作为参数吗？
>不可以，虽然很多语言都可以

11. Java中的e表示10的次方，如2.0e-6为2.0*10^(-6)

12. Java中的抽象数据类型ADT
>所有对象的三大特性：状态，标识，行为。
>* 状态：即数据类型中的值
>* 标识：即内存中的位置
>* 行为：即数据类型的操作
>
>Java对象用引用类型来区别于原始数据类型，可以认为引用就是内存地址。

13. 静态方法与非静态方法
>静态方法的主要作用是实现函数，方便在不创建对象的情况下调用方法和变量
>
>Static方法不能调用非静态方法，反之则可以。
>* **static方法**：不依赖于对象，所以没有this，因此不能访问非静态变量和方法，因为它们的调用要依赖于具体的对象。
>* **static变量**：静态变量被所有对象共享，内存中只能有一个，仅在类加载时被初始化。static不允许修饰局部变量，局部就说明方法的生命周期决定变量的存活时期，static修饰的变量会扩充到整个类，有语法冲突
>* **static代码块**：静态代码块来优化程序性能，类初次加载时会执行一次静态代码块，可以将一些只需要初始化的操作和数据放在静态代码块中。
>
>父类静态代变量->父类静态代码块->子类静态变量->子类静态代码块->父类非静态变量（父类实例成员变量）->父类构造函数->子类非静态变量（子类实例成员变量）->子类构造函数

14. 赋值与复制，副本
>赋值语句给对象传递的是同个内存位置的引用，即起别名。
>
>对于原始数据类型则是拷贝值，生成副本。
>
>而引用类型则复制的是引用，仍是同一对象。

15. 参数传递
>按值传递：将参数值的副本传递给方法。方法无法改变调用端变量的值，原始数据类型正期望如此。
>
>引用类型传递：每次传递的都是对象的引用

16. 数组
>Java中所有非原始数据类型都是对象，所以字符串String，数组都是对象。

17. 字符串
>String和数组类似，但二者有区别，数组通过内置语法访问每个字符，而字符串为索引访问，为字符串操作准备了很多实例方法。
>
>**为什么不用字符数组替代String？**
>* 为了让代码简洁清晰，String是更高级别的封装，有面向对象的思想

18. 重载和重写
>* **重载overloading**：
   同一类中，体现多态性，相同名字的方法，参数个数或类型不同，返回值可同或不同，但不能以返回值区别，访问修饰可以不同，异常也可以不同。
   对于继承，访问权限也会影响重载，父类private时子类认为是新建了方法。
>* **重写overrite**：
不同类中，受限于父方法的访问修饰类型，如默认default时只能被同包内的子类重写，protected能被不同包子类重写
参数列表要相同，返回类型也要相同
访问修饰符要大于父类方法，
不能抛出新的或更广泛的异常检查

19. 维护多个实现
>同一份API的多个实现可能会有维护和命名问题，而且常常需要维护多个版本，通常采用前缀命名约定来应付这种问题，但当系统庞大时，这样不算十分理想，当API维护后还需要修改用例代码，当与泛型和迭代器一起使用会有问题。

20. 四大特性的优点
>* **抽象：**
      以前是觉得抽象类意义不大，但看过一些言论后，感觉还是有其存在意义，

>* **封装：**
>1.	隐藏信息和内部实现细节，提高安全性
>2.	实现了分工，需要时调用
>3.	降低代码耦合度，促进代码复用，API不变却可以更新实现，提升软件质量

>* **继承：**
      1.实现代码复用

>* **多态：**
      1.代码上对封装和继承的体现，如父类引用不同子类表现不同的行为，同样的方法名重载后有不同的实现。

21. 抽象类和接口
>* **接口继承** implements 继承接口使我们能操作实现该接口的任意类型对象
>* **子类继承** extends
>
>(破坏封装，与前者优劣未有定论) 

22. 原始数据类型和封装类型
>Java中封装的引用类型称为封装类型，在需要的时候Java自动将原始数据类型转换为封装类型，如int和String拼接时，int自动转为Integer并调用toString方法

23. 对象的等价性
>== 对于原始数据类型比较的是值，对于非原始数据类型则判断引用或者说标识是否相同，但封装类型有特例，如Integer若值为-128到127则存入常量池比较的是值。
>
>要调用equals方法，自定义数据类型时需要重载equals方法
要求：
>1.	自反性：x.equals(x)=true
>2.	对称性：y.equals(x)=true 则 x.equals(y)=true
>3.	传递性：x.equals(y)=true，y.equals(z)=true 则 x.equals(z)=true
>4.	一致性：值未更改时x.equals(y)=true恒定
>5.	非空性：x.equals(null)=false恒定

24. Java内存管理，垃圾回收
>原始数据类型在编译阶段就可获取内存所需信息，而对象失去调用后成为孤儿，C和C++由程序员来释放孤儿内存，Java则有GC垃圾回收，不允许修改引用
>
>避免一些GC无法识别到的孤儿—对象游离，只需要将其赋值null

25. final
>保证不可变性，再次赋值会报编译错误，如String和数组的区别，String是不可变的，数组可变，这类设计取决于我们对他们的期望。
>
>这点也是StringBuilder和Vector等存在的目的之一。
>
>但final有个缺点，它限制的是赋值语句，所以final只能限制于原始数据类型，当修饰引用类型的变量时，它将永远指向同一个对象，但对象的值仍是可变的。如final一个int[]，仍可以修改元素
>
>final修饰类，类无法被继承，成员方法都会隐式的指定为final方法
>
>final 修饰方法，使用这种方法的原因：
>1.	锁定方法，防止被修改，private会隐式的指定为final方法，所以一般用来锁定被子类继承的方法。
>2.	提高效率，早期会将final方法转为内嵌调用，新版本不需要如此优化
>
>final修饰变量时，封装类型和String加final修饰时会被当作编译常量
>
>final和static的区别：对于成员变量，static表示只保留一份副本，final表示变量不可变，final对于不同的对象可能就不同，static则是一定相同的

26. Stirng，StringBuilder，StringBuffer

*参考博客：https://www.cnblogs.com/su-feng/p/6659064.html*

区别主要是在两个方面，即**运行速度**和**线程安全**这两方面。

>运行速度快慢为：StringBuilder > StringBuffer > String

>String最慢的原因：
>
>&nbsp;&nbsp;String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，隐式final，但后两者的对象是变量，是可以更改的。
```
String str="abc";
System.out.println(str);
str=str+"de";
System.out.println(str);
```
>&nbsp;&nbsp;如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。
>
>&nbsp;&nbsp;而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。

>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的
如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。

>总结一下:
>* **String**：适用于少量的字符串操作的情况
>* **StringBuilder**：适用于单线程下在字符缓冲区进行大量操作的情况
>* **StringBuffer**：适用多线程下在字符缓冲区进行大量操作的情况


27. 异常错误和断言
>断言是一条需要在程序的某处确认为true的布尔表达式，当值为false程序会中止并报告出错信息，只用来测试。


*参考博客：https://blog.csdn.net/lan12334321234/article/details/70049446/*
>Exception Error
>
>java异常分为两种：**运行时异常**（RuntimeException）和**非运行时异常**（CheckedException）也叫**检查式异常**。
>1. 运行时异常是不需要捕获的，程序员可以不去处理，当异常出现时，虚拟机会处理。常见的运行时异常有空指针异常
>
>常见的5中运行时异常：
>* ClassCastException(类转换异常) 
>* IndexOutOfBoundsException(数组越界) 
>* NullPointerException(空指针) 
>* ArrayStoreException(数据存储异常，操作数组时类型不一致) 
>* 还有IO操作的BufferOverflowException异常
>2. 非运行时异常就必须得捕获了，否则编译不过去，java编译器要求程序员必须对这种异常进行catch,Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。
>
>常见的非运行异常有io异常和sql异常：IOException、FileNotFoundExcetion 和SQLException

>finally是异常处理工作的一部分，表示总是执行。一般finally写的代码语句就是流的关闭。也就是做了一项清理，工作清理工作对于我们来说是必不可少的，因为如果一些消耗资源的操作，比如IO,JDBC。如果我们用完以后没有及时正确的关闭，那后果会很严重，这意味着内存泄露。 

>异常处理中的throws和throw的区别： 
>1. throws出现在方法的声明中，表示该方法可能会抛出的异常，允许throws后面跟着多个异常类型 
>2. throw出现在方法体中，用于抛出异常。当方法在执行过程中遇到异常情况时，将异常信息封装为异常对象，然后throw。

28. Java中的引用和指针
>指针可以看作机器地址，Java创建引用只能通过new，改变引用只能通过赋值，所以Java的引用叫安全指针

29. 变量
>* **成员变量**：作用范围是整个类，相当于C语言中的全局变量，定义在方法体和语句块之外，一般定义在类的声明之下;成员变量包括：实例变量、类变量(又叫静态变量)和常量。
>* **局部变量**：作用范围在它定义的方法体或者语句块内部，出了这个范围就无效了。
>* **实例变量**：不用static修饰的成员变量，随对象的创建而创建，每个对象都有自己的独有的实例变量，属于对象私有;调用要实例化对象，用对象名.实例变量名才可以调用，如：Demo demo = new Demo(); int YouAge = demo.age;(当然，一般都会将成员变量设为private，通过属性方法调用)。
>* **静态变量**：有时叫全局变量，和实例变量区别就是不和对象关联。用static修饰的成员变量，又叫类变量，一个类里只有一份，属于对象共有，调用是一般用类名.静态变量名就可以调用，或者用对象名.静态变量名也可以调用，调用的都是同一个变量，如:Demo.height。

30. 泛型和迭代
>* **泛型**<>，参数化类型，象征性的占位符，没有泛型，我们需要为所有数据类型定义不同的API。
>
>* **迭代**，foreach语句通过迭代遍历或处理集合中的每个元素，需要集合数据类型需要实现iterable接口，添加iterator方法并返回一个Iterator迭代器对象，迭代器对象包含hasNext和next方法

31. 自动装箱和自动拆箱
>类型化参数必须实例化为引用类型，所以Java对于原始数据类型和封装类型进行了自动转换。
```
List<Integer> list = new ArrayList<>();
list.add(11); //自动装箱 int->Integer
int i = list.get(0); //自动拆箱 Integer->int 
```
32. 内部类
>* **成员内部类**，定义于另一个类的内部，可以任意访问外部类的属性和方法，如果同名默认内部类成员，外部类访问内部类需要先实例对象，内部类访问权限和属性一样有四种
>* **局部内部类**，定义于方法或作用域内部，访问权限只限于该方法或作用域，类似局部变量不能有访问修饰以及静态修饰
>* **匿名内部类**，new ClassName(){@override......},实现父类或接口的同时产生一个实例对象，当然要先存在该父类或接口，同样不能用访问修饰以及静态修饰。唯一没有构造器的内部类，所以一般只用来做接口回调，不需要增加方法，只重写或实现继承的方法
>* **静态内部类**，定义于另一个类内部但多了static修饰，所以不依赖外部类，也不能使用外部类非static成员。

>**成员内部类如何无条件引用外部类成员？与静态内部类区别？**
>
>成员内部类会单独编译为一个字节码文件，编译器会为成员内部类添加指向外部类对象的引用，即使内部类是无参构造器，编译仍默认加外部类对象的引用，所以也知道成员内部类会依赖于外部类对象。
>
>静态内部类区别于成员内部类，不依赖外部类对象，可以直接创建内部类对象，且不包含外部类引用的。

>**为什么局部内部类和匿名内部类只能访问局部final变量？**
>
>如一个方法调用线程TheadA，方法内有局部变量a，那么方法执行完毕，a生命周期就结束了，但此时线程A还可能在执行，此时无法访问a怎么办？Java编译器会默认在局部或匿名内部类的常量池增加一个相同的值嵌入执行字节码，如此匿名内部类只是使用的副本，而非方法中的变量a，当然a有可能是不确定值的参数，编译时无法确定值，所以会通过构造器传参的方式来对副本初始化赋值。因此可以明白，如果局部变量改变的话会导致数据不一致，所以Java直接限制只能访问final局部变量。

>内部类使用场景和优点：
>1.	内部类独立继承接口，而不用管外部类如何，所以是Java解决多继承的方案
>2.	方便将关系紧密的类结合，并对外界隐藏
>3.	方便编写事件驱动
>4.	方便编写线程代码
```
public class Test{
    public static void main(String[] args){
           // 初始化Bean1
           (1)
           bean1.I++;
           // 初始化Bean2
           (2)
           bean2.J++;
           //初始化Bean3
           (3)
           bean3.k++;
    }
    class Bean1{
           public int I = 0;
    }
 
    static class Bean2{
           public int J = 0;
    }
}

class Bean{
    class Bean3{
           public int k = 0;
    }
}
```

>1. Test test = new Test();
>Test.Bean1 bean1 = test. new Bean1();
>
>2. Test.Bean2 bean2 = new Test.Bean2();
>
>3. Bean bean = new Bean();
> Bean.Bean3 = bean.new Bean3();

33. 字符串和子字符串
>计算内存消耗时可以知道：原始数据类型占用字节：char-2字节，int-4字节，double/long-8字节，而对象需要16字节的对象开销，引用即机器地址一般为8字节。所以一个String字符串内存开销：对象开销16+char数组引用8+偏移量int4+字符串长度int4+散列值int4+填充字节+4  + char数组24+2N = 40+24+2N=64+2N
>
>创建子字符串时，如substring(3,6) 会创建一个新String对象，但其和原字符串共用一个char数组，所以其内存开销为常数：40


