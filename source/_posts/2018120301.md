---
title: 由一个基础问题回顾几个Java基础知识
date: 2018-12-03 11:58:12
tags: [session,bug]
description: 涉及内容：自动装箱和自动拆箱，包装类，参数传递，变量与内存等
categories: 技术文档
photos: 
    - "https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/football__hqs____utm_source=ig_share_sheet&igshid(2).jpg"
---
{% aplayer "OMG" "Arash/Snoop Dogg" 
"https://music-1258215793.cos.ap-shanghai.myqcloud.com/Arash%2CSnoop%20Dogg%20-%20OMG%20(Radio%20Edit).mp3" "http://p1.music.126.net/ux_HuTbvbtgebF8vAbfg7A==/3394192398797732.jpg" "autoplay" %}

&emsp;&emsp;涉及内容：自动装箱和自动拆箱，包装类，参数传递，变量与内存等
                            
## **思考问题**

>当String作为方法参数时，和包装类型一样都不会因为方法内的值改变导致原值变化

&emsp;&emsp;一直没有去深入思考其中的原因和细节，所以抽空通过简单的编程和知识回顾整理了类似过程的实现细节。

## **编程测试**

首先通过编写简单的演示代码来观察整个过程:

```
public class test {
    public static void main(String[] args){
        Integer a = 0;
        Float b = 0.0f;
        String c = "original";
        Student student = new Student("001","张三","男",18,60.0f);

        System.out.println("调用前: " + a);
        System.out.println("调用前: " + b);
        System.out.println("调用前: " + c);
        System.out.println("调用前: " + student.toString());

        change1(a);
        change1(b);
        change1(c);
        change1(student);

        System.out.println("第一次调用后: " + a);
        System.out.println("第一次调用后: " + b);
        System.out.println("第一次调用后: " + c);
        System.out.println("第一次调用后: " + student.toString());

        change2(a);
        change2(b);
        change2(c);
        change2(student);
        System.out.println("第二次调用后: " + a);
        System.out.println("第二次调用后: " + b);
        System.out.println("第二次调用后: " + c);
        System.out.println("第二次调用后: " + student.toString());
    }

    private static void change1(Integer a){
        System.out.println("函数内: " + a);
        a = 1;
    }

    private static void change1(Float b){
        System.out.println("函数内: " + b);
        b = 1.0f;
    }

    private static void change1(String c){
        System.out.println("函数内: " + c);
        c = "changed";
    }

    private static void change1(Student student){
        student.setId("002");
        student.setName("小兰");
        student.setSex("女");
        student.setAge(17);
        student.setScore(100.0f);
    }

    private static void change2(Integer a){
        a = Integer.valueOf(1);
    }

    private static void change2(Float b){
        b = Float.valueOf(1.0f);
    }

    private static void change2(String c){
        c = new String("changed");
    }

    private static void change2(Student student){
        student = new Student("003","小明","男",17,60.0f);
    }
}
```

测试结果:

```
调用前: 0
调用前: 0.0
调用前: original
调用前: Student{id='001', name='张三', sex='男', age=18, score=60.0}
函数内: 0
函数内: 0.0
函数内: original
第一次调用后: 0
第一次调用后: 0.0
第一次调用后: original
第一次调用后: Student{id='002', name='小兰', sex='女', age=17, score=100.0}
第二次调用后: 0
第二次调用后: 0.0
第二次调用后: original
第二次调用后: Student{id='002', name='小兰', sex='女', age=17, score=100.0}
```

&emsp;&emsp;根据结果可以发现Main函数中定义的包装类型在调用函数中修改后，其value是不变的，而抽象对象的成员变量则改变了。所以String也可以看作是包装类型，它有点像是char[]的包装类。

&emsp;&emsp;包装类作为方法参数调用时应该和普通对象一样，传递的同样是引用。那么为什么最终值却没有变化呢？

## **知识点回顾**

### **包装类**

首先回顾一下包装类：

|基本类型|	包装类型|
|:------:|:------:|
|byte	|Byte|
|int	|Integer|
|short	|Short|
|long	|Long|
|float	|Float|
|double	|Double|
|boolean	|Boolean|
|char	|Character|

### **引用类型**

回顾一下引用类型和基本数据类型的区别：

&emsp;&emsp;存储位置不同(基本数据类型根据其作为成员变量或局部变量分别存在堆和栈中，引用类型则同时占用堆和栈，数据存在堆中，堆地址存于栈中)

Java内存结构：
1. 程序计数器 
2. 本地方法栈 
3. 方法区(字节码，常量，静态变量，共享区域) 
4. 虚拟机栈(方法帧，局部变量，可共享) 
5. 堆(引用类型，成员变量))

……

### **变量**

再回顾一下变量的作用域：
* 成员变量：整个类
* 局部变量：定义的方法体或语句块中，执行完方法出栈后就无效了。
成员变量可以分为实例变量和类变量/静态变量/全局变量
* 实例变量：对象私有
* 类变量/静态变量/全局变量：static修饰，不和对象关联，对象共用

## **过程分析**

由以上知识可以绘制如下过程：

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120301.png "")

分析运行过程：
1. 首先在main函数中定义了成员变量Integer a,String c，Student student等，并赋值0和”original”等，存放引用于栈中，值则分别存于堆的对应区域。
2. 分别调用函数change1，作为形参传入参数，然后分别赋值1和” changed”，change执行到}结束，存放于栈中的局部变量生命结束并销毁，而跳回main函数，栈内对应区域可以看作被清除，所以只有抽象对象student因为X001内存中对应的值被修改导致main函数中也改变了。
3. 分别调用函数change2，可以发现执行新建对象，只是在change2函数内改变引用，其作为局部变量只存活到函数执行结束，而不会影响main函数中对象引用。

&emsp;&emsp;所以可以得知为何String和包装类型不会因为调用函数而改变原值了。

## **附件-源代码**

&emsp;&emsp;如Int a = 3; 赋值时自动装箱，调用valueof函数，查看代码所进行的操作

### **Integer**

```
private final int value;

public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

public static Integer valueOf(String s, int radix) throws NumberFormatException {
    return Integer.valueOf(parseInt(s,radix));
}

public static Integer valueOf(String s) throws NumberFormatException {
    return Integer.valueOf(parseInt(s, 10));
}
```

&emsp;&emsp;如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象，否则返回 new 一个Integer 对象。结果都导致了a指向了一个新的内存空间。

### **Float**

```
private final float value;

public static Float valueOf(String s) throws NumberFormatException {
    return new Float(parseFloat(s));
}

public static Float valueOf(float f) {
    return new Float(f);
}

public static float parseFloat(String s) throws NumberFormatException {
    return FloatingDecimal.parseFloat(s);
}
```

### **String**

```
@Stable
private final byte[] value;

public static String valueOf(Object obj) {
    return (obj == null) ? "null" : obj.toString();
}

public static String valueOf(char data[]) {
    return new String(data);
}

public static String valueOf(char data[], int offset, int count) {
    return new String(data, offset, count);
}

public static String valueOf(boolean b) {
    return b ? "true" : "false";
}

public static String valueOf(char c) {
    char data[] = {c};
    return new String(data, true);
}

public static String valueOf(int i) {
    return Integer.toString(i);
}

public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}

```

&emsp;&emsp;String在赋值改变时，和包装类一致，即都会指向新的对象。

## **附件-DEBUG截图**

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120302.png "")

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120303.png "")

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120304.png "")

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120305.png "")

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120306.png "")

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120307.png "")

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120308.png "")

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120309.png "")

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120310.png "")

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120311.png "")

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20181203/2018120312.png "")
