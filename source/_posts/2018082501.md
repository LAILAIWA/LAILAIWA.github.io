---
title: Spring事务简介和使用
date: 2018-08-25 16:46:29
tags: [spring,transational]
categories: 技术文档
description: Spring配置事务和使用介绍
photos: 
    - "https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/hirokingraphy____utm_source=ig_share_sheet&igshid(1).jpg"
---
{% aplayer "Wagon Wheel" "Darius Rucker" 
"https://music-1258215793.cos.ap-shanghai.myqcloud.com/Darius%20Rucker%20-%20Wagon%20Wheel.mp3" "http://p1.music.126.net/_om-n1dhFKWJ5-gsONxlfg==/2469503116010039.jpg" "autoplay" %}

*参考博客：*
> http://tech.lede.com/2017/02/06/rd/server/SpringTransactional/

# **一．Spring @Transactioal的配置**
1. 在spring配置文件中引入命名空间
```
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
```
2. 在xml配置文件中添加事务管理器bean配置
```
<!-- 事务管理器配置，单数据源事务 -->
     <bean id="pkgouTransactionManager"
        class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="pkGouDataSource" />
    </bean>
<!-- 使用annotation定义事务 -->
<tx:annotation-driven transaction-manager="pkgouTransactionManager" />
```
3. 在使用事务的方法或类上添加注释
```
@Transactional(“pkgouTransactionManager”)
```

# **二．传播行为和隔离级别**
1. 事务注解方式：@Transactional
   * 标注在类前：标示类中的所有方法都进行事务处理。
   * 标注在接口，方法前：标示方法要进行事务处理。
2. 事务传播行为：


|事务传播行为|说明|
| :------ | :------: |
|@Transactional(propagation=Propagation.REQUIRED)|如果有事务则加入事务，若没则新建一个|
|@Transactional(propagation=Propagation.NOT_SUPPORTED)|容器不为该方法开启事务 |
|@Transactional(propagation=Propagation.REQUIRES_NEW)|无论是否存在事务，都会创建一个新的事务，旧的挂起，待新事务执行完毕，继续执行旧事务|
|@Transactional(propagation=Propagation.MANDATORY)|必须在一个已有的事务中执行，否则抛出异常|
|@Transactional(propagation=Propagation.NEVER)|必须在一个新的事务中执行，否则抛出异常|
|@Transactional(propagation=Propagation.SUPPORTS)|如果其他Bean调用该方法，且在其他bean中有声明事务，就使用事务，否则不用|

3. 事务超时设置
```
@Transactional(timeout=30)//默认30秒
```
4. 事务隔离级别

|事务隔离级别|说明|
| :------ | :------: |
|@Transactional(Isolation=READ_UNCOMMITED)|读取未提交数据，会出现脏读，不可重复读，基本不使用|
|@Transactional(Isolation=READ_COMMITED)|读取已提交数据，会出现不可重复读和幻读|
|@Transactional(Isolation=REPEATABLE_READ)|可重复读，会出现幻读|
|@Transactional(Isolation=SERIALIZABLE)|串行化|

* 脏读：一个事务读取到另一个事务未提交的更新数据
* 不可重复读：在同一个事务中，多次读取同一数据返回的结果有可能不同，即后续读取可以读取到另一事务提交的更新数据。
* 可重复读：在同一事务中多次读取数据时，能够保证所读数据一样，即后续读取不能读到另一事务已提交的更新数据。
* 幻读：一个事务读到另一个事务已提交的insert数据

**@Transactional属性**

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20180825/201808250101.png "")

# **三．工作原理**

## **显示事务，隐式事务**

* **隐式事务**：又叫自动提交事务，是数据库隐式做的事务，如插入语句会被包装进事务，当插入失败会回滚，每条sql语句都可以看作一个事务，无法明确指定事务的开始，默认connection被打开open
* **显式事务**：由自己即第三方明确指定的事务，明确指定事务的开始，需要打开connection，默认情况是closed
* **分布式事务(显式/隐式)**：跨库使用同一事务

## **自动提交**

&emsp;&emsp;默认情况下，数据库处于自动提交模式。

&emsp;&emsp;每一条语句处于一个单独的事务中，在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果执行失败则隐式的回滚事务。 

## **事务管理**

&emsp;&emsp;是一组相关的操作处于一个事务之中，因此必须关闭数据库的自动提交模式。

&emsp;&emsp;这点，Spring会在org/springframework/jdbc/datasource/DataSourceTransactionManager.java中将底层连接的自动提交特性设置为false。

```
// switch to manual commit if necessary。 this is very expensive in some jdbc drivers，
// so we don't want to do it unnecessarily (for example if we've explicitly
// configured the connection pool to set it already).+if (con.getautocommit()) 
{
    txobject.setmustrestoreautocommit(true);
    if (logger.isdebugenabled()) 
    {
        logger.debug("switching jdbc connection [" + con + "] to manual commit");
     }
     //首先将自动提交属性改为false
     con.setautocommit(false);
}
```
## **Spring事务回滚规则**

* Spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。
* Spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。 
* 默认配置下，Spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)。
* 而抛出checked异常则不会导致事务回滚。 
* Spring也支持明确的配置在抛出哪些异常时回滚事务，包括checked异常。
* 也可以明确定义哪些异常抛出时不回滚事务。 
* 还可以编程性的通过setRollbackOnly()方法来指示一个事务必须回滚，在调用完setRollbackOnly()后你所能执行的唯一操作就是回滚。

# **四．注意事项**

&emsp;&emsp;由于Spring事务管理是基于接口代理或动态字节码技术，通过AOP实施事务增强的。

1. 对于基于接口动态代理的AOP事务增强来说，由于接口的方法是public的，这就要求实现类的实现方法必须是public的（不能是protected，private等），同时不能使用static的修饰符。所以，可以实施接口动态代理的方法只能是使用“public” 或 “public final”修饰符的方法，其它方法不可能被动态代理，相应的也就不能实施AOP增强，也即不能进行Spring事务增强。

2. 基于CGLib字节码动态代理的方案是通过扩展被增强类，动态创建子类的方式进行AOP增强植入的。由于使用final,static,private修饰符的方法都不能被子类覆盖，相应的，这些方法将不能被实施的AOP增强。

&emsp;&emsp;所以，必须特别注意这些修饰符的使用，@Transactional 注解只被应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错，但是这个被注解的方法将不会展示已配置的事务设置。

* 用 spring 事务管理器，由spring来负责数据库的打开，提交，回滚。默认遇到运行期异常(throw new RuntimeException(“注释”);)会回滚，即遇到不受检查（unchecked）的异常时回滚；而遇到需要捕获的异常(throw new Exception(“注释”);)不会回滚，即遇到受检查的异常（就是非运行时抛出的异常，编译器会检查到的异常叫受检查异常或说受检查异常）时，需我们指定方式来让事务回滚 要想所有异常都回滚，要加上 @Transactional(rollbackFor={Exception。class，其它异常}) 。如果让unchecked异常不回滚：@Transactional(notRollbackFor=RunTimeException.class)如下:
```
@Transactional(rollbackFor=Exception.class) //指定回滚，遇到异常Exception时回滚
public void methodName() {
     throw new Exception("注释");
}
@Transactional(noRollbackFor=Exception.class)//指定不回滚，遇到运行期异常(throw new RuntimeException("注释");)会回滚
public ItimDaoImpl getItemDaoImpl() {
     throw new RuntimeException("注释");
}
```
&emsp;&emsp;仅仅 @Transactional注解的出现不足于开启事务行为，它仅仅是一种元数据，能够被可以识别 @Transactional注解和上述的配置适当的具有事务行为的beans所使用。其实，根本上是 元素的出现 开启了事务行为。

* Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因此，请接受Spring团队的建议并且在具体的类火方法上使用 @Transactional 注解。

* @Transactional 注解标识的方法，处理过程尽量的简单。尤其是带锁的事务方法，能不放在事务里面的最好不要放在事务里面。可以将常规的数据库查询操作放在事务前面进行，而事务内进行增、删、改、加锁查询等操作。

* @Transactional 注解的默认事务管理器bean是“transactionManager”，如果声明为其他名称的事务管理器，需要在方法上添加@Transational(“managerName”)。

* @Transactional 注解标注的方法中不要出现网络调用、比较耗时的处理程序，因为，事务中数据库连接是不会释放的，如果每个事务的处理时间都非常长，那么宝贵的数据库连接资源将很快被耗尽。

# **五．自我调用中的问题**

&emsp;&emsp;Spring事务使用AOP代理后的方法调用执行流程，如图所示：

![](https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20180825/201808250102.png "")

&emsp;&emsp;从图中可以看出，调用事务时首先调用的是AOP代理对象而不是目标对象，首先执行事务切面，事务切面内部通过TransactionInterceptor环绕增强进行事务的增强。即进入目标方法之前开启事务，退出目标方法时提交/回滚事务。

&emsp;&emsp;这样在自我调用时，则会出现无法开启事务的问题，比如：
```
public interface TargetService 
{  
    public void a();  
    public void b();  
}  
@Service 
public class TargetServiceImpl implements TargetService
{  
    public void a() 
    {  
        this.b();  
    }  
    @Transactional(propagation = Propagation.REQUIRES_NEW)  
    public void b() 
    {
    //执行数据库操作
    }  
}
```
&emsp;&emsp;此处的this指向目标对象，因此调用this.b()将不会执行b事务切面，即不会执行事务增强，因此b方法的事务定义“@Transactional(propagation = Propagation.REQUIRES_NEW)”将不会实施，即结果是b和a方法的事务是方法的事务定义是一样的。


**解决方法**

&emsp;&emsp;通过BeanPostProcessor 在目标对象中注入代理对象：

**一、定义BeanPostProcessor 需要使用的标识接口**

```
public interface BeanSelfAware
{
    public abstract void setSelf(Object obj);
}
```

**二、定义自己的BeanPostProcessor（InjectBeanSelfProcessor）**

```
public class InjectBeanSelfProcessor
    implements BeanPostProcessor, ApplicationContextAware
{
    ApplicationContext context;
    
    private static Log log = LogFactory.getLog(com/netease/lottery/base/common/BeanSelf/InjectBeanSelfProcessor);
    public InjectBeanSelfProcessor()
    {
    }
    public void setApplicationContext(ApplicationContext context)
        throws BeansException
    {
        this.context = context;
    }
    public Object postProcessAfterInitialization(Object bean, String beanName)
        throws BeansException
    {
        if(bean instanceof BeanSelfAware)
        {//如果Bean实现了BeanSelfAware标识接口，就将代理对象注入
            BeanSelfAware myBean = (BeanSelfAware)bean;
            Class cls = bean.getClass();
            if(!AopUtils.isAopProxy(bean))
            {
                Class c = bean.getClass();
                Service serviceAnnotation = (Service)c.getAnnotation(org/springframework/stereotype/Service);
                if(serviceAnnotation != null)
                    try
                    {
                        bean = context.getBean(beanName);
                        if(AopUtils.isAopProxy(bean));
                    }
                    catch(BeanCurrentlyInCreationException beancurrentlyincreationexception) { }
                    catch(Exception ex)
                    {
                        log.fatal((new StringBuilder()).append("No Proxy Bean for service ").append(bean.getClass()).append(" ").append(ex.getMessage()).toString(), ex);
                    }
            }
            myBean.setSelf(bean);
            return myBean;
        } else
        {
            return bean;
        }
    }
    public Object postProcessBeforeInitialization(Object bean, String beanName)
        throws BeansException
    {
        return bean;
    }
```

**三、目标类实现**

```
public interface TargetService 
{  
    public void a();  
    public void b();  
}  
@Service 
public class TargetServiceImpl implements TargetService,BeanSelfAware
{  
    private TargetService self;  
    public void setSelf(Object proxyBean) 
    { //通过InjectBeanSelfProcessor注入自己（目标对象）的AOP代理对象  
        this.self = (TargetService) proxyBean;  
    }  
    public void a() 
    {  
        self.b();  
    }  
    @Transactional(propagation = Propagation.REQUIRES_NEW)  
    public void b() 
    {
    //执行数据库操作
    }  
}
```
&emsp;&emsp;postProcessAfterInitialization根据目标对象是否实现BeanSelfAware标识接口，通过setSelf(bean)将代理对象（bean）注入到目标对象中，从而可以完成目标对象内部的自我调用。