---
title: Java对象克隆
date: 2018-08-30 23:46:36
tags: [java]
categories: 技术文档
description: Java对象的克隆方法，深度和浅度克隆的区别。
photos: 
    - "https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/football__hqs____utm_source=ig_share_sheet&igshid(4).jpg"
---
{% aplayer "Sakura" "嵐" 
"https://music-1258215793.cos.ap-shanghai.myqcloud.com/Sakura.mp3" "http://p1.music.126.net/g4S2IKRT3qZkPPH7I33dVA==/7907687627161169.jpg" "autoplay" %}
*参考博客：*
> https://www.cnblogs.com/Qian123/p/5710533.html

*相关代码：*
> https://github.com/LAILAIWA/Java

# **为什么要重写clone克隆对象？**
1. 需要新建一个对象来保存当前对象的状态。
2. 因为Java的赋值语句对于抽象对象来说是传递引用，所以复制对象需要特殊的实现
3. native方法，运行速度快

# **Java对象克隆**
Object这个类是由11个方法，其中有两个protected方法，其中一个为clone方法
```
protected native Object clone() throws CloneNotSupportedException;
```

它是native方法，就是非Java语言实现的代码，供Java程序调用，Java语言是运行于虚拟机上的，想要访问底层于操作系统相关的资源就需要底层语言来实现了。
* 第一次声明保证克隆对象有单独的内存地址分配
* 第二次声明表示原始对象和克隆对象有相同的类型
* 第三次声明表示原始和克隆的对象是平等的equals()方法使用

每个抽象类都继承了clone方法，但因为是protected所以无法在外部包使用，所以需要重写clone方法。

两种克隆方法：
* 浅克隆ShallowClone
* 深克隆DeepClone
两者的主要区别在是否支持成员变量是引用类型的复制。

步骤：
1.	被复制的类要先实现Cloneable接口，标记该类支持克隆，否则会抛出异常CloneNotSupportedException
2.	重写clone()方法，访问修饰符public。方法中调用super.clone()方法得到需要的复制对象。

> 源代码：项目-java 包-objectClone 类-ShallowClone
```
@Override
public Object clone(){
    ShallowClone clone = null;
    try{
        clone = (ShallowClone)super.clone();
    }catch (CloneNotSupportedException ex){
        ex.printStackTrace();
    }
    return clone;
}
```

> 源代码：项目-java 包-objectClone 类- DeepClone
```
@Override
public Object clone(){
    DeepClone clone = null;
    try{
        clone = (DeepClone)super.clone(); //浅复制
        clone.adress = (Adress) adress.clone(); //深复制
    }catch (CloneNotSupportedException ex){
        ex.printStackTrace();
    }
    return clone;
}
```
# **多层克隆问题**
  引用类型里面包含引用类型，此时使用覆盖clone方法会比较麻烦，而深克隆除了覆盖clone方法也可
  
>通过对象序列化来实现：
序列化就是将对象写入流中，是对原对象的拷贝，原对象仍然在内存中，需要对象类实现Serializable接口。
```
public SerializableClone ownClone(){//深度复制方法,需要对象及对象所有的对象属性都实现序列化
    SerializableClone clone = null;
    try{
        //将该对象序列化成流，是对对象的拷贝，原对象仍存活在JVM中
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
        objectOutputStream.writeObject(this);
        //将流序列化为对象
        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
        clone = (SerializableClone)objectInputStream.readObject();
    }catch (IOException | ClassNotFoundException ex){
        ex.printStackTrace();
    }
    return clone;
}
```


