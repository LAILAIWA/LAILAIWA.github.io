---
title: 算法复习 (一) 排序
date: 2018-07-30 14:48:00
tags: [algorithm,sort]
categories: 技术文档
description: 排序算法包括：选择排序，插入排序，希尔排序，快速排序等常用排序算法内容
photos: 
    - "https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/tinapouty_1___BfVFfHaHi54___.jpg"
---
{% aplayer "ラスト・シンデレラ" "FreeTEMPO" 
"http://pcvwwmd5n.bkt.clouddn.com/FreeTEMPO%20-%20%E3%83%A9%E3%82%B9%E3%83%88%E3%83%BB%E3%82%B7%E3%83%B3%E3%83%87%E3%83%AC%E3%83%A9.mp3" "http://p1.music.126.net/qdCz_G7r4dtlpKIE76laJw==/2405731441630133.jpg" "autoplay" %}

# **一些理论基础**

如何比较两种排序算法：
1.	实现并调试他们
2.	分析它们的基本性质
3.	对它们的相对性能做出猜想
4.	用实验证明猜想


# **排序算法回顾**
>**排序**：将一组对象按照某种逻辑顺序重新排列的过程 

接下来回顾一下常用的几种排序算法，实现代码可在GitHub中获取: 
>URL: https://github.com/LAILAIWA/AlgorithmTraining
>
>SSH: git@github.com:LAILAIWA/AlgorithmTraining.git
>
>代码位置：https://github.com/LAILAIWA/AlgorithmTraining/tree/master/src/sort

## **1.选择排序**
**选择排序**：找到数组中最小的元素，将其与数组第一个元素交换，继续在余下数组中循环此过程直到所有元素排序。

```
public static void sort(Comparable[] a){//将数组a按升序
    int N = a.length;//记录数组长度
    for(int i = 0;i < N;i++){//将a[i]与a[i+1...N]最小元素交换
        int min = i;
        for(int j = i+1;j < N;j++)
            if(less(a[j],a[min])) min = j;
        exch(a,i,min);
    }
}
```

>对于长度为N数组，选择排序需要N^2/2次比较和N次交换

**选择排序特点**：
1. 运行时间和输入无关，即使是已排序过的数组再排序亦无不同 
2. 数据移动是最少的

## **2.插入排序**
**插入排序**：每次将新来元素插入已经有序的数组中，右侧数据需要右移，当索引到达数组右端排序结束。

```
public static void sort(Comparable[] a){
    int N = a.length;
    for(int i = 1;i < N;i++){
        for(int j = i;j > 0 && less(a[j],a[j-1]);j--)
            exch(a,j,j-1);
    }
}
```

**插入排序特点**：运行时间取决于数组元素的初始顺序 
> * 对于长度为N的数组，插入排序平均需要N^2/4次比较以及N^2/4次交换；
> * 最坏需要N^2/2次比较以及N^2/2次交换；
> * 最好情况下需要N-1次比较和0次交换。

## **3.希尔排序**
**希尔排序**：基于插入排序的改进版本，针对乱序的数组，插入排序只交换相邻元素，而希尔排序则交换不相邻的元素对局部进行排序，最终用插入排序将局部有序的数组排序。

**排序思想**：使数组中固定间隔H内的元素是有序的，即H有序数组，一个由H个有序子数组组成的数组。
对于子数组用插入排序进行排序，将子数组中大的元素右移，移动距离由1改为H。
希尔排序之所以高效是因为其权衡了子数组的规模和有序性，初始时子数组较短，且都部分有序，这很适合插入排序。

```
public static void sort(Comparable[] a){
    int N = a.length;
    int H = 1;
    while (H < N/3)
        H = 3*H + 1;
    while (H >= 1){
        for(int i = H;i < N;i++){//将a[i]插入到a[i-H],a[i-2H]...之中
            for(int j = i; j >=H && less(a[j],a[j-H]);j-=H)
                exch(a,j,j-H);
        }
        H = H/3;
    }
}
```
>希尔排序的性能论证十分复杂，目前的结论是其运行时间达不到平方级别，最坏情况大概与N^3/2成正比，相比插入排序一点微小的改变就突破了平方的屏障，这正是算法设计的目标。

希尔排序通常会被有经验的程序员使用，一些更高效的算法除非对于N特别大的情景，一般只会比希尔排序快不到两倍，且设计复杂度会更大，所以可以首先考虑希尔排序再根据情况选择更复杂的排序算法。

## **4.归并排序**
**归并排序**：归并-将两个有序数组归并成一个更大的有序数组，根据这个思路设计归并排序，即对数组排序时，先将其分为两半分别排序，然后再将结果归并。归并排序可以保证任意长度N数组排序所需时间与NlogN成正比，缺点是所需额外空间与N成正比，用空间换时间。

**原地归并**：每次归并都创建新数组来存储排序结果是非常耗能的设计，所以需要在原数组中归并，采用共用一个公共数组来暂存数组数据。

**自顶向下的归并排序**：采用递归调用的方法，因为若归并排序可以将两个子数组排序，那么其就可以递归归并子数组来排序整个数组
对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组6NlgN次
数组规模较小使用插入排序

**自底向上的归并排序**： **分治思想**

**自底向上的归并排序**：自底向上的思路是从最小单元开始两两归并，相比标准递归方法所需的代码量会少一些。
>对于长度为N的任意数组，自底向上的归并排序需要1/2NlgN至NlgN次比较，最多访问数组6NlgN次
自底向上的归并排序比较适合链表组织的数据，从底层开始重新组织链接即可。

```
public class Merge extends SortExample {
    private static Comparable[] aux; //归并所需的辅助数组

    public static void sort(Comparable[] a){
        aux = new Comparable[a.length];//一次性分配空间
        sort(a,0,a.length-1);
    }

    private static void sort(Comparable[] a,int lo,int hi){//将数组a排序，递归排序，sort的作用为以正确的顺序调用merge方法
        if(hi <= lo) return;
        int mid = lo + (hi - lo)/2;
        sort(a,lo,mid);
        sort(a,mid+1,hi);
        merge(a,lo,mid,hi);
    }

    public static void sortBottomUp(Comparable[] a){//自底向上的归并排序，进行lgN次两两归并
        int N = a.length;
        aux = new Comparable[N];
        for(int sz = 1; sz < N ;sz = sz + sz) //sz-子数组大小
            for(int lo = 0; lo < N-sz;lo+=sz+sz) //子数组索引
                merge(a,lo,lo+sz-1,Math.min(lo+sz+sz-1,N-1));

    }

    public static void merge(Comparable[] a, int lo, int mid, int hi){//原地归并
        //将a[lo,mid]与a[mid+1,hi]归并，两个数组是有序的
        //先将所有元素复制到aux[]中，再归并到a[]中
        int i = lo,j = mid+1;
        for(int k = lo;k <= hi;k++)
            aux[k] = a[k];
        for(int k = lo;k <= hi;k++){//用i,j指针分别游离于两数组
            if(i > mid) a[k] = aux[j++]; //左边下标已结束
            else if(j > hi) a[k] = aux[i++];//右边下标已结束
            else if(less(aux[j],aux[i])) a[k] = aux[j++];//两数组的指针比较当前大小，前者较小
            else a[k] = aux[i++];
        }
    }

    public static void main(String[] args){
        Integer[] a = RandomUtil.getRandomIndex(10000);
        Stopwatch stopwatch = new Stopwatch();
        sort(a);
        System.out.println(stopwatch.elapseTime());
        show(a);
    }
}
```

>**排序算法的复杂度**
二叉树来表示比较，叶子结点的数量介于[N!,2^H]，H为最坏情况比较次数，根据斯特灵公式对阶乘函数的近似可得lgN!~NlgN
归并排序在最坏情况下比较次数为~NlgN，这是其他排序算法复杂度的上限，更好的算法需要保证更少的比较次数，

>**归并排序的局限性**：归并排序的空间复杂度不是最优的，实践中不一定会遇到最坏情况，除了比较一些如访问数据的操作可能也会很重要，不进行比较也可以将数据排序

## **5.快速排序**
**快速排序**

**优缺点**：
* 原地排序，只要一个很小的辅助栈
快速排序内循环比大部分排序要短小，因此速度较快
将长度为N的数组排序时间所需和NlgN成正比

* 需要小心避免性能低劣

快速排序是一种分治的排序算法，将数组分为两个子数组，子数组独立的排序，快排和归并排序是**互补**的：
>归并排序是将数组分为两个子数组分别排序，将有序的子数组归并从而将整个数组排序。
快速排序是将两个子数组顺序有序，当子数组内元素有序则数组自然有序。
归并排序递归调用发生在处理整个数组之前，快速排序递归调用发生在处理整个数组之后。
快排切分位置取决于输入数据，因为取数组a[lo]作为切分元素，根据归纳法来判断，快速排序递归过程能正确的将整个数组排序，有序的左数组右数组内元素都是有序的则整个数组一定有序。

**一些可能导致实现错误和性能下降的细节**：
1. 原地切分，我们用数组来辅助切分的话这当然是容易实现的，但这会增加复制过程的开销，有些经验较差的新手甚至可能会把空数组创建在递归过程，这会大大降低排序速度。
2. 不要越界，如果切分元素可能是最小或最大元素，就要小心不要将扫描指针跑出数组边界，在切分方法中可以检测来避免。
3. 切分元素有重复如何处理？左侧扫描在遇到大于等于即停下，右侧小于等于停下，虽然会进行等值交换，但会避免一些情况下运行时间变为平方级别：：：
4. 终止递归，快排常见的错误是忘记把切分元素放回正确的位置，导致切分元素一直是子数组的最大或最小元素，导致无限的递归循环

```
    public static void sort(Comparable[] a){
        //消除对输入的依赖，需要在这里把元素随机分布一下
        sort(a,0,a.length-1);

    }

    public static void sort(Comparable[] a,int lo,int hi){
        if(hi <= lo) return;
        int j = partition(a,lo,hi);//切分
        sort(a,lo,j-1);//将左半部分排序
        sort(a,j+1,hi);//将右半部分排序
    }

    private static int partition(Comparable[] a,int lo,int hi){//切分数组
        int i = lo,j = hi + 1; //左右扫描指针
        Comparable v = a[lo];  //切分元素
        while(true){
            //扫描左右，检查扫描是否结束并交换元素
            while(less(a[++i],v))
                if(i == hi) break;
            while(less(v,a[--j]))
                if(j == lo) break;
            if(i >= j) break;
            exch(a,i,j);
        }
        exch(a,lo,j); //将v=a[j]放入正确位置
        return j;    //a[lo...j-1] <= a[j] <= a[j+1...hi] 达成
    }
```

**快速排序的性能特点**：
切分方法的内循环通过一个递增的索引将数组元素和一个固定值来进行比较，这是最短的内循环了，如归并排序和希尔排序它们的内循环会移动数据。
快速排序比较次数很少，其排序效率依赖于切分数组的效果，最好就是每次都对半切分数组，这种情况下比较次数满足分支递归的CN=2C(N/2)+N公式，这个公式的解为CN~NlgN
对于长度为N的无重复元素数组排序平均需要~2NlnN次比较了，以及1/6的交换

注意，正是因为最糟糕情况，每次切分元素都刚好是剩余元素中最小的或最大的，那么最多需要N^2/2次比较，为了避免这种情况就在排序前随机打乱数组。
快速排序比归并排序比较次数会多一些，但移动数据次数要少，最终也会比归并排序快

**改进快速排序算法**：
基于以下两点：
1.	小数组，快速排序比插入排序慢
2.	因为递归，快速排序的sort方法在小数组中也会调用自己
所以

**一、根据数组大小切换到插入排序**
简单的写法是把sort()中的
if(hi <= lo) return;
修改为
if(hi <= lo + M) {
Insertion.sort(a,lo,hi);
return;
}
非常的机智的改法，指定参数M,只要排序数组大小符合就转换为插入排序，一般认为M在5到15很合适

**二、三取样切分**
该方法是使用子数组的一小部分元素的中位数来切分数组，这样得到的切分会更好，虽然多了计算中位数的开销，根据统计取样大小为3时并用大小居中的元素切分效果是最好的。
将取样元素放在数组末尾作为哨兵代替切分方法的数组边界测试。

```
    public static void sort(Comparable[] a){
        sort(a,0,a.length-1);
    }

    private static void sort(Comparable[] a,int lo,int hi){
        if(hi <= lo) return;
        int lt = lo,i = lo + 1,gt = hi;
        Comparable v = a[lo];
        while(i <= gt){
            //通过与切分元素比较
            int cmp = a[i].compareTo(v);
            if(cmp < 0) exch(a,lt++,i++);
            else if(cmp > 0) exch(a,i,gt--);
            else i++;
        }
        //a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]
        sort(a,lo,lt-1);
        sort(a,gt+1,hi);
    }
```

**三、熵最优排序**
当数组内有大量的重复元素时，快速排序有很大的改进空间
简单的想法就是将数组切分为三部分，分别对应小于等于大于切分元素的数组元素。但这种想法实现起来会很复杂。
**三项切分法的快速排序**：维护一个指针lt使a[lo..lt-1]的元素都小于v，一个指针gt使a[gt+1..hi]元素都大于v，一个指针i使a[lt..i-1]得元素都等于v，a[I,gt]中的元素还未确定

## **6.优先队列**
**优先队列**：
支持两种操作：删除最大元素和插入元素
从N个输入中找到最大的M个元素所需成本：
|          |  时间  |	空间  |
| :------: | ------ | ------ |
|排序算法	|NlogN	|N|
|初级实现的优先队列|	NM|	M|
|基于堆实现的优先队列|	NlogM|	M|

初级实现：
1. 数组实现（无序）
利用栈，插入元素就是入栈，内部需要类似选择排序的内循环的代码，将最大元素和边界元素交换并删除它，删除就是出栈。
2. 数组实现（有序）
在入栈时添加操作，让较大元素向右移动，保证数组总是有序的，最大的元素总是在边界，删除就完全和出栈一样了。
3. 链表表示法
基于链表的下压栈，使用有序或无序序列就是积极和惰性方法之分。
基于栈和队列来说，两个操作总会在最坏情况下需要线性时间来完成，但基于堆可以把时间从N改善到logN

**二叉堆**，在二叉堆数组中，每个元素都要保证大于等于另两个特定位置的元素，当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。
由根结点开始，一层一层由上至下由左至右，从每个结点下方连接两个更小的结点，直至N个结点连接完毕。
在一个堆中，位置K结点的父结点位置为k/2，子结点位置分别为2k，2k+1，所以在不使用指针时可以通过计算索引的方法在树上移动。
一棵大小为N的完全二叉树的高度为lgN

**堆的算法**：
用长度为N+1的私有数组pq[]来表示一个大小为N的堆，弃用pq[0]，堆元素放于1到N中。堆的操作首先需要打破堆的状态，然后再遍历堆按要求将堆的状态恢复，这个过程叫做**堆的有序化**。

**有序化过程的问题**：某个结点优先级上升，需要由下至上的恢复堆的顺序。某个结点优先级下降，需要由上至下恢复堆的顺序。
由下至上的堆有序化
将比父结点更大的结点和父结点互换，持续这一过程直到遇到比自己大的父结点，只要知道位置k的父结点为k/2这个过程实现十分容易。
由上至下的堆有序化
将父结点和子结点中较大者交换位置来恢复堆有序。
>可以将这两种过程看作严密的黑社会组织，swim过程即一位强力新人加入，逐级提升，直到有一个比他强力的领导，而sink过程为某级领导退休被外来者替代，该外来者需要被强力的下属替换，直到没有能力比其强的下属为止。

```
public class MaxPQ<T extends Comparable<T>> {
    private T[] pq;    //基于堆的完全二叉树
    private int N = 0; //存储于pq[1..N]中，pq[0]没有使用

    public MaxPQ(int maxN){
        pq = (T[]) new Comparable[maxN+1];
    }

    public boolean isEmpty(){
        return N == 0;
    }

    public int size(){
        return N;
    }

    public void insert(T t){
        pq[++N] = t; //新增结点
        swim(N);     //由下至上恢复堆的有序性
    }

    public T delMax(){
        T max = pq[1];   //从根节点得到最大元素
        exch(1, N--); //将其和最后一个结点交换
        pq[N+1] = null; //防止对象游离
        sink(1);      //由上至下恢复堆的有序性
        return max;
    }

    private boolean less(int i, int j){
        return pq[i].compareTo(pq[j]) < 0;
    }

    private void exch(int i, int j){
        T t = pq[i];
        pq[i] = pq[j];
        pq[j] = t;
    }

    private void swim(int k){
        while (k > 1 && less(k/2,k)){//循环判断条件，k>1,父结点的值比当前小
            //交换当前结点和父结点的值，以及当前游标所指下标
            exch(k/2,k);
            k = k/2;
        }
    }

    private void sink(int k){
        while (2*k <= N){//循环判断条件，当前游标所指有子结点存在
            int j = 2*k;
            //当子结点不是最后结点，且子结点小于右子结点，指较大的那个子结点
            if(j < N && less(j,j+1))
                j++;
            //如果当前结点比子结点大就跳出循环
            if(!less(k,j))
                break;
            //交换，更新游标
            exch(k,j);
            k = j;
        }
    }
}
```

对于一个含N个元素的基于堆的优先队列，插入元素操作只需不超过lgN+1次比较，删除最大元素只需不超过2lgN次比较


**基于堆的索引优先队列**IndexMinPQ
快速访问最小元素的数组，
在一个大小为N的索引优先队列中，插入元素，改变优先级，删除，删除最小元素操作所需的比较次数和logN成正比

```
public class IndexMinPQ<T extends Comparable<T>> {
    private int N;       //PQ中的元素数量
    private int[] pq;    //索引二叉堆，由1开始
    private int[] qp;    //逆序，qp[pq[i]] = pq[qp[i]] = i
    private T[] keys;    //有优先级之分的元素
    public IndexMinPQ(int maxN){
        keys = (T[]) new Comparable[maxN + 1];
        pq = new int[maxN + 1];
        qp = new int[maxN + 1];
        for (int i = 0;i <= maxN; i++)
            qp[i] = -1;
    }

    public boolean isEmpty(){
        return N == 0;
    }

    public boolean comtains(int k){
        return qp[k] != -1;
    }

    public int size(){
        return N;
    }

    public void insert(int k,T t){
        N++;
        qp[k] = N;
        pq[N] = k;
        keys[k] = t;
        swim(N);
    }

    public T min(){
        return keys[pq[1]];
    }

    public int delMin(){
        int indexOfMin = pq[1];
        exch(1,N--);
        sink(1);
        keys[pq[N+1]] = null;
        qp[pq[N+1]] = -1;
        return indexOfMin;
    }

    public int minIndex(){
        return pq[1];
    }

    public void change(int k,T t){
        keys[k] = t;
        swim(qp[k]);
        sink(qp[k]);
    }

    public void delete(int k){
        int index = qp[k];
        exch(index,N--);
        swim(index);
        sink(index);
        keys[k] = null;
        qp[k] = -1;
    }


    private boolean less(int i, int j){
        return keys[i].compareTo(keys[j]) < 0;
    }

    private void exch(int i, int j){
        T t = keys[i];
        keys[i] = keys[j];
        keys[j] = t;
    }

    private void swim(int k){
        while (k > 1 && less(k/2,k)){//循环判断条件，k>1,父结点的值比当前小
            //交换当前结点和父结点的值，以及当前游标所指下标
            exch(k/2,k);
            k = k/2;
        }
    }

    private void sink(int k){
        while (2*k <= N){//循环判断条件，当前游标所指有子结点存在
            int j = 2*k;
            //当子结点不是最后结点，且子结点小于右子结点，指较大的那个子结点
            if(j < N && less(j,j+1))
                j++;
            //如果当前结点比子结点大就跳出循环
            if(!less(k,j))
                break;
            //交换，更新游标
            exch(k,j);
            k = j;
        }
    }
}
```

可通过IndexMinPQ将多行输入的字符串归并为一行有序的输出，所以优先队列可以变为一种排序方法：**堆排序**。将所有元素插入一个查找最小元素的优先队列，然后重复调用删除最小元素的操作将元素按顺序删除。
对于无序数组实现的优先队列就等同于插入排序，而堆排序则是一种全新的排序方法。

堆排序分为两个阶段：
* 堆的构造阶段，将原始数组重新安排进一个堆中。
* 下沉排序阶段，从堆中按递减顺序取出所有元素并得到排序结果。

```
/**
 * 堆排序
 */
public class Set extends SortExample {
    public static Comparable[] sort(Comparable[] c){
        Comparable[] a = new Comparable[c.length+1];
        int N = c.length;
        for (int i = 0;i < N;i++)
            a[i+1] = c[i];
        //for循环构造堆，sink方法将a从1到N排序
        for(int k = N/2; k >= 1; k--)
            sink(a,k,N);
        show(a);
        //while循环将最大元素a[1]和a[N]交换，并修复堆
        while (N > 1){
            exch(a,1,N--);
            sink(a,1,N);
            show(a);
        }
        return a;
    }

    private static void swim(Comparable[] a,int k){
        while (k > 1 && less(k/2,k)){//循环判断条件，k>1,父结点的值比当前小
            //交换当前结点和父结点的值，以及当前游标所指下标
            exch(a,k/2,k);
            k = k/2;
        }
    }

    private static void sink(Comparable[] a,int k,int N){
        while (2*k <= N){//循环判断条件，当前游标所指有子结点存在
            int j = 2*k;
            //当子结点不是最后结点，且子结点小于右子结点，指较大的那个子结点
            if(j < N && less(a[j],a[j+1]))
                j++;
            //如果当前结点比子结点大就跳出循环
            if(!less(a[k],a[j]))
                break;
            //交换，更新游标
            exch(a,k,j);
            k = j;
        }
    }

    public static void exch(Comparable[] a,int i, int j){
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    public static void main(String[] args){
       // Integer[] a = RandomUtil.getRandomIndex(10000);
        Comparable[] a = {'S','O','R','T','E','X','A','M','P','L','E'};
        Stopwatch stopwatch = new Stopwatch();
        a = sort(a);
        System.out.println(stopwatch.elapseTime());
        show(a);
    }
}
```

**堆的构造**：
普通做法：从左至右遍历数组，用swim()保证指针左侧是一棵堆有序的二叉树，时间与NlgN成正比。
更高效的做法：从右至左用sink()函数构造子堆，数组每个位置都是子堆的一个根结点，若一个结点的两个子结点都是堆在该节点调用sink()将它们变成一个堆，递归此过程直到最后在位置1调用sink。在堆的构造阶段，最大元素是位于数组的开头，而不是结尾。

堆排序将N个元素排序，只需要少于2NlgN+2N次比较，以及一半次数的交换
堆排序使用空间是额定的，所以在一些嵌入式系统中很流行，但其无法利用缓存，因为数组元素很少和相邻元素比较，但另一方面，用堆实现的优先队列在如今越来越重要，因为其两个基本操作混合的场景中保证对数级别的运行时间。

# **排序算法实际应用**
**排序应用时注意**：
1. 不可变的键：尽量使用不可变数据类型来作键，如String，Integer，Double，File
2. 廉价交换：若元素大而键小，可以使用引用排序，避免元素的交换操作。
3. 多键数组：应用场景中，可能元素多种属性都可以当作排序的键，Comparator接口可以定义多种比较器，甚至定义多种排序方法

**各种排序算法的比较**

>测试用例：1万个随机整数[0,9999]

|算法	|100次运行平均所用时间|
| ------ | :------: |
|选择排序 |0.0718|
|插入排序 |0.1156|
|希尔排序 |0.0025|
|快速排序 |0.0014|
|三向快速排序|0.0021|
|归并排序 |0.0031|
|堆排序   |0.0020|

取随机数耗时比较大，测试的时候注意把取随机数的时间过滤。

|算法	|是否稳定|	原地排序？|	时间复杂度|	空间复杂度|	备注|
| ------ | ------ | ------ | ------ | ------ | :------: |
|选择排序 |	否     |	是  |	N^2  |	1	  |            |
|插入排序 |	是     |	是  |	N~N^2|	1	  |取决于输入元素的排列情况|
|希尔排序 |	否     |	是  |	NlogN? N^(6/5)?|1|            |		
|快速排序 |	否     |	是  |	NlogN|	lgN	  | 运行效率由概率提供保证|	
|三向快速排序|	否 |	是  |	N~NlogN|lgN	   |运行效率由概率保证，同时也取决于输入元素的分布情况|	
|归并排序 |	是     |	否  |	NlogN|	N	  |            |
|堆排序   |	否     |	是  |	NlogN|	1     |            |

>快速排序是最快的通用排序算法，大多数实际情况快排是最佳选择，但如看重稳定性又不在意空间的场景，归并排序是更好的选择。

>Java 的Arrays.sort()是对原始数据类型进行三向快速排序，对引用类型使用归并排序，也暗示了用空间来换取稳定性。




