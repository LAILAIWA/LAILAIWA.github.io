---
title: SpringBoot日志简单整理
date: 2018-10-29 09:29:32
tags: [spring boot,log,AOP,log4j]
description: 简单实现了SpringBoot日志框架log4j2，生成日志文件以便记录操作信息，保证软件安全性，以及方便后期维护。
categories: 技术文档
photos: 
    - "https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/39saku_chan_1____utm_source=ig_share_sheet&igshid=16t1lejf3qc0f___.jpg"
---
{% aplayer "雨声" "B.A.P" 
"https://music-1258215793.cos.ap-shanghai.myqcloud.com/B.A.P-%EB%B9%97%EC%86%8C%EB%A6%AC.mp3" "http://p1.music.126.net/3O023Ipet7UoTpdKQcZ46Q==/2501388953245183.jpg" "autoplay" %}

# **Spring Boot 日志**

## **logback和log4j对比**

>参考博客：http://blog.51cto.com/wyait/1969613

Java日志库常用的有java.util.logging、commons logging、slf4j、log4j1.x、logback、log4j2.x等。

log4j2是log4j1的替代者。

Spring Boot内置默认日志为logback.

logback相比log4j1在性能，稳定性，方便使用等方面有很大提升。

log4j2相较logback，在重新配置时不会丢失历史数据，多线程场景效率较高，扩展性高，并发同步服务支持度比较高。

## **Spring Boot集成log4j2**

### **1.引入log4j2依赖，移除默认日志**

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <exclusions>
        <!-- 移除日志 -->
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
    <version>2.0.5.RELEASE</version>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

### **2.新建配置文件log4j.properties**

```
log4j.rootLogger = debug,stdout,D,E
### 输出到控制台 ###
log4j.appender.stdout = org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target = System.out
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern =  %d{ABSOLUTE} %5p %c{1}:%L - %m%n

### 输出到日志文件 ###
log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File = /Java/logs/COUNSELOR_MANAGEMENT/log.log
log4j.appender.D.Append = true
log4j.appender.D.Threshold = DEBUG
log4j.appender.D.layout = org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [%t:%r] - [%p]  %m%n

### 保存异常信息到单独文件 ###
log4j.appender.E = org.apache.log4j.DailyRollingFileAppender
log4j.appender.E.File = /Java/logs/COUNSELOR_MANAGEMENT/error.log
log4j.appender.E.Append = true
log4j.appender.E.Threshold = ERROR
log4j.appender.E.layout = org.apache.log4j.PatternLayout
log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [%t:%r] - [%p]  %m%n
```

### **3.用AOP方法对请求消息进行log处理**

```
@Aspect
@Component
public class HttpAspect {
    private Logger logger = Logger.getLogger(HttpAspect.class);

    @Pointcut("execution(public * com.lai.counselorManagement.controller.*.*(..))")
    public void log(){}

    //@Before 在方法执行之前执行
    @Before("log()")
    public void doBefore(JoinPoint joinPoint){
        //记录http请求
        ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        //从request中获取http请求的url/请求的方法类型／响应该http请求的类方法／IP地址／请求中的参数
        logger.info("-----------------------------------------------------------------------------------------------------------");
        //得到session对象
        HttpSession session = request.getSession(false);
        //取出请求用户
        String userId = (String)session.getAttribute("type");
        //userId
        logger.info("请求用户[userId] = {" + userId + "}");
        //ip
        logger.info("访问IP[IP] = {" + request.getRemoteAddr() + "}");
        //url
        logger.info("请求地址[URL] = {" + request.getRequestURI() + "}");
        //method
        logger.info("HTTP方法[method] = {" + request.getMethod() + "}");
        //控制层
        logger.info("控制层[class] = {" + joinPoint.getSignature().getDeclaringTypeName() + "}");
        //方法
        logger.info("请求服务[method] = {" + joinPoint.getSignature().getName() + "}");
        //参数
        Object[] objects = joinPoint.getArgs();
        String[] argNames = ((MethodSignature)joinPoint.getSignature()).getParameterNames(); // 参数名
        for(int i = 0;i < objects.length;i++){
            logger.info("参数[" + argNames[i] + "] = {" + objects[i].toString() + "}");
        }
        logger.info("-----------------------------------------------------------------------------------------------------------");
    }

//    //@After在方法执行之后执行
//    @After("log()")
//    public void doAfter(){
//        System.out.println("doAfter");
//    }
}
```

